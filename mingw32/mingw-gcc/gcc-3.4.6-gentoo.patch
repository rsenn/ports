diff -r -u -N gcc-3.4.6_orig/gcc/Makefile.in gcc-3.4.6/gcc/Makefile.in
--- gcc-3.4.6_orig/gcc/Makefile.in	2007-09-30 14:28:18.000000000 +0200
+++ gcc-3.4.6/gcc/Makefile.in	2007-09-30 14:37:08.000000000 +0200
@@ -1186,6 +1186,7 @@
 	SHLIB_MAPFILES='$(SHLIB_MAPFILES)' \
 	SHLIB_NM_FLAGS='$(SHLIB_NM_FLAGS)' \
 	MULTILIB_OSDIRNAMES='$(MULTILIB_OSDIRNAMES)' \
+	GCC_FOR_TARGET='$(GCC_FOR_TARGET)' \
 	mkinstalldirs='$(SHELL) $(srcdir)/mkinstalldirs' \
 	  $(SHELL) mklibgcc > tmp-libgcc.mk
 	mv tmp-libgcc.mk libgcc.mk
@@ -2505,6 +2506,9 @@
 	rm -f include/limits.h
 	cp xlimits.h include/limits.h
 	chmod a+r include/limits.h
+	if [ x"$(STMP_FIXINC)" = x ]; then \
+	  cp $(srcdir)/gsyslimits.h include/syslimits.h; \
+	fi
 # Install the README
 	rm -f include/README
 	cp $(srcdir)/README-fixinc include/README
@@ -2917,7 +2921,7 @@
 	  else true; fi; \
 	done
 # Don't mess with specs if it doesn't exist yet.
-	-if [ -f specs ] ; then \
+	-if [ -f specs ] && [ x"$(STMP_FIXINC)" != x ] ; then \
 	  rm -f $(DESTDIR)$(libsubdir)/specs; \
 	  $(INSTALL_DATA) $(SPECS) $(DESTDIR)$(libsubdir)/specs; \
 	  chmod a-x $(DESTDIR)$(libsubdir)/specs; \
diff -r -u -N gcc-3.4.6_orig/gcc/c-common.c gcc-3.4.6/gcc/c-common.c
--- gcc-3.4.6_orig/gcc/c-common.c	2007-09-30 14:28:19.000000000 +0200
+++ gcc-3.4.6/gcc/c-common.c	2007-09-30 14:32:22.000000000 +0200
@@ -832,7 +832,7 @@
 			      handle_deprecated_attribute },
   { "vector_size",	      1, 1, false, true, false,
 			      handle_vector_size_attribute },
-  { "visibility",	      1, 1, true,  false, false,
+  { "visibility",	      1, 1, false, false, false,
 			      handle_visibility_attribute },
   { "tls_model",	      1, 1, true,  false, false,
 			      handle_tls_model_attribute },
@@ -4937,7 +4937,16 @@
 
   *no_add_attrs = true;
 
-  if (decl_function_context (decl) != 0 || ! TREE_PUBLIC (decl))
+  if (TYPE_P (*node))
+    {
+      if (TREE_CODE (*node) != RECORD_TYPE && TREE_CODE (*node) != UNION_TYPE)
+       {
+         warning ("`%s' attribute ignored on non-class types",
+                  IDENTIFIER_POINTER (name));
+         return NULL_TREE;
+       }
+    }
+  else if (decl_function_context (decl) != 0 || ! TREE_PUBLIC (decl))
     {
       warning ("`%s' attribute ignored", IDENTIFIER_POINTER (name));
       return NULL_TREE;
@@ -4948,6 +4957,14 @@
       error ("visibility arg not a string");
       return NULL_TREE;
     }
+  
+  /*  If this is a type, set the visibility on the type decl.  */
+  if (TYPE_P (decl))
+    {
+      decl = TYPE_NAME (decl);
+      if (! decl)
+        return NULL_TREE;
+    }
 
   if (strcmp (TREE_STRING_POINTER (id), "default") == 0)
     DECL_VISIBILITY (decl) = VISIBILITY_DEFAULT;
@@ -4959,6 +4976,14 @@
     DECL_VISIBILITY (decl) = VISIBILITY_PROTECTED;
   else
     error ("visibility arg must be one of \"default\", \"hidden\", \"protected\" or \"internal\"");
+  DECL_VISIBILITY_SPECIFIED (decl) = 1;
+
+  /* For decls only, go ahead and attach the attribute to the node as well.
+     This is needed so we can determine whether we have VISIBILITY_DEFAULT
+     because the visibility was not specified, or because it was explicitly
+     overridden from the class visibility.  */
+  if (DECL_P (*node))
+    *no_add_attrs = false;
 
   return NULL_TREE;
 }
diff -r -u -N gcc-3.4.6_orig/gcc/c-decl.c gcc-3.4.6/gcc/c-decl.c
--- gcc-3.4.6_orig/gcc/c-decl.c	2007-09-30 14:28:12.000000000 +0200
+++ gcc-3.4.6/gcc/c-decl.c	2007-09-30 14:34:21.000000000 +0200
@@ -1173,9 +1173,8 @@
     }
 
   /* warnings */
-  /* All decls must agree on a non-default visibility.  */
-  if (DECL_VISIBILITY (newdecl) != VISIBILITY_DEFAULT
-      && DECL_VISIBILITY (olddecl) != VISIBILITY_DEFAULT
+  /* All decls must agree on a visibility.  */
+  if (DECL_VISIBILITY_SPECIFIED (newdecl) && DECL_VISIBILITY_SPECIFIED (olddecl)
       && DECL_VISIBILITY (newdecl) != DECL_VISIBILITY (olddecl))
     {
       warning ("%Jredeclaration of '%D' with different visibility "
@@ -1378,9 +1377,12 @@
      Currently, it can only be defined in the prototype.  */
   COPY_DECL_ASSEMBLER_NAME (olddecl, newdecl);
 
-  /* If either declaration has a nondefault visibility, use it.  */
-  if (DECL_VISIBILITY (olddecl) != VISIBILITY_DEFAULT)
-    DECL_VISIBILITY (newdecl) = DECL_VISIBILITY (olddecl);
+  /* Use visibility of whichever declaration had it specified */
+  if (DECL_VISIBILITY_SPECIFIED (olddecl))
+    {
+      DECL_VISIBILITY (newdecl) = DECL_VISIBILITY (olddecl);
+      DECL_VISIBILITY_SPECIFIED (newdecl) = 1;
+    }
 
   if (TREE_CODE (newdecl) == FUNCTION_DECL)
     {
@@ -2820,7 +2822,7 @@
 	{
 	  tree builtin = built_in_decls [DECL_FUNCTION_CODE (decl)];
 	  SET_DECL_RTL (builtin, NULL_RTX);
-	  SET_DECL_ASSEMBLER_NAME (builtin, get_identifier (starred));
+	  change_decl_assembler_name (builtin, get_identifier (starred));
 #ifdef TARGET_MEM_FUNCTIONS
 	  if (DECL_FUNCTION_CODE (decl) == BUILT_IN_MEMCPY)
 	    init_block_move_fn (starred);
diff -r -u -N gcc-3.4.6_orig/gcc/c-opts.c gcc-3.4.6/gcc/c-opts.c
--- gcc-3.4.6_orig/gcc/c-opts.c	2007-09-30 14:28:12.000000000 +0200
+++ gcc-3.4.6/gcc/c-opts.c	2007-09-30 14:32:22.000000000 +0200
@@ -633,6 +633,10 @@
       cpp_opts->warn_traditional = value;
       break;
 
+    case OPT_Wtrampolines:
+      warn_trampolines = value;
+      break;
+
     case OPT_Wtrigraphs:
       cpp_opts->warn_trigraphs = value;
       break;
@@ -921,6 +925,10 @@
     case OPT_fuse_cxa_atexit:
       flag_use_cxa_atexit = value;
       break;
+      
+    case OPT_fvisibility_inlines_hidden:
+      visibility_options.inlines_hidden = value;
+      break;
 
     case OPT_fweak:
       flag_weak = value;
diff -r -u -N gcc-3.4.6_orig/gcc/c-pragma.c gcc-3.4.6/gcc/c-pragma.c
--- gcc-3.4.6_orig/gcc/c-pragma.c	2007-09-30 14:28:11.000000000 +0200
+++ gcc-3.4.6/gcc/c-pragma.c	2007-09-30 14:32:22.000000000 +0200
@@ -481,6 +481,86 @@
   return asmname;
 }
 
+
+#ifdef HANDLE_PRAGMA_VISIBILITY
+static void handle_pragma_visibility (cpp_reader *);
+
+/* Sets the default visibility for symbols to something other than that
+   specified on the command line.  */
+static void
+handle_pragma_visibility (cpp_reader *dummy ATTRIBUTE_UNUSED)
+{ /* Form is #pragma GCC visibility push(hidden)|pop */
+  static int visstack [16], visidx;
+  tree x;
+  enum cpp_ttype token;
+  enum { bad, push, pop } action = bad;
+ 
+  token = c_lex (&x);
+  if (token == CPP_NAME)
+    {
+      const char *op = IDENTIFIER_POINTER (x);
+      if (!strcmp (op, "push"))
+        action = push;
+      else if (!strcmp (op, "pop"))
+        action = pop;
+    }
+  if (bad == action)
+    GCC_BAD ("#pragma GCC visibility must be followed by push or pop");
+  else
+    {
+      if (pop == action)
+        {
+          if (!visidx)
+            {
+              GCC_BAD ("No matching push for '#pragma GCC visibility pop'");
+            }
+          else
+            {
+              default_visibility = visstack[--visidx];
+              visibility_options.inpragma = (visidx>0);
+            }
+        }
+      else
+        {
+          if (c_lex (&x) != CPP_OPEN_PAREN)
+            GCC_BAD ("missing '(' after '#pragma GCC visibility push' - ignored");
+          token = c_lex (&x);
+          if (token != CPP_NAME)
+            {
+              GCC_BAD ("malformed #pragma GCC visibility push");
+            }
+          else if (visidx >= 16)
+            {
+              GCC_BAD ("No more than sixteen #pragma GCC visibility pushes allowed at once");
+            }
+          else
+            {
+              const char *str = IDENTIFIER_POINTER (x);
+              visstack[visidx++] = default_visibility;
+              if (!strcmp (str, "default"))
+                default_visibility = VISIBILITY_DEFAULT;
+              else if (!strcmp (str, "internal"))
+                default_visibility = VISIBILITY_INTERNAL;
+              else if (!strcmp (str, "hidden"))
+                default_visibility = VISIBILITY_HIDDEN;  
+              else if (!strcmp (str, "protected"))
+                default_visibility = VISIBILITY_PROTECTED;
+              else
+                {
+                  GCC_BAD ("#pragma GCC visibility push() must specify default, internal, hidden or protected");
+                }
+              visibility_options.inpragma = 1;
+            }
+          if (c_lex (&x) != CPP_CLOSE_PAREN)
+            GCC_BAD ("missing '(' after '#pragma GCC visibility push' - ignored");
+        }
+    }
+  if (c_lex (&x) != CPP_EOF)
+    warning ("junk at end of '#pragma GCC visibility'");
+}
+
+#endif
+
 /* Front-end wrapper for pragma registration to avoid dragging
    cpplib.h in almost everywhere.  */
 void
@@ -506,6 +586,9 @@
 #ifdef HANDLE_PRAGMA_EXTERN_PREFIX
   c_register_pragma (0, "extern_prefix", handle_pragma_extern_prefix);
 #endif
+#ifdef HANDLE_PRAGMA_VISIBILITY
+  c_register_pragma ("GCC", "visibility", handle_pragma_visibility);
+#endif
 
 #ifdef REGISTER_TARGET_PRAGMAS
   REGISTER_TARGET_PRAGMAS ();
diff -r -u -N gcc-3.4.6_orig/gcc/c-pragma.h gcc-3.4.6/gcc/c-pragma.h
--- gcc-3.4.6_orig/gcc/c-pragma.h	2007-09-30 14:28:22.000000000 +0200
+++ gcc-3.4.6/gcc/c-pragma.h	2007-09-30 14:32:22.000000000 +0200
@@ -44,6 +44,11 @@
 #define HANDLE_PRAGMA_PACK 1
 #endif /* HANDLE_PRAGMA_PACK_PUSH_POP */
 
+/* It's safe to always leave visibility pragma enabled as if
+   visibility is not supported on the host OS platform the
+   statements are ignored.  */
+#define HANDLE_PRAGMA_VISIBILITY 1
+
 extern void init_pragma (void);
 
 /* Front-end wrapper for pragma registration to avoid dragging
diff -r -u -N gcc-3.4.6_orig/gcc/c.opt gcc-3.4.6/gcc/c.opt
--- gcc-3.4.6_orig/gcc/c.opt	2007-09-30 14:28:09.000000000 +0200
+++ gcc-3.4.6/gcc/c.opt	2007-09-30 14:32:22.000000000 +0200
@@ -380,6 +380,10 @@
 C ObjC
 Warn about features not present in traditional C
 
+Wtrampolines
+C ObjC C++ ObjC++
+Warn whenever the compiler generates a trampoline
+
 Wtrigraphs
 C ObjC C++ ObjC++
 Warn if trigraphs are encountered that might affect the meaning of the program
@@ -656,6 +660,10 @@
 C++ ObjC++
 Use __cxa_atexit to register destructors
 
+fvisibility-inlines-hidden
+C++
+Marks all inlined methods as having hidden visibility
+
 fvtable-gc
 C++ ObjC++
 Discard unused virtual functions
diff -r -u -N gcc-3.4.6_orig/gcc/collect2.c gcc-3.4.6/gcc/collect2.c
--- gcc-3.4.6_orig/gcc/collect2.c	2007-09-30 14:28:22.000000000 +0200
+++ gcc-3.4.6/gcc/collect2.c	2007-09-30 14:30:39.000000000 +0200
@@ -36,6 +36,12 @@
 #if ! defined( SIGCHLD ) && defined( SIGCLD )
 #  define SIGCHLD SIGCLD
 #endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#if HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
 
 #ifndef LIBRARY_PATH_ENV
 #define LIBRARY_PATH_ENV "LIBRARY_PATH"
@@ -1589,14 +1595,24 @@
   do_wait (prog);
 }
 
-/* Unlink a file unless we are debugging.  */
-
+/* Unlink a file unless we are debugging or file is not normal.  */
+#ifndef S_ISLNK
+#ifdef S_IFLNK
+#define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
+#else
+#define S_ISLNK(m) 0
+#define lstat stat
+#endif
+#endif
 static void
 maybe_unlink (const char *file)
 {
-  if (!debug)
-    unlink (file);
-  else
+  if (!debug) {
+    struct stat st;
+    if (lstat (file, &st) == 0
+        && (S_ISREG (st.st_mode) || S_ISLNK (st.st_mode)))
+      unlink (file);
+  } else
     notice ("[Leaving %s]\n", file);
 }
 
diff -r -u -N gcc-3.4.6_orig/gcc/common.opt gcc-3.4.6/gcc/common.opt
--- gcc-3.4.6_orig/gcc/common.opt	2007-09-30 14:28:19.000000000 +0200
+++ gcc-3.4.6/gcc/common.opt	2007-09-30 14:32:22.000000000 +0200
@@ -718,6 +718,11 @@
 Common
 Add extra commentary to assembler output
 
+fvisibility=
+Common Joined RejectNegative
+-fvisibility=[default|internal|hidden|protected]	Set the default symbol visibility
+
+
 fvpt
 Common
 Use expression value profiles in optimizations
diff -r -u -N gcc-3.4.6_orig/gcc/config/alpha/alpha.h gcc-3.4.6/gcc/config/alpha/alpha.h
--- gcc-3.4.6_orig/gcc/config/alpha/alpha.h	2007-09-30 14:28:13.000000000 +0200
+++ gcc-3.4.6/gcc/config/alpha/alpha.h	2007-09-30 14:30:26.000000000 +0200
@@ -96,7 +96,7 @@
   while (0)
 #endif
 
-#define CPP_SPEC "%(cpp_subtarget)"
+#define CPP_SPEC "%(cpp_subtarget) %{!no-ieee:-mieee}"
 
 #ifndef CPP_SUBTARGET_SPEC
 #define CPP_SUBTARGET_SPEC ""
@@ -301,6 +301,8 @@
      N_("Request IEEE-conformant math library routines (OSF/1)")},	\
     {"ieee", MASK_IEEE|MASK_IEEE_CONFORMANT,				\
      N_("Emit IEEE-conformant code, without inexact exceptions")},	\
+    {"no-ieee", - (MASK_IEEE|MASK_IEEE_CONFORMANT),				\
+     N_("Do not emit IEEE-conformant code, without inexact exceptions")},	\
     {"ieee-with-inexact", MASK_IEEE_WITH_INEXACT|MASK_IEEE_CONFORMANT,	\
      N_("Emit IEEE-conformant code, with inexact exceptions")},		\
     {"build-constants", MASK_BUILD_CONSTANTS,				\
diff -r -u -N gcc-3.4.6_orig/gcc/config/arm/arm.c gcc-3.4.6/gcc/config/arm/arm.c
--- gcc-3.4.6_orig/gcc/config/arm/arm.c	2007-09-30 14:28:16.000000000 +0200
+++ gcc-3.4.6/gcc/config/arm/arm.c	2007-09-30 14:33:31.000000000 +0200
@@ -4572,6 +4572,10 @@
 int
 adjacent_mem_locations (rtx a, rtx b)
 {
+  /* We don't guarantee to preserve the order of these memory refs.  */
+  if (volatile_refs_p (a) || volatile_refs_p (b))
+    return 0;
+
   if ((GET_CODE (XEXP (a, 0)) == REG
        || (GET_CODE (XEXP (a, 0)) == PLUS
 	   && GET_CODE (XEXP (XEXP (a, 0), 1)) == CONST_INT))
@@ -4611,6 +4615,17 @@
 	return 0;
 
       val_diff = val1 - val0;
+
+      if (arm_ld_sched)
+	{
+	  /* If the target has load delay slots, then there's no benefit
+	     to using an ldm instruction unless the offset is zero and
+	     we are optimizing for size.  */
+	  return (optimize_size && (REGNO (reg0) == REGNO (reg1))
+		  && (val0 == 0 || val1 == 0 || val0 == 4 || val1 == 4)
+		  && (val_diff == 4 || val_diff == -4));
+	}
+
       return ((REGNO (reg0) == REGNO (reg1))
 	      && (val_diff == 4 || val_diff == -4));
     }
@@ -4857,6 +4872,11 @@
       *load_offset = unsorted_offsets[order[0]];
     }
 
+  /* For XScale a two-word LDM is a performance loss, so only do this if
+     size is more important.  See comments in arm_gen_load_multiple.  */
+  if (nops == 2 && arm_tune_xscale && !optimize_size)
+    return 0;
+
   if (unsorted_offsets[order[0]] == 0)
     return 1; /* ldmia */
 
@@ -5083,6 +5103,11 @@
       *load_offset = unsorted_offsets[order[0]];
     }
 
+  /* For XScale a two-word LDM is a performance loss, so only do this if
+     size is more important.  See comments in arm_gen_load_multiple.  */
+  if (nops == 2 && arm_tune_xscale && !optimize_size)
+    return 0;
+
   if (unsorted_offsets[order[0]] == 0)
     return 1; /* stmia */
 
@@ -8514,6 +8539,26 @@
   return_used_this_function = 0;  
 }
 
+/* Return the number (counting from 0) of
+   the least significant set bit in MASK.  */
+
+#ifdef __GNUC__
+inline
+#endif
+static int
+number_of_first_bit_set (mask)
+     int mask;
+{
+  int bit;
+
+  for (bit = 0;
+       (mask & (1 << bit)) == 0;
+       ++bit)
+    continue;
+
+  return bit;
+}
+
 const char *
 arm_output_epilogue (rtx sibling)
 {
@@ -8747,27 +8792,47 @@
 	  saved_regs_mask |=   (1 << PC_REGNUM);
 	}
 
-      /* Load the registers off the stack.  If we only have one register
-	 to load use the LDR instruction - it is faster.  */
-      if (saved_regs_mask == (1 << LR_REGNUM))
-	{
-	  /* The exception handler ignores the LR, so we do
-	     not really need to load it off the stack.  */
-	  if (eh_ofs)
-	    asm_fprintf (f, "\tadd\t%r, %r, #4\n", SP_REGNUM, SP_REGNUM);
-	  else
-	    asm_fprintf (f, "\tldr\t%r, [%r], #4\n", LR_REGNUM, SP_REGNUM);
-	}
-      else if (saved_regs_mask)
+      if (saved_regs_mask)
 	{
-	  if (saved_regs_mask & (1 << SP_REGNUM))
-	    /* Note - write back to the stack register is not enabled
-	       (ie "ldmfd sp!...").  We know that the stack pointer is
-	       in the list of registers and if we add writeback the
-	       instruction becomes UNPREDICTABLE.  */
-	    print_multi_reg (f, "ldmfd\t%r", SP_REGNUM, saved_regs_mask);
+	  /* Load the registers off the stack.  If we only have one register
+	     to load use the LDR instruction - it is faster.  */
+	  if (bit_count (saved_regs_mask) == 1)
+	    {
+	      int reg = number_of_first_bit_set (saved_regs_mask);
+
+	      switch (reg)
+		{
+		case SP_REGNUM:
+		  /* Mustn't use base writeback when loading SP.  */
+		  asm_fprintf (f, "\tldr\t%r, [%r]\n", SP_REGNUM, SP_REGNUM);
+		  break;
+		  
+		case LR_REGNUM:
+		  if (eh_ofs)
+		    {
+		      /* The exception handler ignores the LR, so we do
+			 not really need to load it off the stack.  */
+		      asm_fprintf (f, "\tadd\t%r, %r, #4\n", SP_REGNUM, SP_REGNUM);
+		      break;
+		    }
+		  /* else fall through */
+		  
+		default:
+		  asm_fprintf (f, "\tldr\t%r, [%r], #4\n", reg, SP_REGNUM);
+		  break;
+		}
+	    }
 	  else
-	    print_multi_reg (f, "ldmfd\t%r!", SP_REGNUM, saved_regs_mask);
+	    {
+	      if (saved_regs_mask & (1 << SP_REGNUM))
+		/* Note - write back to the stack register is not enabled
+		   (ie "ldmfd sp!...").  We know that the stack pointer is
+		   in the list of registers and if we add writeback the
+		   instruction becomes UNPREDICTABLE.  */
+		print_multi_reg (f, "ldmfd\t%r", SP_REGNUM, saved_regs_mask);
+	      else
+		print_multi_reg (f, "ldmfd\t%r!", SP_REGNUM, saved_regs_mask);
+	    }
 	}
 
       if (current_function_pretend_args_size)
@@ -11395,22 +11460,6 @@
     }
 }
 
-/* Return the number (counting from 0) of
-   the least significant set bit in MASK.  */
-
-inline static int
-number_of_first_bit_set (int mask)
-{
-  int bit;
-
-  for (bit = 0;
-       (mask & (1 << bit)) == 0;
-       ++bit)
-    continue;
-
-  return bit;
-}
-
 /* Generate code to return from a thumb function.
    If 'reg_containing_return_addr' is -1, then the return address is
    actually on the stack, at the stack pointer.  */
diff -r -u -N gcc-3.4.6_orig/gcc/config/arm/arm.md gcc-3.4.6/gcc/config/arm/arm.md
--- gcc-3.4.6_orig/gcc/config/arm/arm.md	2007-09-30 14:28:16.000000000 +0200
+++ gcc-3.4.6/gcc/config/arm/arm.md	2007-09-30 14:33:09.000000000 +0200
@@ -8811,13 +8811,16 @@
    (set_attr "length" "4,8,8")]
 )
 
+; Try to convert LDR+LDR+arith into [add+]LDM+arith
+; On XScale, LDM is always slower than two LDRs, so only do this if
+; optimising for size.
 (define_insn "*arith_adjacentmem"
   [(set (match_operand:SI 0 "s_register_operand" "=r")
 	(match_operator:SI 1 "shiftable_operator"
 	 [(match_operand:SI 2 "memory_operand" "m")
 	  (match_operand:SI 3 "memory_operand" "m")]))
    (clobber (match_scratch:SI 4 "=r"))]
-  "TARGET_ARM && adjacent_mem_locations (operands[2], operands[3])"
+  "TARGET_ARM && (!arm_tune_xscale || optimize_size) && adjacent_mem_locations (operands[2], operands[3])"
   "*
   {
     rtx ldm[3];
@@ -8852,6 +8855,8 @@
       }
    if (val1 && val2)
       {
+	/* This would be a loss on a Harvard core, but adjacent_mem_locations()
+	   will prevent it from happening.  */
 	rtx ops[3];
 	ldm[0] = ops[0] = operands[4];
 	ops[1] = XEXP (XEXP (operands[2], 0), 0);
diff -r -u -N gcc-3.4.6_orig/gcc/config/arm/linux-elf.h gcc-3.4.6/gcc/config/arm/linux-elf.h
--- gcc-3.4.6_orig/gcc/config/arm/linux-elf.h	2007-09-30 14:28:16.000000000 +0200
+++ gcc-3.4.6/gcc/config/arm/linux-elf.h	2007-09-30 14:33:23.000000000 +0200
@@ -30,17 +30,34 @@
 /* Do not assume anything about header files.  */
 #define NO_IMPLICIT_EXTERN_C
 
+/*
+ * 'config.gcc' defines TARGET_BIG_ENDIAN_DEFAULT as 1 for arm*b-*
+ * (big endian) configurations.
+ */
+#if TARGET_BIG_ENDIAN_DEFAULT
+#define TARGET_ENDIAN_DEFAULT ARM_FLAG_BIG_END
+#define TARGET_ENDIAN_OPTION "mbig-endian"
+#define TARGET_LINKER_EMULATION "armelfb_linux"
+#else
+#define TARGET_ENDIAN_DEFAULT 0
+#define TARGET_ENDIAN_OPTION "mlittle-endian"
+#define TARGET_LINKER_EMULATION "armelf_linux"
+#endif
+
 /* Default is to use APCS-32 mode.  */
 #undef  TARGET_DEFAULT
-#define TARGET_DEFAULT (ARM_FLAG_APCS_32 | ARM_FLAG_MMU_TRAPS)
+#define TARGET_DEFAULT \
+		( ARM_FLAG_APCS_32 | \
+		  ARM_FLAG_MMU_TRAPS | \
+		  TARGET_ENDIAN_DEFAULT )
 
 #define SUBTARGET_CPU_DEFAULT TARGET_CPU_arm6
 
-#define SUBTARGET_EXTRA_LINK_SPEC " -m armelf_linux -p"
+#define SUBTARGET_EXTRA_LINK_SPEC " -m " TARGET_LINKER_EMULATION " -p"
 
 #undef  MULTILIB_DEFAULTS
 #define MULTILIB_DEFAULTS \
-	{ "marm", "mlittle-endian", "mhard-float", "mapcs-32", "mno-thumb-interwork" }
+	{ "marm", TARGET_ENDIAN_OPTION, "mhard-float", "mapcs-32", "mno-thumb-interwork" }
 
 #define CPP_APCS_PC_DEFAULT_SPEC "-D__APCS_32__"
 
@@ -89,7 +106,7 @@
    %{rdynamic:-export-dynamic} \
    %{!dynamic-linker:-dynamic-linker /lib/ld-linux.so.2} \
    -X \
-   %{mbig-endian:-EB}" \
+   %{mbig-endian:-EB} %{mlittle-endian:-EL}" \
    SUBTARGET_EXTRA_LINK_SPEC
 
 #define TARGET_OS_CPP_BUILTINS() LINUX_TARGET_OS_CPP_BUILTINS()
diff -r -u -N gcc-3.4.6_orig/gcc/config/avr/avr.c gcc-3.4.6/gcc/config/avr/avr.c
--- gcc-3.4.6_orig/gcc/config/avr/avr.c	2007-09-30 14:28:16.000000000 +0200
+++ gcc-3.4.6/gcc/config/avr/avr.c	2007-09-30 14:33:54.000000000 +0200
@@ -175,6 +175,18 @@
   { "at90c8534", 2, "__AVR_AT90C8534__" },
   { "at90s8535", 2, "__AVR_AT90S8535__" },
   { "at86rf401", 2, "__AVR_AT86RF401__" },
+    /* Classic + MOVW, <= 8K.  */
+  { "attiny13",   2, "__AVR_ATtiny13__" },
+  { "attiny2313", 2, "__AVR_ATtiny2313__" },  
+  { "attiny24", 2, "__AVR_ATtiny24__" },
+  { "attiny25", 2, "__AVR_ATtiny25__" },
+  { "attiny261", 2, "__AVR_ATtiny261__" },
+  { "attiny44", 2, "__AVR_ATtiny44__" },
+  { "attiny45", 2, "__AVR_ATtiny45__" },
+  { "attiny461", 2, "__AVR_ATtiny461__" },
+  { "attiny84", 2, "__AVR_ATtiny84__" },
+  { "attiny85", 2, "__AVR_ATtiny85__" },
+  { "attiny861", 2, "__AVR_ATtiny861__" },
     /* Classic, > 8K.  */
   { "avr3",      3, NULL },
   { "atmega103", 3, "__AVR_ATmega103__" },
@@ -185,6 +197,8 @@
     /* Enhanced, <= 8K.  */
   { "avr4",      4, NULL },
   { "atmega8",   4, "__AVR_ATmega8__" },
+  { "atmega48",   4, "__AVR_ATmega48__" },
+  { "atmega88",   4, "__AVR_ATmega88__" },
   { "atmega8515", 4, "__AVR_ATmega8515__" },
   { "atmega8535", 4, "__AVR_ATmega8535__" },
     /* Enhanced, > 8K.  */
@@ -193,11 +207,35 @@
   { "atmega161", 5, "__AVR_ATmega161__" },
   { "atmega162", 5, "__AVR_ATmega162__" },
   { "atmega163", 5, "__AVR_ATmega163__" },
+  { "atmega164", 5, "__AVR_ATmega164__" },
+  { "atmega165", 5, "__AVR_ATmega165__" },
+  { "atmega168", 5, "__AVR_ATmega168__" },
   { "atmega169", 5, "__AVR_ATmega169__" },
   { "atmega32",  5, "__AVR_ATmega32__" },
   { "atmega323", 5, "__AVR_ATmega323__" },
+  { "atmega324", 5, "__AVR_ATmega324__" },
+  { "atmega325", 5, "__AVR_ATmega325__" },
+  { "atmega3250", 5, "__AVR_ATmega3250__" },
+  { "atmega329", 5, "__AVR_ATmega329__" },
+  { "atmega3290", 5, "__AVR_ATmega3290__" },
+  { "atmega406", 5, "__AVR_ATmega406__" },
   { "atmega64",  5, "__AVR_ATmega64__" },
+  { "atmega640", 5, "__AVR_ATmega640__" },
+  { "atmega644", 5, "__AVR_ATmega644__" },
+  { "atmega645", 5, "__AVR_ATmega645__" },
+  { "atmega6450", 5, "__AVR_ATmega6450__" },
+  { "atmega649", 5, "__AVR_ATmega649__" },
+  { "atmega6490", 5, "__AVR_ATmega6490__" },
   { "atmega128", 5, "__AVR_ATmega128__" },
+  { "atmega1280",5, "__AVR_ATmega1280__" },
+  { "atmega1281",5, "__AVR_ATmega1281__" },
+  { "at90usb646", 5, "__AVR_AT90USB646__" },
+  { "at90usb647", 5, "__AVR_AT90USB647__" },
+  { "at90usb1286", 5, "__AVR_AT90USB1286__" },
+  { "at90usb1287", 5, "__AVR_AT90USB1287__" },
+  { "at90can32", 5, "__AVR_AT90CAN32__" },
+  { "at90can64", 5, "__AVR_AT90CAN64__" },
+  { "at90can128", 5, "__AVR_AT90CAN128__" },
   { "at94k",     5, "__AVR_AT94K__" },
     /* Assembler only.  */
   { "avr1",      1, NULL },
diff -r -u -N gcc-3.4.6_orig/gcc/config/avr/avr.h gcc-3.4.6/gcc/config/avr/avr.h
--- gcc-3.4.6_orig/gcc/config/avr/avr.h	2007-09-30 14:28:16.000000000 +0200
+++ gcc-3.4.6/gcc/config/avr/avr.h	2007-09-30 14:33:54.000000000 +0200
@@ -2351,12 +2351,12 @@
    Do not define this macro if it does not need to do anything.  */
 
 #define LINK_SPEC " %{!mmcu*:-m avr2}\
-%{mmcu=at90s1200|mmcu=attiny1*|mmcu=attiny28:-m avr1} \
-%{mmcu=attiny22|mmcu=attiny26|mmcu=at90s2*|mmcu=at90s4*|mmcu=at90s8*|mmcu=at90c8*|mmcu=at86rf401:-m avr2}\
+%{mmcu=at90s1200|mmcu=attiny11|mmcu=attiny12|mmcu=attiny15|mmcu=attiny28:-m avr1} \
+%{mmcu=attiny22|mmcu=attiny26|mmcu=at90s2*|mmcu=at90s4*|mmcu=at90s8*|mmcu=at90c8*|mmcu=at86rf401|mmcu=attiny13|mmcu=attiny2313|mmcu=attiny25|mmcu=attiny45|mmcu=attiny85|mmcu=attiny24|mmcu=attiny44|mmcu=attiny84|mmcu=attiny261|mmcu=attiny461|mmcu=attiny861:-m avr2}\
 %{mmcu=atmega103|mmcu=atmega603|mmcu=at43*|mmcu=at76*:-m avr3}\
-%{mmcu=atmega8*:-m avr4}\
-%{mmcu=atmega16*|mmcu=atmega32*|mmcu=atmega64|mmcu=atmega128|mmcu=at94k:-m avr5}\
-%{mmcu=atmega64|mmcu=atmega128|mmcu=atmega162|mmcu=atmega169: -Tdata 0x800100} "
+%{mmcu=atmega8*|mmcu=atmega48:-m avr4}\
+%{mmcu=atmega16*|mmcu=atmega32*|mmcu=atmega406|mmcu=atmega64*|mmcu=atmega128*|mmcu=at90can*|mmcu=at90usb*|mmcu=at94k:-m avr5}\
+%{mmcu=atmega48|mmcu=atmega88|mmcu=atmega128*|mmcu=at90can*|mmcu=at90usb*|mmcu=atmega16*|mmcu=atmega32*|mmcu=atmega406|mmcu=atmega64*: -Tdata 0x800100} "
 
 /* A C string constant that tells the GCC driver program options to
    pass to the linker.  It can also specify how to translate options
@@ -2365,7 +2365,7 @@
    Do not define this macro if it does not need to do anything.  */
 
 #define LIB_SPEC \
-  "%{!mmcu=at90s1*:%{!mmcu=attiny1*:%{!mmcu=attiny28: -lc }}}"
+  "%{!mmcu=at90s1*:%{!mmcu=attiny11:%{!mmcu=attiny12:%{!mmcu=attiny15:%{!mmcu=attiny28: -lc }}}}}"
 /* Another C string constant used much like `LINK_SPEC'.  The
    difference between the two is that `LIB_SPEC' is used at the end
    of the command given to the linker.
@@ -2377,7 +2377,7 @@
 /* No libstdc++ for now.  Empty string doesn't work.  */
 
 #define LIBGCC_SPEC \
-  "%{!mmcu=at90s1*:%{!mmcu=attiny1*:%{!mmcu=attiny28: -lgcc }}}"
+  "%{!mmcu=at90s1*:%{!mmcu=attiny11:%{!mmcu=attiny12:%{!mmcu=attiny15:%{!mmcu=attiny28: -lgcc }}}}}"
 /* Another C string constant that tells the GCC driver program how
    and when to place a reference to `libgcc.a' into the linker
    command line.  This constant is placed both before and after the
@@ -2421,23 +2421,60 @@
 %{mmcu=at90c8534:crtc8534.o%s} \
 %{mmcu=at90s8535:crts8535.o%s} \
 %{mmcu=at86rf401:crt86401.o%s} \
+%{mmcu=attiny13:crttn13.o%s} \
+%{mmcu=attiny2313:crttn2313.o%s} \
+%{mmcu=attiny24:crttn24.o%s} \
+%{mmcu=attiny44:crttn44.o%s} \
+%{mmcu=attiny85:crttn84.o%s} \
+%{mmcu=attiny25:crttn25.o%s} \
+%{mmcu=attiny45:crttn45.o%s} \
+%{mmcu=attiny85:crttn85.o%s} \
+%{mmcu=attiny261:crttn261.o%s} \
+%{mmcu=attiny461:crttn461.o%s} \
+%{mmcu=attiny861:crttn861.o%s} \
 %{mmcu=atmega103|mmcu=avr3:crtm103.o%s} \
 %{mmcu=atmega603:crtm603.o%s} \
 %{mmcu=at43usb320:crt43320.o%s} \
 %{mmcu=at43usb355:crt43355.o%s} \
 %{mmcu=at76c711:crt76711.o%s} \
 %{mmcu=atmega8|mmcu=avr4:crtm8.o%s} \
+%{mmcu=atmega48:crtm48.o%s} \
+%{mmcu=atmega88:crtm88.o%s} \
 %{mmcu=atmega8515:crtm8515.o%s} \
 %{mmcu=atmega8535:crtm8535.o%s} \
 %{mmcu=atmega16:crtm16.o%s} \
 %{mmcu=atmega161|mmcu=avr5:crtm161.o%s} \
 %{mmcu=atmega162:crtm162.o%s} \
 %{mmcu=atmega163:crtm163.o%s} \
+%{mmcu=atmega164:crtm164.o%s} \
+%{mmcu=atmega165:crtm165.o%s} \
+%{mmcu=atmega168:crtm168.o%s} \
 %{mmcu=atmega169:crtm169.o%s} \
 %{mmcu=atmega32:crtm32.o%s} \
 %{mmcu=atmega323:crtm323.o%s} \
+%{mmcu=atmega324:crtm324.o%s} \
+%{mmcu=atmega325:crtm325.o%s} \
+%{mmcu=atmega3250:crtm3250.o%s} \
+%{mmcu=atmega329:crtm329.o%s} \
+%{mmcu=atmega3290:crtm3290.o%s} \
+%{mmcu=atmega406:crtm406.o%s} \
 %{mmcu=atmega64:crtm64.o%s} \
+%{mmcu=atmega640:crtm640.o%s} \
+%{mmcu=atmega644:crtm644.o%s} \
+%{mmcu=atmega645:crtm645.o%s} \
+%{mmcu=atmega6450:crtm6450.o%s} \
+%{mmcu=atmega649:crtm649.o%s} \
+%{mmcu=atmega6490:crtm6490.o%s} \
 %{mmcu=atmega128:crtm128.o%s} \
+%{mmcu=atmega1280:crtm1280.o%s} \
+%{mmcu=atmega1281:crtm1281.o%s} \
+%{mmcu=at90usb646:crtusb646.o%s} \
+%{mmcu=at90usb647:crtusb647.o%s} \
+%{mmcu=at90usb1286:crtusb1286.o%s} \
+%{mmcu=at90usb1287:crtusb1287.o%s} \
+%{mmcu=at90can32:crtcan32.o%s} \
+%{mmcu=at90can64:crtcan64.o%s} \
+%{mmcu=at90can128:crtcan128.o%s} \
 %{mmcu=at94k:crtat94k.o%s}"
 
 #define EXTRA_SPECS {"crt_binutils", CRT_BINUTILS_SPECS},
diff -r -u -N gcc-3.4.6_orig/gcc/config/avr/t-avr gcc-3.4.6/gcc/config/avr/t-avr
--- gcc-3.4.6_orig/gcc/config/avr/t-avr	2007-09-30 14:28:16.000000000 +0200
+++ gcc-3.4.6/gcc/config/avr/t-avr	2007-09-30 14:33:54.000000000 +0200
@@ -46,13 +46,25 @@
 	mmcu?avr3=mmcu?at43usb320 mmcu?avr3=mmcu?at43usb355 \
 	mmcu?avr3=mmcu?at76c711 \
 	mmcu?avr4=mmcu?atmega8515 mmcu?avr4=mmcu?atmega8535 \
-	mmcu?avr4=mmcu?atmega8 \
+	mmcu?avr4=mmcu?atmega8 mmcu?avr4=mmcu?atmega48 \
+	mmcu?avr4=mmcu?atmega88 \
 	mmcu?avr5=mmcu?atmega161 mmcu?avr5=mmcu?atmega162 \
-	mmcu?avr5=mmcu?atmega163 mmcu?avr5=mmcu?atmega169 \
-	mmcu?avr5=mmcu?atmega16 \
+	mmcu?avr5=mmcu?atmega163 mmcu?avr5=mmcu?atmega164 \
+	mmcu?avr=mmcu?atmega165 mmcu?avr5=mmcu?atmega168 \
+	mmcu?avr5=mmcu?atmega169 mmcu?avr5=mmcu?atmega16 \
 	mmcu?avr5=mmcu?atmega323 mmcu?avr5=mmcu?atmega32 \
+	mmcu?avr=mmcu?atmega329 mmcu?avr5=mmcu?atmega3290 \
+	mmcu?avr5=mmcu?atmega324 mmcu?avr5=mmcu?atmega644 \
+	mmcu?avr5=mmcu?atmega406 mmcu?avr5=mmcu?atmega640 \
+	mmcu?avr5=mmcu?atmega649 mmcu?avr5=mmcu?atmega6490 \
 	mmcu?avr5=mmcu?atmega64  mmcu?avr5=mmcu?atmega128 \
-	mmcu?avr5=mmcu?at94k
+	mmcu?avr5=mmcu?atmega1280 mmcu?avr5=mmcu?atmega1281 \
+	mmcu?avr5=mmcu?atmega325 mmcu?avr5=mmcu?atmega3250 \
+	mmcu?avr5=mmcu?atmega645 mmcu?avr5=mmcu?atmega6450 \
+	mmcu?avr5=mmcu?at90can32 mmcu?avr5=mmcu?at90can64 \
+	mmcu?avr5=mmcu?at90usb646 mmcu?avr5=mmcu?at90usb647 \
+	mmcu?avr5=mmcu?at90usb1286 mmcu?avr5=mmcu?at90usb1287 \
+	mmcu?avr5=mmcu?at94k mmcu?avr5=mmcu?at90can128
 
 MULTILIB_EXCEPTIONS =
 
diff -r -u -N gcc-3.4.6_orig/gcc/config/freebsd-spec.h gcc-3.4.6/gcc/config/freebsd-spec.h
--- gcc-3.4.6_orig/gcc/config/freebsd-spec.h	2007-09-30 14:28:14.000000000 +0200
+++ gcc-3.4.6/gcc/config/freebsd-spec.h	2007-09-30 14:30:43.000000000 +0200
@@ -154,8 +154,4 @@
 #endif
 #endif
 
-#if FBSD_MAJOR < 6
-#define FBSD_DYNAMIC_LINKER "/usr/libexec/ld-elf.so.1"
-#else
 #define FBSD_DYNAMIC_LINKER "/libexec/ld-elf.so.1"
-#endif
diff -r -u -N gcc-3.4.6_orig/gcc/config/i386/i386.c gcc-3.4.6/gcc/config/i386/i386.c
--- gcc-3.4.6_orig/gcc/config/i386/i386.c	2007-09-30 14:28:16.000000000 +0200
+++ gcc-3.4.6/gcc/config/i386/i386.c	2007-09-30 14:33:50.000000000 +0200
@@ -2041,11 +2041,11 @@
 	    {
 	      tree bases = TYPE_BINFO_BASETYPES (type);
 	      int n_bases = TREE_VEC_LENGTH (bases);
-	      int i;
+	      int basenum;
 
-	      for (i = 0; i < n_bases; ++i)
+	      for (basenum = 0; basenum < n_bases; ++basenum)
 		{
-		   tree binfo = TREE_VEC_ELT (bases, i);
+		   tree binfo = TREE_VEC_ELT (bases, basenum);
 		   int num;
 		   int offset = tree_low_cst (BINFO_OFFSET (binfo), 0) * 8;
 		   tree type = BINFO_TYPE (binfo);
@@ -2129,11 +2129,11 @@
 	    {
 	      tree bases = TYPE_BINFO_BASETYPES (type);
 	      int n_bases = TREE_VEC_LENGTH (bases);
-	      int i;
+	      int basenum;
 
-	      for (i = 0; i < n_bases; ++i)
+	      for (basenum = 0; basenum < n_bases; ++basenum)
 		{
-		   tree binfo = TREE_VEC_ELT (bases, i);
+		   tree binfo = TREE_VEC_ELT (bases, basenum);
 		   int num;
 		   int offset = tree_low_cst (BINFO_OFFSET (binfo), 0) * 8;
 		   tree type = BINFO_TYPE (binfo);
@@ -3835,6 +3835,21 @@
   return (GET_CODE (op) == CONST_INT && INTVAL (op) >= 0 && INTVAL (op) < 256);
 }
 
+/* Match exactly one bit in 4-bit mask. */
+int
+const_pow2_1_to_8_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)
+{
+  unsigned int log = exact_log2 (INTVAL (op));
+  return log <= 3;
+}
+
+/* Match exactly one bit in 8-bit mask. */
+int
+const_pow2_1_to_128_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)
+{
+  unsigned int log = exact_log2 (INTVAL (op));
+  return log <= 7;
+}
 
 /* True if this is a constant appropriate for an increment or decrement.  */
 
@@ -14224,7 +14239,7 @@
       if (! (*insn_data[icode].operand[3].predicate) (op2, mode2))
 	{
 	  error ("selector must be an integer constant in the range 0..%i",
-		  fcode == IX86_BUILTIN_PINSRW ? 15:255);
+		  fcode == IX86_BUILTIN_PINSRW ? 3:7);
 	  return const0_rtx;
 	}
       if (target == 0
diff -r -u -N gcc-3.4.6_orig/gcc/config/i386/i386.h gcc-3.4.6/gcc/config/i386/i386.h
--- gcc-3.4.6_orig/gcc/config/i386/i386.h	2007-09-30 14:28:16.000000000 +0200
+++ gcc-3.4.6/gcc/config/i386/i386.h	2007-09-30 14:33:38.000000000 +0200
@@ -2944,6 +2944,8 @@
   {"const_0_to_7_operand", {CONST_INT}},				\
   {"const_0_to_15_operand", {CONST_INT}},				\
   {"const_0_to_255_operand", {CONST_INT}},				\
+  {"const_pow2_1_to_8_operand", {CONST_INT}}, \
+  {"const_pow2_1_to_128_operand", {CONST_INT}}, \
   {"incdec_operand", {CONST_INT}},					\
   {"mmx_reg_operand", {REG}},						\
   {"reg_no_sp_operand", {SUBREG, REG}},					\
diff -r -u -N gcc-3.4.6_orig/gcc/config/i386/i386.md gcc-3.4.6/gcc/config/i386/i386.md
--- gcc-3.4.6_orig/gcc/config/i386/i386.md	2007-09-30 14:28:17.000000000 +0200
+++ gcc-3.4.6/gcc/config/i386/i386.md	2007-09-30 14:33:38.000000000 +0200
@@ -20441,14 +20441,31 @@
 
 ;; MMX insert/extract/shuffle
 
-(define_insn "mmx_pinsrw"
+(define_expand "mmx_pinsrw"
+  [(set (match_operand:V4HI 0 "register_operand" "")
+        (vec_merge:V4HI
+	  (match_operand:V4HI 1 "register_operand" "")
+          (vec_duplicate:V4HI
+            (match_operand:SI 2 "nonimmediate_operand" ""))
+          (match_operand:SI 3 "const_0_to_3_operand" "")))]
+  "TARGET_SSE || TARGET_3DNOW_A"
+{
+  operands[2] = gen_lowpart (HImode, operands[2]);
+  operands[3] = GEN_INT (1 << INTVAL (operands[3]));
+})
+
+(define_insn "*mmx_pinsrw"
   [(set (match_operand:V4HI 0 "register_operand" "=y")
-        (vec_merge:V4HI (match_operand:V4HI 1 "register_operand" "0")
-			(vec_duplicate:V4HI
-			 (truncate:HI (match_operand:SI 2 "nonimmediate_operand" "rm")))
-			(match_operand:SI 3 "const_0_to_15_operand" "N")))]
+        (vec_merge:V4HI
+	  (match_operand:V4HI 1 "register_operand" "0")
+          (vec_duplicate:V4HI
+            (match_operand:HI 2 "nonimmediate_operand" "rm"))
+          (match_operand:SI 3 "const_pow2_1_to_8_operand" "N")))]
   "TARGET_SSE || TARGET_3DNOW_A"
-  "pinsrw\t{%3, %2, %0|%0, %2, %3}"
+{
+  operands[3] = GEN_INT (exact_log2 (INTVAL (operands[3])));
+  return "pinsrw\t{%3, %k2, %0|%0, %k2, %3}";
+}
   [(set_attr "type" "mmxcvt")
    (set_attr "mode" "DI")])
 
@@ -22136,15 +22153,31 @@
 
 ;; MMX insert/extract/shuffle
 
-(define_insn "sse2_pinsrw"
+(define_expand "sse2_pinsrw"
+  [(set (match_operand:V8HI 0 "register_operand" "")
+        (vec_merge:V8HI
+	  (match_operand:V8HI 1 "register_operand" "")
+          (vec_duplicate:V8HI
+            (match_operand:SI 2 "nonimmediate_operand" ""))
+          (match_operand:SI 3 "const_0_to_7_operand" "")))]
+  "TARGET_SSE2"
+{
+  operands[2] = gen_lowpart (HImode, operands[2]);
+  operands[3] = GEN_INT (1 << INTVAL (operands[3]));
+})
+
+(define_insn "*sse2_pinsrw"
   [(set (match_operand:V8HI 0 "register_operand" "=x")
-        (vec_merge:V8HI (match_operand:V8HI 1 "register_operand" "0")
-			(vec_duplicate:V8HI
-			 (truncate:HI
-			   (match_operand:SI 2 "nonimmediate_operand" "rm")))
-			(match_operand:SI 3 "const_0_to_255_operand" "N")))]
+        (vec_merge:V8HI
+	  (match_operand:V8HI 1 "register_operand" "0")
+          (vec_duplicate:V8HI
+            (match_operand:HI 2 "nonimmediate_operand" "rm"))
+          (match_operand:SI 3 "const_pow2_1_to_128_operand" "N")))]
   "TARGET_SSE2"
-  "pinsrw\t{%3, %2, %0|%0, %2, %3}"
+{
+  operands[3] = GEN_INT (exact_log2 (INTVAL (operands[3])));
+  return "pinsrw\t{%3, %k2, %0|%0, %k2, %3}";
+}
   [(set_attr "type" "ssecvt")
    (set_attr "mode" "TI")])
 
diff -r -u -N gcc-3.4.6_orig/gcc/config/i386/openbsdelf.h gcc-3.4.6/gcc/config/i386/openbsdelf.h
--- gcc-3.4.6_orig/gcc/config/i386/openbsdelf.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc/config/i386/openbsdelf.h	2007-09-30 14:32:14.000000000 +0200
@@ -0,0 +1,135 @@
+
+/* Configuration for an OpenBSD i386 target.
+   
+   Copyright (C) 1999 Free Software Foundation, Inc.
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* This gets defined in tm.h->linux.h->svr4.h, and keeps us from using
+   libraries compiled with the native cc, so undef it. */
+#undef NO_DOLLAR_IN_LABEL
+
+/* Override the default comment-starter of "/".  */
+#undef ASM_COMMENT_START
+#define ASM_COMMENT_START "#"
+
+
+/* This goes away when the math-emulator is fixed */
+#undef TARGET_DEFAULT
+#define TARGET_DEFAULT \
+  (MASK_80387 | MASK_IEEE_FP | MASK_FLOAT_RETURNS | MASK_NO_FANCY_MATH_387)
+
+/* Run-time target specifications */
+
+#define TARGET_OS_CPP_BUILTINS()		\
+  do						\
+    {						\
+    	OPENBSD_OS_CPP_BUILTINS_ELF();		\
+    }						\
+  while (0)
+
+/* As an elf system, we need crtbegin/crtend stuff.  */
+#undef STARTFILE_SPEC
+#define STARTFILE_SPEC "\
+	%{!shared: %{pg:gcrt0%O%s} %{!pg:%{p:gcrt0%O%s} %{!p:crt0%O%s}} \
+	crtbegin%O%s} %{shared:crtbeginS%O%s}"
+#undef ENDFILE_SPEC
+#define ENDFILE_SPEC "%{!shared:crtend%O%s} %{shared:crtendS%O%s}"
+
+/* Layout of source language data types.  */
+
+/* This must agree with <machine/ansi.h> */
+#undef SIZE_TYPE
+#define SIZE_TYPE "unsigned int"
+
+#undef PTRDIFF_TYPE
+#define PTRDIFF_TYPE "int"
+
+#undef WCHAR_TYPE
+#define WCHAR_TYPE "int"
+
+#undef WCHAR_TYPE_SIZE
+#define WCHAR_TYPE_SIZE BITS_PER_WORD
+
+/* Assembler format: overall framework.  */
+
+#undef ASM_APP_ON
+#define ASM_APP_ON "#APP\n"
+
+#undef ASM_APP_OFF
+#define ASM_APP_OFF "#NO_APP\n"
+
+#undef SET_ASM_OP
+#define SET_ASM_OP	"\t.set\t"
+
+/* The following macros were originally stolen from i386v4.h.
+   These have to be defined to get PIC code correct.  */
+
+/* Assembler format: dispatch tables.  */
+
+/* Assembler format: sections.  */
+
+/* Stack & calling: aggregate returns.  */
+
+/* Don't default to pcc-struct-return, because gcc is the only compiler, and
+   we want to retain compatibility with older gcc versions.  */
+#define DEFAULT_PCC_STRUCT_RETURN 0
+
+/* Assembler format: alignment output.  */
+
+#ifdef HAVE_GAS_MAX_SKIP_P2ALIGN
+#define ASM_OUTPUT_MAX_SKIP_ALIGN(FILE,LOG,MAX_SKIP) \
+  if ((LOG) != 0) {\
+    if ((MAX_SKIP) == 0) fprintf ((FILE), "\t.p2align %d\n", (LOG)); \
+    else fprintf ((FILE), "\t.p2align %d,,%d\n", (LOG), (MAX_SKIP)); \
+  }
+#endif
+
+/* Stack & calling: profiling.  */
+
+/* OpenBSD's profiler recovers all information from the stack pointer.
+   The icky part is not here, but in machine/profile.h.  */
+#undef FUNCTION_PROFILER
+#define FUNCTION_PROFILER(FILE, LABELNO)  \
+  fputs (flag_pic ? "\tcall __mcount@PLT\n": "\tcall __mcount\n", FILE);
+
+/* Assembler format: exception region output.  */
+
+/* our configuration still doesn't handle dwarf2 correctly */
+#define DWARF2_UNWIND_INFO 0
+
+/* Assembler format: alignment output.  */
+
+/* Note that we pick up ASM_OUTPUT_MAX_SKIP_ALIGN from i386/gas.h */
+
+/* Note that we pick up ASM_OUTPUT_MI_THUNK from unix.h.  */
+
+#undef LINK_SPEC
+#define LINK_SPEC \
+  "%{!shared:%{!nostdlib:%{!r*:%{!e*:-e __start}}}} \
+   %{shared:-shared} %{R*} \
+   %{static:-Bstatic} \
+   %{!static:-Bdynamic} \
+   %{assert*} \
+   %{!dynamic-linker:-dynamic-linker /usr/libexec/ld.so}"
+
+#define OBSD_HAS_CORRECT_SPECS
+
+/* pick up defines for mprotect (used in TRANSFER_FROM_TRANPOLINE) */
+#include <sys/types.h>
+#include <sys/mman.h>
diff -r -u -N gcc-3.4.6_orig/gcc/config/ia64/change-symver.c gcc-3.4.6/gcc/config/ia64/change-symver.c
--- gcc-3.4.6_orig/gcc/config/ia64/change-symver.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc/config/ia64/change-symver.c	2007-09-30 14:31:51.000000000 +0200
@@ -0,0 +1,211 @@
+#define _GNU_SOURCE 1
+#define _FILE_OFFSET_BITS 64
+#include <endian.h>
+#include <errno.h>
+#include <error.h>
+#include <fcntl.h>
+#include <fnmatch.h>
+#include <gelf.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+int
+compute_veridx (const char *name, Elf *elf, Elf_Data *verd, GElf_Shdr *verd_shdr)
+{
+  if (strcmp (name, "_GLOBAL_") == 0)
+    return 1;
+
+  int cnt;
+  size_t offset = 0;
+  for (cnt = verd_shdr->sh_info; --cnt >= 0; )
+    {
+      GElf_Verdef defmem;
+      GElf_Verdef *def;
+      GElf_Verdaux auxmem;
+      GElf_Verdaux *aux;
+      unsigned int auxoffset;
+
+      /* Get the data at the next offset.  */
+      def = gelf_getverdef (verd, offset, &defmem);
+      if (def == NULL)
+	break;
+
+      auxoffset = offset + def->vd_aux;
+      aux = gelf_getverdaux (verd, auxoffset, &auxmem);
+      if (aux == NULL)
+	break;
+
+      if (strcmp (name, elf_strptr (elf, verd_shdr->sh_link,
+		  aux->vda_name)) == 0)
+	return def->vd_ndx;
+
+      /* Find the next offset.  */
+      offset += def->vd_next;
+    }
+
+  return -1;
+}
+
+int
+main (int argc, char **argv)
+{
+  if (argc < 4)
+    error (1, 0, "Usage: change_symver library from_symver to_symver symbol...\nExample: change_symver libfoo.so FOO_1.0 *global* bar baz");
+
+  const char *fname = argv[1];
+
+  /* Open the file.  */
+  int fd;
+  fd = open (fname, O_RDWR);
+  if (fd == -1)
+    error (1, errno, fname);
+
+  elf_version (EV_CURRENT);
+
+  /* Now get the ELF descriptor.  */
+  Elf *elf = elf_begin (fd, ELF_C_READ_MMAP, NULL);
+  if (elf == NULL || elf_kind (elf) != ELF_K_ELF)
+    error (1, 0, "Couldn't open %s: %s", fname, elf_errmsg (-1));
+
+  size_t shstrndx;
+  /* Get the section header string table index.  */
+  if (elf_getshstrndx (elf, &shstrndx) < 0)
+    error (1, 0, "cannot get shstrndx from %s", fname);
+
+  GElf_Ehdr ehdr_mem;
+  GElf_Ehdr *ehdr;
+
+  /* We need the ELF header in a few places.  */
+  ehdr = gelf_getehdr (elf, &ehdr_mem);
+  if (ehdr == NULL)
+    error (1, 0, "couldn't get ELF headers %s: %s", fname, elf_errmsg (-1));
+
+  Elf_Scn *scn = NULL;
+  GElf_Shdr shdr_mem, verd_shdr, ver_shdr, dynsym_shdr;
+  Elf_Data *ver = NULL, *verd = NULL, *dynsym = NULL;
+
+  while ((scn = elf_nextscn (elf, scn)) != NULL)
+    {
+      GElf_Shdr *shdr = gelf_getshdr (scn, &shdr_mem);
+
+      if (shdr == NULL)
+	error (1, 0, "couldn't get shdr from %s", fname);
+
+      if ((shdr->sh_flags & SHF_ALLOC) != 0)
+	{
+	  const char *name = elf_strptr (elf, shstrndx, shdr->sh_name);
+	  Elf_Data **p;
+
+	  if (strcmp (name, ".gnu.version") == 0)
+	    {
+	      p = &ver;
+	      ver_shdr = *shdr;
+	    }
+	  else if (strcmp (name, ".gnu.version_d") == 0)
+	    {
+	      p = &verd;
+	      verd_shdr = *shdr;
+	    }
+	  else if (strcmp (name, ".dynsym") == 0)
+	    {
+	      p = &dynsym;
+	      dynsym_shdr = *shdr;
+	    }
+	  else
+	    continue;
+
+	  if (*p != NULL)
+	    error (1, 0, "Two %s sections in %s", name, fname);
+	  *p = elf_getdata (scn, NULL);
+	  if (*p == NULL || elf_getdata (scn, *p) != NULL)
+	    error (1, 0, "No data or non-contiguous data in %s section in %s",
+		   name, fname);
+	}
+    }
+
+  if (ver == NULL || verd == NULL || dynsym == NULL)
+    error (1, 0, "Couldn't find one of the needed sections in %s", fname);
+
+  int from_idx = compute_veridx (argv[2], elf, verd, &verd_shdr);
+  if (from_idx == -1)
+    error (1, 0, "Could not find symbol version %s in %s", argv[2], fname);
+
+  int to_idx = compute_veridx (argv[3], elf, verd, &verd_shdr);
+  if (to_idx == -1)
+    error (1, 0, "Could not find symbol version %s in %s", argv[3], fname);
+
+  if (dynsym_shdr.sh_entsize != gelf_fsize (elf, ELF_T_SYM, 1, ehdr->e_version)
+      || dynsym_shdr.sh_size % dynsym_shdr.sh_entsize
+      || ver_shdr.sh_entsize != 2
+      || (ver_shdr.sh_size & 1)
+      || dynsym_shdr.sh_size / dynsym_shdr.sh_entsize != ver_shdr.sh_size / 2)
+    error (1, 0, "Unexpected sh_size or sh_entsize in %s", fname);
+
+  size_t nentries = ver_shdr.sh_size / 2;
+  size_t cnt;
+  GElf_Versym array[nentries];
+  for (cnt = 0; cnt < nentries; ++cnt)
+    {
+      GElf_Versym vsymmem;
+      GElf_Versym *vsym;
+
+      vsym = gelf_getversym (ver, cnt, &vsymmem);
+      if (vsym == NULL)
+	error (1, 0, "gelt_getversym failed in %s: %s", fname, elf_errmsg (-1));
+
+      array[cnt] = *vsym;
+      if (*vsym != from_idx)
+	continue;
+
+      GElf_Sym sym_mem;
+      GElf_Sym *sym;
+      sym = gelf_getsym (dynsym, cnt, &sym_mem);
+      if (sym == NULL)
+	error (1, 0, "gelt_getsym failed in %s: %s", fname, elf_errmsg (-1));
+
+      const char *name = elf_strptr (elf, dynsym_shdr.sh_link, sym->st_name);
+
+      int argn;
+      for (argn = 4; argn < argc; ++argn)
+	if (fnmatch (argv[argn], name, 0) == 0)
+	  {
+	    array[cnt] = to_idx;
+	    break;
+	  }
+    }
+
+  if (sizeof (array[0]) != 2)
+    abort ();
+
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+  if (ehdr->e_ident[EI_DATA] == ELFDATA2LSB)
+    ;
+  else if (ehdr->e_ident[EI_DATA] == ELFDATA2MSB)
+#elif __BYTE_ORDER == __BIG_ENDIAN
+  if (ehdr->e_ident[EI_DATA] == ELFDATA2MSB)
+    ;
+  else if (ehdr->e_ident[EI_DATA] == ELFDATA2LSB)
+#else
+# error Unsupported endianity
+#endif
+    {
+      for (cnt = 0; cnt < nentries; ++cnt)
+	array[cnt] = ((array[cnt] & 0xff) << 8) | ((array[cnt] & 0xff00) >> 8);
+    }
+  else
+    error (1, 0, "Unknown EI_DATA %d in %s", ehdr->e_ident[EI_DATA], fname);
+
+  if (elf_end (elf) != 0)
+    error (1, 0, "couldn't close %s: %s", fname, elf_errmsg (-1));
+
+  if (lseek (fd, ver_shdr.sh_offset, SEEK_SET) != (off_t) ver_shdr.sh_offset)
+    error (1, 0, "failed to seek to %zd in %s", (size_t) ver_shdr.sh_offset,
+	   fname);
+
+  if (write (fd, array, 2 * nentries) != (ssize_t) (2 * nentries))
+    error (1, 0, "failed to write .gnu.version section into %s", fname);
+
+  close (fd);
+  return 0;
+}
diff -r -u -N gcc-3.4.6_orig/gcc/config/ia64/crtbegin.asm gcc-3.4.6/gcc/config/ia64/crtbegin.asm
--- gcc-3.4.6_orig/gcc/config/ia64/crtbegin.asm	2007-09-30 14:28:14.000000000 +0200
+++ gcc-3.4.6/gcc/config/ia64/crtbegin.asm	2007-09-30 14:36:13.000000000 +0200
@@ -246,3 +246,7 @@
 .weak __cxa_finalize
 #endif
 .weak _Jv_RegisterClasses
+
+#ifdef __linux__
+.section .note.GNU-stack; .previous
+#endif
diff -r -u -N gcc-3.4.6_orig/gcc/config/ia64/crtend.asm gcc-3.4.6/gcc/config/ia64/crtend.asm
--- gcc-3.4.6_orig/gcc/config/ia64/crtend.asm	2007-09-30 14:28:14.000000000 +0200
+++ gcc-3.4.6/gcc/config/ia64/crtend.asm	2007-09-30 14:36:13.000000000 +0200
@@ -113,3 +113,7 @@
 
 	br.ret.sptk.many rp
 	.endp __do_global_ctors_aux
+
+#ifdef __linux__
+.section .note.GNU-stack; .previous
+#endif
diff -r -u -N gcc-3.4.6_orig/gcc/config/ia64/crti.asm gcc-3.4.6/gcc/config/ia64/crti.asm
--- gcc-3.4.6_orig/gcc/config/ia64/crti.asm	2007-09-30 14:28:14.000000000 +0200
+++ gcc-3.4.6/gcc/config/ia64/crti.asm	2007-09-30 14:36:13.000000000 +0200
@@ -64,3 +64,7 @@
 	.body
 
 # end of crti.asm
+
+#ifdef __linux__
+.section .note.GNU-stack; .previous
+#endif
diff -r -u -N gcc-3.4.6_orig/gcc/config/ia64/crtn.asm gcc-3.4.6/gcc/config/ia64/crtn.asm
--- gcc-3.4.6_orig/gcc/config/ia64/crtn.asm	2007-09-30 14:28:14.000000000 +0200
+++ gcc-3.4.6/gcc/config/ia64/crtn.asm	2007-09-30 14:36:13.000000000 +0200
@@ -54,3 +54,7 @@
 	br.ret.sptk.many b0
 
 # end of crtn.asm
+
+#ifdef __linux__
+.section .note.GNU-stack; .previous
+#endif
diff -r -u -N gcc-3.4.6_orig/gcc/config/ia64/ia64.h gcc-3.4.6/gcc/config/ia64/ia64.h
--- gcc-3.4.6_orig/gcc/config/ia64/ia64.h	2007-09-30 14:28:14.000000000 +0200
+++ gcc-3.4.6/gcc/config/ia64/ia64.h	2007-09-30 14:36:21.000000000 +0200
@@ -173,6 +173,8 @@
 
 #define TARGET_SWITCHES							\
 {									\
+  { "64",		0,						\
+      N_("Generate 64-bit code") },					\
   { "big-endian",	MASK_BIG_ENDIAN,				\
       N_("Generate big endian code") },					\
   { "little-endian",	-MASK_BIG_ENDIAN,				\
diff -r -u -N gcc-3.4.6_orig/gcc/config/ia64/lib1funcs.asm gcc-3.4.6/gcc/config/ia64/lib1funcs.asm
--- gcc-3.4.6_orig/gcc/config/ia64/lib1funcs.asm	2007-09-30 14:28:14.000000000 +0200
+++ gcc-3.4.6/gcc/config/ia64/lib1funcs.asm	2007-09-30 14:36:13.000000000 +0200
@@ -741,3 +741,7 @@
 	.endp __floattitf
 
 #endif
+
+#ifdef __linux__
+.section .note.GNU-stack; .previous
+#endif
diff -r -u -N gcc-3.4.6_orig/gcc/config/ia64/libgcc-ia64-no-libunwind.ver gcc-3.4.6/gcc/config/ia64/libgcc-ia64-no-libunwind.ver
--- gcc-3.4.6_orig/gcc/config/ia64/libgcc-ia64-no-libunwind.ver	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc/config/ia64/libgcc-ia64-no-libunwind.ver	2007-09-30 14:31:51.000000000 +0200
@@ -0,0 +1,17 @@
+GCC_3.4.2 {
+  _Unwind_GetGR
+  _Unwind_RaiseException
+  _Unwind_GetRegionStart
+  _Unwind_SetIP
+  _Unwind_GetIP
+  _Unwind_GetLanguageSpecificData
+  _Unwind_Resume
+  _Unwind_DeleteException
+  _Unwind_SetGR
+  _Unwind_ForcedUnwind
+  _Unwind_Backtrace
+  _Unwind_FindEnclosingFunction
+  _Unwind_GetCFA
+  _Unwind_Resume_or_Rethrow
+  _Unwind_GetBSP
+}
diff -r -u -N gcc-3.4.6_orig/gcc/config/ia64/linux.h gcc-3.4.6/gcc/config/ia64/linux.h
--- gcc-3.4.6_orig/gcc/config/ia64/linux.h	2007-09-30 14:28:14.000000000 +0200
+++ gcc-3.4.6/gcc/config/ia64/linux.h	2007-09-30 14:36:21.000000000 +0200
@@ -5,6 +5,8 @@
 
 #define TARGET_VERSION fprintf (stderr, " (IA-64) Linux");
 
+#define TARGET_ASM_FILE_END file_end_indicate_exec_stack
+
 /* This is for -profile to use -lc_p instead of -lc.  */
 #undef CC1_SPEC
 #define CC1_SPEC "%{profile:-p} %{G*}"
@@ -55,6 +57,8 @@
 #undef LINK_EH_SPEC
 #define LINK_EH_SPEC ""
 
+#define MULTILIB_DEFAULTS { "m64" }
+
 /* Do code reading to identify a signal frame, and set the frame
    state data appropriately.  See unwind-dw2.c for the structs.  */
 
diff -r -u -N gcc-3.4.6_orig/gcc/config/ia64/mkmap-symver-multi.awk gcc-3.4.6/gcc/config/ia64/mkmap-symver-multi.awk
--- gcc-3.4.6_orig/gcc/config/ia64/mkmap-symver-multi.awk	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc/config/ia64/mkmap-symver-multi.awk	2007-09-30 14:31:51.000000000 +0200
@@ -0,0 +1,133 @@
+# Generate an ELF symbol version map a-la Solaris and GNU ld.
+#	Contributed by Richard Henderson <rth@cygnus.com>
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify it under
+# the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2, or (at your option) any later
+# version.
+#
+# GCC is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+# License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING.  If not, write to the Free
+# Software Foundation, 59 Temple Place - Suite 330, Boston MA
+# 02111-1307, USA.
+
+BEGIN {
+  state = "nm";
+  sawsymbol = 0;
+}
+
+# Remove comment and blank lines.
+/^ *#/ || /^ *$/ {
+  next;
+}
+
+# We begin with nm input.  Collect the set of symbols that are present
+# so that we can not emit them into the final version script -- Solaris
+# complains at us if we do.
+
+state == "nm" && /^%%/ {
+  state = "ver";
+  next;
+}
+
+state == "nm" && ($1 == "U" || $2 == "U") {
+  next;
+}
+
+state == "nm" && NF == 3 {
+  if ($3 ~ /^[^@]*@GCC_[0-9.]*$/) {
+    def[$3] = 1
+    tl=$3
+    sub(/^.*@/,"",tl)
+    ver[$3] = tl
+  } else {
+    sub(/@@?GCC_[0-9.]*$/,"",$3)
+    def[$3] = 1;
+  }
+  sawsymbol = 1;
+  next;
+}
+
+state == "nm" {
+  next;
+}
+
+# Now we process a simplified variant of the Solaris symbol version
+# script.  We have one symbol per line, no semicolons, simple markers
+# for beginning and ending each section, and %inherit markers for
+# describing version inheritence.  A symbol may appear in more than
+# one symbol version, and the last seen takes effect.
+
+NF == 3 && $1 == "%inherit" {
+  inherit[$2] = $3;
+  next;
+}
+
+NF == 2 && $2 == "{" {
+  libs[$1] = 1;
+  thislib = $1;
+  next;
+}
+
+$1 == "}" {
+  thislib = "";
+  next;
+}
+
+{
+  ver[$1] = thislib;
+  next;
+}
+
+END {
+  if (!sawsymbol)
+    {
+      print "No symbols seen -- broken or mis-installed nm?" | "cat 1>&2";
+      exit 1;
+    }
+  for (l in libs)
+    output(l);
+}
+
+function output(lib) {
+  if (done[lib])
+    return;
+  done[lib] = 1;
+  if (inherit[lib])
+    output(inherit[lib]);
+
+  empty=1
+  for (sym in ver)
+    if ((ver[sym] == lib) && (sym in def))
+      {
+	if (empty)
+	  {
+	    printf("%s {\n", lib);
+	    printf("  global:\n");
+	    empty = 0;
+	  }
+	symp = sym;
+	sub(/@GCC_[0-9.]*$/,"",symp);
+	printf("\t%s;\n", symp);
+	if (dotsyms)
+	  printf("\t.%s;\n", symp);
+      }
+
+  if (empty)
+    {
+      for (l in libs)
+	if (inherit[l] == lib)
+	  inherit[l] = inherit[lib];
+    }
+  else if (inherit[lib])
+    printf("} %s;\n", inherit[lib]);
+  else
+    printf ("\n  local:\n\t*;\n};\n");
+}
diff -r -u -N gcc-3.4.6_orig/gcc/config/ia64/t-glibc gcc-3.4.6/gcc/config/ia64/t-glibc
--- gcc-3.4.6_orig/gcc/config/ia64/t-glibc	2007-09-30 14:28:14.000000000 +0200
+++ gcc-3.4.6/gcc/config/ia64/t-glibc	2007-09-30 14:36:21.000000000 +0200
@@ -1,3 +1,8 @@
 # Use system libunwind library on IA-64 GLIBC based system.
+
+MULTILIB_OPTIONS = m64/m32
+MULTILIB_DIRNAMES = 64 32
+MULTILIB_EXCEPTIONS = m32
+MULTILIB_OSDIRNAMES = ../lib64 ../lib
 LIB2ADDEH = $(srcdir)/unwind-sjlj.c $(srcdir)/unwind-c.c \
   $(srcdir)/unwind-compat.c
diff -r -u -N gcc-3.4.6_orig/gcc/config/ia64/t-glibc-no-libunwind gcc-3.4.6/gcc/config/ia64/t-glibc-no-libunwind
--- gcc-3.4.6_orig/gcc/config/ia64/t-glibc-no-libunwind	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc/config/ia64/t-glibc-no-libunwind	2007-09-30 14:31:51.000000000 +0200
@@ -0,0 +1,32 @@
+# Don't use system libunwind library on IA-64 GLIBC based system,
+# but make _Unwind_* symbols unversioned, so that created programs
+# are usable even when libgcc_s uses libunwind.
+LIB2ADDEH += $(srcdir)/config/ia64/fde-glibc.c
+LIB2ADDEH += $(srcdir)/config/ia64/unwind-shared-ia64.c
+LIB2ADDEHSTATIC = $(srcdir)/config/ia64/unwind-ia64.c $(srcdir)/unwind-sjlj.c \
+  $(srcdir)/unwind-c.c $(srcdir)/gthr-gnat.c $(srcdir)/config/ia64/fde-glibc.c
+LIB2ADDEHSHARED = $(srcdir)/config/ia64/unwind-shared-ia64.c $(srcdir)/unwind-sjlj.c \
+  $(srcdir)/unwind-c.c $(srcdir)/gthr-gnat.c $(srcdir)/config/ia64/fde-glibc.c
+SHLIB_MAPFILES += $(srcdir)/config/ia64/libgcc-ia64-no-libunwind.ver
+SHLIB_MKMAP = $(srcdir)/config/ia64/mkmap-symver-multi.awk
+
+SHLIB_LINK = $(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) -shared -nodefaultlibs \
+	-Wl,--soname=$(SHLIB_SONAME) \
+	-Wl,--version-script=$(SHLIB_MAP) \
+	-o $(SHLIB_NAME).tmp @multilib_flags@ $(SHLIB_OBJS) -lc && \
+	rm -f $(SHLIB_SOLINK) && \
+	if [ -f $(SHLIB_NAME) ]; then \
+	  mv -f $(SHLIB_NAME) $(SHLIB_NAME).`basename $(STAGE_PREFIX)`; \
+	else true; fi && \
+	gcc -O2 -o $(SHLIB_NAME).tweak $(srcdir)/config/ia64/change-symver.c -lelf && \
+	./$(SHLIB_NAME).tweak $(SHLIB_NAME).tmp GCC_3.4.2 _GLOBAL_ \
+	_Unwind_GetGR _Unwind_RaiseException _Unwind_GetRegionStart _Unwind_SetIP \
+	_Unwind_GetIP _Unwind_GetLanguageSpecificData _Unwind_Resume \
+	_Unwind_DeleteException _Unwind_SetGR _Unwind_ForcedUnwind \
+	_Unwind_Backtrace _Unwind_FindEnclosingFunction _Unwind_GetCFA \
+	_Unwind_Resume_or_Rethrow _Unwind_GetBSP && \
+	rm -f $(SHLIB_NAME).tweak && \
+	mv $(SHLIB_NAME).tmp $(SHLIB_NAME) && \
+	$(LN_S) $(SHLIB_NAME) $(SHLIB_SOLINK)
+
+TARGET_LIBGCC2_CFLAGS += -DUSE_SYMVER_GLOBAL
diff -r -u -N gcc-3.4.6_orig/gcc/config/ia64/unwind-ia64.c gcc-3.4.6/gcc/config/ia64/unwind-ia64.c
--- gcc-3.4.6_orig/gcc/config/ia64/unwind-ia64.c	2007-09-30 14:28:14.000000000 +0200
+++ gcc-3.4.6/gcc/config/ia64/unwind-ia64.c	2007-09-30 14:31:51.000000000 +0200
@@ -51,6 +51,51 @@
 #define UNW_FLAG_UHANDLER(x)	((x) & 0x0000000200000000L)
 #define UNW_LENGTH(x)		((x) & 0x00000000ffffffffL)
 
+#if defined (USE_SYMVER_GLOBAL) && defined (SHARED)
+extern _Unwind_Reason_Code __symverglobal_Unwind_Backtrace
+  (_Unwind_Trace_Fn, void *);
+extern void __symverglobal_Unwind_DeleteException
+  (struct _Unwind_Exception *);
+extern void * __symverglobal_Unwind_FindEnclosingFunction (void *);
+extern _Unwind_Reason_Code __symverglobal_Unwind_ForcedUnwind
+  (struct _Unwind_Exception *, _Unwind_Stop_Fn, void *);
+extern _Unwind_Word __symverglobal_Unwind_GetCFA
+  (struct _Unwind_Context *);
+extern _Unwind_Word __symverglobal_Unwind_GetBSP
+  (struct _Unwind_Context *);
+extern _Unwind_Word __symverglobal_Unwind_GetGR
+  (struct _Unwind_Context *, int );
+extern _Unwind_Ptr __symverglobal_Unwind_GetIP (struct _Unwind_Context *);
+extern void *__symverglobal_Unwind_GetLanguageSpecificData
+  (struct _Unwind_Context *);
+extern _Unwind_Ptr __symverglobal_Unwind_GetRegionStart
+  (struct _Unwind_Context *);
+extern _Unwind_Reason_Code __symverglobal_Unwind_RaiseException
+  (struct _Unwind_Exception *);
+extern void __symverglobal_Unwind_Resume (struct _Unwind_Exception *);
+extern _Unwind_Reason_Code __symverglobal_Unwind_Resume_or_Rethrow
+   (struct _Unwind_Exception *);
+extern void __symverglobal_Unwind_SetGR
+  (struct _Unwind_Context *, int, _Unwind_Word);
+extern void __symverglobal_Unwind_SetIP
+  (struct _Unwind_Context *, _Unwind_Ptr);
+#define _Unwind_Backtrace __symverglobal_Unwind_Backtrace
+#define _Unwind_DeleteException __symverglobal_Unwind_DeleteException
+#define _Unwind_FindEnclosingFunction __symverglobal_Unwind_FindEnclosingFunction
+#define _Unwind_ForcedUnwind __symverglobal_Unwind_ForcedUnwind
+#define _Unwind_GetBSP __symverglobal_Unwind_GetBSP
+#define _Unwind_GetCFA __symverglobal_Unwind_GetCFA
+#define _Unwind_GetGR __symverglobal_Unwind_GetGR
+#define _Unwind_GetIP __symverglobal_Unwind_GetIP
+#define _Unwind_GetLanguageSpecificData __symverglobal_Unwind_GetLanguageSpecificData
+#define _Unwind_GetRegionStart __symverglobal_Unwind_GetRegionStart
+#define _Unwind_RaiseException __symverglobal_Unwind_RaiseException
+#define _Unwind_Resume __symverglobal_Unwind_Resume
+#define _Unwind_Resume_or_Rethrow __symverglobal_Unwind_Resume_or_Rethrow
+#define _Unwind_SetGR __symverglobal_Unwind_SetGR
+#define _Unwind_SetIP __symverglobal_Unwind_SetIP
+#endif
+
 enum unw_application_register
 {
   UNW_AR_BSP,
@@ -2404,4 +2449,44 @@
 alias (_Unwind_SetIP);
 #endif
 
+#if defined (USE_SYMVER_GLOBAL) && defined (SHARED)
+#undef alias
+#define symverglobal(name, version) \
+__typeof (__symverglobal##name) __symverlocal##name		\
+  __attribute__ ((alias ("__symverglobal" #name)));		\
+__asm__ (".symver __symverglobal" #name"," #name "@@GCC_3.4.2");\
+__asm__ (".symver __symverlocal" #name"," #name "@" #version)
+
+#undef _Unwind_Backtrace
+#undef _Unwind_DeleteException
+#undef _Unwind_FindEnclosingFunction
+#undef _Unwind_ForcedUnwind
+#undef _Unwind_GetBSP
+#undef _Unwind_GetCFA
+#undef _Unwind_GetGR
+#undef _Unwind_GetIP
+#undef _Unwind_GetLanguageSpecificData
+#undef _Unwind_GetRegionStart
+#undef _Unwind_RaiseException
+#undef _Unwind_Resume
+#undef _Unwind_Resume_or_Rethrow
+#undef _Unwind_SetGR
+#undef _Unwind_SetIP
+symverglobal (_Unwind_Backtrace, GCC_3.3);
+symverglobal (_Unwind_DeleteException, GCC_3.0);
+symverglobal (_Unwind_FindEnclosingFunction, GCC_3.3);
+symverglobal (_Unwind_ForcedUnwind, GCC_3.0);
+symverglobal (_Unwind_GetBSP, GCC_3.3.2);
+symverglobal (_Unwind_GetCFA, GCC_3.3);
+symverglobal (_Unwind_GetGR, GCC_3.0);
+symverglobal (_Unwind_GetIP, GCC_3.0);
+symverglobal (_Unwind_GetLanguageSpecificData, GCC_3.0);
+symverglobal (_Unwind_GetRegionStart, GCC_3.0);
+symverglobal (_Unwind_RaiseException, GCC_3.0);
+symverglobal (_Unwind_Resume, GCC_3.0);
+symverglobal (_Unwind_Resume_or_Rethrow, GCC_3.3);
+symverglobal (_Unwind_SetGR, GCC_3.0);
+symverglobal (_Unwind_SetIP, GCC_3.0);
+#endif
+
 #endif
diff -r -u -N gcc-3.4.6_orig/gcc/config/ia64/unwind-shared-ia64.c gcc-3.4.6/gcc/config/ia64/unwind-shared-ia64.c
--- gcc-3.4.6_orig/gcc/config/ia64/unwind-shared-ia64.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc/config/ia64/unwind-shared-ia64.c	2007-09-30 14:31:51.000000000 +0200
@@ -0,0 +1,2 @@
+#define SHARED
+#include "unwind-ia64.c"
diff -r -u -N gcc-3.4.6_orig/gcc/config/m68k/m68k.md gcc-3.4.6/gcc/config/m68k/m68k.md
--- gcc-3.4.6_orig/gcc/config/m68k/m68k.md	2007-09-30 14:28:17.000000000 +0200
+++ gcc-3.4.6/gcc/config/m68k/m68k.md	2007-09-30 14:33:45.000000000 +0200
@@ -1454,11 +1454,20 @@
   ""
 {
   CC_STATUS_INIT;
-  operands[2] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);
-  if (TARGET_68020 || TARGET_COLDFIRE)
-    return "move%.b %1,%2\;extb%.l %2\;smi %0\;extb%.l %0";
+  if (ADDRESS_REG_P(operands[1]))
+    {
+      if (TARGET_68020 || TARGET_COLDFIRE)
+        return "move%.w %1,%R0\;extb%.l %R0\;smi %0\;extb%.l %0";
+      else
+        return "move%.w %1,%R0\;ext%.w %R0\;ext%.l %R0\;move%.l %R0,%0\;smi %0";
+    }
   else
-    return "move%.b %1,%2\;ext%.w %0\;ext%.l %2\;move%.l %2,%0\;smi %0";
+    {
+      if (TARGET_68020 || TARGET_COLDFIRE)
+        return "move%.b %1,%R0\;extb%.l %R0\;smi %0\;extb%.l %0";
+      else
+        return "move%.b %1,%R0\;ext%.w %R0\;ext%.l %R0\;move%.l %R0,%0\;smi %0";
+    }
 })
 
 (define_insn "extendhidi2"
@@ -4834,8 +4843,8 @@
 (define_insn ""
   [(set (match_operand:SI 0 "nonimmediate_operand" "=d")
 	(sign_extract:SI (match_operand:QI 1 "memory_operand" "o")
-			 (match_operand:SI 2 "general_operand" "di")
-			 (match_operand:SI 3 "general_operand" "di")))]
+			 (match_operand:SI 2 "general_operand" "dn")
+			 (match_operand:SI 3 "general_operand" "dn")))]
   "TARGET_68020 && TARGET_BITFIELD"
   "bfexts %1{%b3:%b2},%0")
 
@@ -4850,8 +4859,8 @@
 (define_insn ""
   [(set (match_operand:SI 0 "nonimmediate_operand" "=d,d")
 	(zero_extract:SI (match_operand:QI 1 "memory_operand" "o,d")
-			 (match_operand:SI 2 "general_operand" "di,di")
-			 (match_operand:SI 3 "general_operand" "di,di")))]
+			 (match_operand:SI 2 "general_operand" "dn,dn")
+			 (match_operand:SI 3 "general_operand" "dn,dn")))]
   "TARGET_68020 && TARGET_BITFIELD"
 {
   if (GET_CODE (operands[2]) == CONST_INT)
@@ -4868,8 +4877,8 @@
 
 (define_insn ""
   [(set (zero_extract:SI (match_operand:QI 0 "memory_operand" "+o")
-			 (match_operand:SI 1 "general_operand" "di")
-			 (match_operand:SI 2 "general_operand" "di"))
+			 (match_operand:SI 1 "general_operand" "dn")
+			 (match_operand:SI 2 "general_operand" "dn"))
         (xor:SI (zero_extract:SI (match_dup 0) (match_dup 1) (match_dup 2))
 		(match_operand 3 "const_int_operand" "n")))]
   "TARGET_68020 && TARGET_BITFIELD
@@ -4883,8 +4892,8 @@
 
 (define_insn ""
   [(set (zero_extract:SI (match_operand:QI 0 "memory_operand" "+o")
-			 (match_operand:SI 1 "general_operand" "di")
-			 (match_operand:SI 2 "general_operand" "di"))
+			 (match_operand:SI 1 "general_operand" "dn")
+			 (match_operand:SI 2 "general_operand" "dn"))
 	(const_int 0))]
   "TARGET_68020 && TARGET_BITFIELD"
 {
@@ -4894,8 +4903,8 @@
 
 (define_insn ""
   [(set (zero_extract:SI (match_operand:QI 0 "memory_operand" "+o")
-			 (match_operand:SI 1 "general_operand" "di")
-			 (match_operand:SI 2 "general_operand" "di"))
+			 (match_operand:SI 1 "general_operand" "dn")
+			 (match_operand:SI 2 "general_operand" "dn"))
 	(const_int -1))]
   "TARGET_68020 && TARGET_BITFIELD"
 {
@@ -4913,8 +4922,8 @@
 
 (define_insn ""
   [(set (zero_extract:SI (match_operand:QI 0 "memory_operand" "+o")
-			 (match_operand:SI 1 "general_operand" "di")
-			 (match_operand:SI 2 "general_operand" "di"))
+			 (match_operand:SI 1 "general_operand" "dn")
+			 (match_operand:SI 2 "general_operand" "dn"))
 	(match_operand:SI 3 "register_operand" "d"))]
   "TARGET_68020 && TARGET_BITFIELD"
   "bfins %3,%0{%b2:%b1}")
@@ -4925,16 +4934,16 @@
 (define_insn ""
   [(set (match_operand:SI 0 "nonimmediate_operand" "=d")
 	(sign_extract:SI (match_operand:SI 1 "register_operand" "d")
-			 (match_operand:SI 2 "general_operand" "di")
-			 (match_operand:SI 3 "general_operand" "di")))]
+			 (match_operand:SI 2 "general_operand" "dn")
+			 (match_operand:SI 3 "general_operand" "dn")))]
   "TARGET_68020 && TARGET_BITFIELD"
   "bfexts %1{%b3:%b2},%0")
 
 (define_insn ""
   [(set (match_operand:SI 0 "nonimmediate_operand" "=d")
 	(zero_extract:SI (match_operand:SI 1 "register_operand" "d")
-			 (match_operand:SI 2 "general_operand" "di")
-			 (match_operand:SI 3 "general_operand" "di")))]
+			 (match_operand:SI 2 "general_operand" "dn")
+			 (match_operand:SI 3 "general_operand" "dn")))]
   "TARGET_68020 && TARGET_BITFIELD"
 {
   if (GET_CODE (operands[2]) == CONST_INT)
@@ -4951,8 +4960,8 @@
 
 (define_insn ""
   [(set (zero_extract:SI (match_operand:SI 0 "register_operand" "+d")
-			 (match_operand:SI 1 "general_operand" "di")
-			 (match_operand:SI 2 "general_operand" "di"))
+			 (match_operand:SI 1 "general_operand" "dn")
+			 (match_operand:SI 2 "general_operand" "dn"))
 	(const_int 0))]
   "TARGET_68020 && TARGET_BITFIELD"
 {
@@ -4962,8 +4971,8 @@
 
 (define_insn ""
   [(set (zero_extract:SI (match_operand:SI 0 "register_operand" "+d")
-			 (match_operand:SI 1 "general_operand" "di")
-			 (match_operand:SI 2 "general_operand" "di"))
+			 (match_operand:SI 1 "general_operand" "dn")
+			 (match_operand:SI 2 "general_operand" "dn"))
 	(const_int -1))]
   "TARGET_68020 && TARGET_BITFIELD"
 {
@@ -4973,8 +4982,8 @@
 
 (define_insn ""
   [(set (zero_extract:SI (match_operand:SI 0 "register_operand" "+d")
-			 (match_operand:SI 1 "general_operand" "di")
-			 (match_operand:SI 2 "general_operand" "di"))
+			 (match_operand:SI 1 "general_operand" "dn")
+			 (match_operand:SI 2 "general_operand" "dn"))
 	(match_operand:SI 3 "register_operand" "d"))]
   "TARGET_68020 && TARGET_BITFIELD"
 {
@@ -4996,7 +5005,7 @@
   [(set (cc0)
 	(zero_extract:SI (match_operand:QI 0 "memory_operand" "o")
 			 (match_operand:SI 1 "const_int_operand" "n")
-			 (match_operand:SI 2 "general_operand" "di")))]
+			 (match_operand:SI 2 "general_operand" "dn")))]
   "TARGET_68020 && TARGET_BITFIELD"
 {
   if (operands[1] == const1_rtx
@@ -5021,7 +5030,7 @@
   [(set (cc0)
 	(zero_extract:SI (match_operand:SI 0 "register_operand" "d")
 			 (match_operand:SI 1 "const_int_operand" "n")
-			 (match_operand:SI 2 "general_operand" "di")))]
+			 (match_operand:SI 2 "general_operand" "dn")))]
   "TARGET_68020 && TARGET_BITFIELD"
 {
   if (operands[1] == const1_rtx
diff -r -u -N gcc-3.4.6_orig/gcc/config/netbsd-elf.h gcc-3.4.6/gcc/config/netbsd-elf.h
--- gcc-3.4.6_orig/gcc/config/netbsd-elf.h	2007-09-30 14:28:16.000000000 +0200
+++ gcc-3.4.6/gcc/config/netbsd-elf.h	2007-09-30 14:32:08.000000000 +0200
@@ -83,6 +83,7 @@
 #define NETBSD_LINK_SPEC_ELF \
   "%{assert*} %{R*} %{rpath*} \
    %{shared:-shared} \
+   %{symbolic:-Bsymbolic} \
    %{!shared: \
      -dc -dp \
      %{!nostdlib: \
diff -r -u -N gcc-3.4.6_orig/gcc/config/openbsd.h gcc-3.4.6/gcc/config/openbsd.h
--- gcc-3.4.6_orig/gcc/config/openbsd.h	2007-09-30 14:28:17.000000000 +0200
+++ gcc-3.4.6/gcc/config/openbsd.h	2007-09-30 14:32:14.000000000 +0200
@@ -52,15 +52,14 @@
 
 #ifdef OPENBSD_NATIVE
 
-#undef GCC_INCLUDE_DIR
-#define GCC_INCLUDE_DIR "/usr/include"
-
 /* The compiler is configured with ONLY the gcc/g++ standard headers.  */
 #undef INCLUDE_DEFAULTS
 #define INCLUDE_DEFAULTS			\
   {						\
     { GPLUSPLUS_INCLUDE_DIR, "G++", 1, 1 },	\
-    { GCC_INCLUDE_DIR, "GCC", 0, 0 },		\
+    { GPLUSPLUS_TOOL_INCLUDE_DIR, "G++", 1, 1 }, \
+    { GPLUSPLUS_BACKWARD_INCLUDE_DIR, "G++", 1, 1 }, \
+    { STANDARD_INCLUDE_DIR, STANDARD_INCLUDE_COMPONENT, 0, 0 }, \
     { 0, 0, 0, 0 }				\
   }
 
@@ -72,9 +71,39 @@
 
 
 /* Controlling the compilation driver.  */
+/* TARGET_OS_CPP_BUILTINS() common to all OpenBSD targets.  */
+#define OPENBSD_OS_CPP_BUILTINS_COMMON()	\
+  do						\
+    {						\
+      builtin_define ("__OpenBSD__");		\
+      builtin_define ("__unix__");		\
+      builtin_define ("__ANSI_COMPAT");		\
+      builtin_assert ("system=unix");		\
+      builtin_assert ("system=bsd");		\
+      builtin_assert ("system=OpenBSD");	\
+    }						\
+  while (0)
+
+/* TARGET_OS_CPP_BUILTINS() common to all OpenBSD ELF targets.  */
+#define OPENBSD_OS_CPP_BUILTINS_ELF()		\
+  do						\
+    {						\
+      OPENBSD_OS_CPP_BUILTINS_COMMON();		\
+      builtin_define ("__ELF__");		\
+    }						\
+  while (0)
+
+/* TARGET_OS_CPP_BUILTINS() common to all LP64 OpenBSD targets.  */
+#define OPENBSD_OS_CPP_BUILTINS_LP64()		\
+  do						\
+    {						\
+      builtin_define ("_LP64");			\
+      builtin_define ("__LP64__");		\
+    }						\
+  while (0)
 
 /* CPP_SPEC appropriate for OpenBSD. We deal with -posix and -pthread.
-   XXX the way threads are handling currently is not very satisfying,
+   XXX the way threads are handled currently is not very satisfying,
    since all code must be compiled with -pthread to work. 
    This two-stage defines makes it easy to pick that for targets that
    have subspecs.  */
@@ -84,10 +113,9 @@
 #define OBSD_CPP_SPEC "%{posix:-D_POSIX_SOURCE} %{pthread:-D_POSIX_THREADS}"
 #endif
 
-/* LIB_SPEC appropriate for OpenBSD.  Select the appropriate libc, 
-   depending on profiling and threads.  Basically, 
-   -lc(_r)?(_p)?, select _r for threads, and _p for p or pg.  */
-#define OBSD_LIB_SPEC "%{!shared:-lc%{pthread:_r}%{p:_p}%{!p:%{pg:_p}}}"
+/* LIB_SPEC appropriate for OpenBSD.  Include -lpthread if -pthread is
+   specified on the command line. */
+#define OBSD_LIB_SPEC "%{!shared:%{pthread:-lpthread%{p:_p}%{!p:%{pg:_p}}}} %{!shared:-lc%{p:_p}%{!p:%{pg:_p}}}"
 
 #ifndef OBSD_HAS_CORRECT_SPECS
 
diff -r -u -N gcc-3.4.6_orig/gcc/config/rs6000/ppc-asm.h gcc-3.4.6/gcc/config/rs6000/ppc-asm.h
--- gcc-3.4.6_orig/gcc/config/rs6000/ppc-asm.h	2007-09-30 14:28:13.000000000 +0200
+++ gcc-3.4.6/gcc/config/rs6000/ppc-asm.h	2007-09-30 14:36:13.000000000 +0200
@@ -158,7 +158,7 @@
 	.size FUNC_NAME(name),GLUE(.L,name)-FUNC_NAME(name)
 #endif
 
-#if defined __linux__ && !defined __powerpc64__
+#if defined __linux__
 	.section .note.GNU-stack
 	.previous
 #endif
diff -r -u -N gcc-3.4.6_orig/gcc/config/rs6000/rs6000.c gcc-3.4.6/gcc/config/rs6000/rs6000.c
--- gcc-3.4.6_orig/gcc/config/rs6000/rs6000.c	2007-09-30 14:28:14.000000000 +0200
+++ gcc-3.4.6/gcc/config/rs6000/rs6000.c	2007-09-30 14:32:01.000000000 +0200
@@ -1177,6 +1177,12 @@
       if (*start == '\0')
 	putc ('\n', file);
     }
+
+  if (DEFAULT_ABI == ABI_AIX || (TARGET_ELF && flag_pic == 2))
+    {
+      toc_section ();
+      text_section ();
+    }
 }
 
 /* Return nonzero if this function is known to have a null epilogue.  */
@@ -11452,13 +11458,6 @@
 		   ? gen_rtx_REG (Pmode, 0)
 		   : gen_reg_rtx (Pmode));
 
-      /* possibly create the toc section */
-      if (! toc_initialized)
-	{
-	  toc_section ();
-	  function_section (current_function_decl);
-	}
-
       if (fromprolog)
 	{
 	  rtx symF, symL;
@@ -15920,7 +15919,6 @@
   fputs ("\t.file\t", asm_out_file);
   output_quoted_string (asm_out_file, main_input_filename);
   fputc ('\n', asm_out_file);
-  toc_section ();
   if (write_symbols != NO_DEBUG)
     private_data_section ();
   text_section ();
diff -r -u -N gcc-3.4.6_orig/gcc/config/rs6000/t-linux64 gcc-3.4.6/gcc/config/rs6000/t-linux64
--- gcc-3.4.6_orig/gcc/config/rs6000/t-linux64	2007-09-30 14:28:13.000000000 +0200
+++ gcc-3.4.6/gcc/config/rs6000/t-linux64	2007-09-30 14:31:21.000000000 +0200
@@ -9,13 +9,13 @@
 
 SHLIB_MAPFILES += $(srcdir)/config/rs6000/libgcc-ppc64.ver
 
-MULTILIB_OPTIONS        = m64/m32 msoft-float
-MULTILIB_DIRNAMES       = 64 32 nof
+MULTILIB_OPTIONS        = m64/m32
+MULTILIB_DIRNAMES       = 64 32
 MULTILIB_EXTRA_OPTS     = fPIC mstrict-align
-MULTILIB_EXCEPTIONS     = m64/msoft-float
-MULTILIB_EXCLUSIONS     = m64/!m32/msoft-float
-MULTILIB_OSDIRNAMES	= ../lib64 ../lib nof
-MULTILIB_MATCHES        = $(MULTILIB_MATCHES_FLOAT)
+MULTILIB_EXCEPTIONS     =
+MULTILIB_EXCLUSIONS     =
+MULTILIB_OSDIRNAMES	= ../lib64 ../lib
+MULTILIB_MATCHES        =
 
 # We want fine grained libraries, so use the new code to build the
 # floating point emulation libraries.
diff -r -u -N gcc-3.4.6_orig/gcc/config/sh/lib1funcs.asm gcc-3.4.6/gcc/config/sh/lib1funcs.asm
--- gcc-3.4.6_orig/gcc/config/sh/lib1funcs.asm	2007-09-30 14:28:15.000000000 +0200
+++ gcc-3.4.6/gcc/config/sh/lib1funcs.asm	2007-09-30 14:36:53.000000000 +0200
@@ -37,9 +37,19 @@
    ELF local label prefixes by J"orn Rennecke
    amylaar@cygnus.com  */
 
+#define ALIAS(X,Y)	.global GLOBAL(X); .set GLOBAL(X),GLOBAL(Y)
+
 #ifdef __ELF__
 #define LOCAL(X)	.L_##X
-#define FUNC(X)		.type X,@function
+
+#if 1 /* ??? The export list mechanism is broken, everything that is not
+	 hidden is exported.  */
+#undef FUNC
+#define FUNC(X)		.type X,@function; .hidden X
+#undef ALIAS
+#define ALIAS(X,Y)	.global GLOBAL(X); .set GLOBAL(X),GLOBAL(Y); .hidden GLOBAL(X)
+#endif
+
 #define ENDFUNC0(X)	.Lfe_##X: .size X,.Lfe_##X-X
 #define ENDFUNC(X)	ENDFUNC0(X)
 #else
diff -r -u -N gcc-3.4.6_orig/gcc/config/sh/sh.c gcc-3.4.6/gcc/config/sh/sh.c
--- gcc-3.4.6_orig/gcc/config/sh/sh.c	2007-09-30 14:28:15.000000000 +0200
+++ gcc-3.4.6/gcc/config/sh/sh.c	2007-09-30 14:37:04.000000000 +0200
@@ -8999,6 +8999,9 @@
       && REGCLASS_HAS_FP_REG (dstclass))
     return 4;
 
+  if (REGCLASS_HAS_FP_REG (dstclass) && srcclass == T_REGS)
+    return ((TARGET_HARD_SH4 && !optimize_size) ? 10 : 7);
+
   if ((REGCLASS_HAS_FP_REG (dstclass) && srcclass == MAC_REGS)
       || (dstclass== MAC_REGS && REGCLASS_HAS_FP_REG (srcclass)))
     return 9;
@@ -9107,6 +9110,15 @@
     }
   this = FUNCTION_ARG (cum, Pmode, ptr_type_node, 1);
 
+  /* In PIC case, we set PIC register to compute the target address.  We
+     can use a scratch register to save and restore the original value  
+     except for SHcompact.  For SHcompact, use stack.  */
+  if (flag_pic && TARGET_SHCOMPACT)
+    {
+      push (PIC_OFFSET_TABLE_REGNUM);
+      emit_insn (gen_GOTaddr2picreg ());
+    }
+
   /* For SHcompact, we only have r0 for a scratch register: r1 is the
      static chain pointer (even if you can't have nested virtual functions
      right now, someone might implement them sometime), and the rest of the
@@ -9189,8 +9201,24 @@
       assemble_external (function);
       TREE_USED (function) = 1;
     }
+  /* We can use scratch1 to save and restore the original value of
+     PIC register except for SHcompact.  */
+  if (flag_pic && ! TARGET_SHCOMPACT)
+    {
+      emit_move_insn (scratch1,
+		      gen_rtx_REG (Pmode, PIC_OFFSET_TABLE_REGNUM));
+      emit_insn (gen_GOTaddr2picreg ());
+    }
   funexp = XEXP (DECL_RTL (function), 0);
   emit_move_insn (scratch2, funexp);
+  if (flag_pic)
+    {
+      if (! TARGET_SHCOMPACT)
+	emit_move_insn (gen_rtx_REG (Pmode, PIC_OFFSET_TABLE_REGNUM),
+			scratch1);
+      else
+	pop (PIC_OFFSET_TABLE_REGNUM);
+    }
   funexp = gen_rtx_MEM (FUNCTION_MODE, scratch2);
   sibcall = emit_call_insn (gen_sibcall (funexp, const0_rtx, NULL_RTX));
   SIBLING_CALL_P (sibcall) = 1;
diff -r -u -N gcc-3.4.6_orig/gcc/config/sh/sh.h gcc-3.4.6/gcc/config/sh/sh.h
--- gcc-3.4.6_orig/gcc/config/sh/sh.h	2007-09-30 14:28:15.000000000 +0200
+++ gcc-3.4.6/gcc/config/sh/sh.h	2007-09-30 14:36:50.000000000 +0200
@@ -422,6 +422,10 @@
 do {									\
   if (LEVEL)								\
     flag_omit_frame_pointer = -1;					\
+  if (LEVEL <= 2)							\
+    {									\
+      flag_reorder_blocks = 0;						\
+    }									\
   if (SIZE)								\
     target_flags |= SPACE_BIT;						\
   if (TARGET_SHMEDIA && LEVEL > 1)					\
diff -r -u -N gcc-3.4.6_orig/gcc/config/sparc/openbsd.h gcc-3.4.6/gcc/config/sparc/openbsd.h
--- gcc-3.4.6_orig/gcc/config/sparc/openbsd.h	2007-09-30 14:28:16.000000000 +0200
+++ gcc-3.4.6/gcc/config/sparc/openbsd.h	2007-09-30 14:32:14.000000000 +0200
@@ -22,10 +22,7 @@
 #define TARGET_OS_CPP_BUILTINS()		\
   do						\
     {						\
-	builtin_define ("__unix__");		\
-	builtin_define ("__OpenBSD__");		\
-	builtin_assert ("system=unix");		\
-	builtin_assert ("system=OpenBSD");	\
+      OPENBSD_OS_CPP_BUILTINS_ELF();		\
     }						\
   while (0)
 
@@ -44,6 +41,23 @@
 #undef WCHAR_TYPE_SIZE
 #define WCHAR_TYPE_SIZE 32
 
+#undef LINK_SPEC
+#define LINK_SPEC \
+  "%{!shared:%{!nostdlib:%{!r*:%{!e*:-e __start}}}} \
+   %{shared:-shared} %{R*} \
+   %{static:-Bstatic} \
+   %{!static:-Bdynamic} \
+   %{assert*} \
+   %{!dynamic-linker:-dynamic-linker /usr/libexec/ld.so}"
+
+/* As an elf system, we need crtbegin/crtend stuff.  */
+#undef STARTFILE_SPEC
+#define STARTFILE_SPEC "\
+	%{!shared: %{pg:gcrt0%O%s} %{!pg:%{p:gcrt0%O%s} %{!p:crt0%O%s}} \
+	crtbegin%O%s} %{shared:crtbeginS%O%s}"
+#undef ENDFILE_SPEC
+#define ENDFILE_SPEC "%{!shared:crtend%O%s} %{shared:crtendS%O%s}"
+
 /* Specific options for DBX Output.  */
 
 /* This is BSD, so it wants DBX format.  */
diff -r -u -N gcc-3.4.6_orig/gcc/config.gcc gcc-3.4.6/gcc/config.gcc
--- gcc-3.4.6_orig/gcc/config.gcc	2007-09-30 14:28:08.000000000 +0200
+++ gcc-3.4.6/gcc/config.gcc	2007-09-30 14:33:23.000000000 +0200
@@ -678,6 +678,11 @@
 	;;
 arm*-*-linux*)			# ARM GNU/Linux with ELF
 	tm_file="dbxelf.h elfos.h linux.h arm/elf.h  arm/linux-gas.h arm/linux-elf.h arm/aout.h arm/arm.h"
+	case $target in
+	arm*b-*)
+		tm_defines="TARGET_BIG_ENDIAN_DEFAULT=1 $tm_defines"
+		;;
+	esac
 	tmake_file="t-slibgcc-elf-ver t-linux arm/t-linux"
 	extra_parts="crtbegin.o crtbeginS.o crtend.o crtendS.o"
 	gnu_ld=yes
@@ -977,11 +982,11 @@
 	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h netbsd.h netbsd-elf.h i386/x86-64.h i386/netbsd64.h"
 	;;
 i[34567]86-*-openbsd*)
-	tm_file="i386/i386.h i386/unix.h i386/bsd.h i386/gas.h i386/gstabs.h openbsd-oldgas.h openbsd.h i386/openbsd.h"
-	# needed to unconfuse gdb
-	tmake_file="t-libc-ok t-openbsd i386/t-openbsd"
-	# we need collect2 until our bug is fixed...
-	use_collect2=yes
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h i386/i386elf.h"
+	tm_file="${tm_file} openbsd.h i386/openbsdelf.h"
+	gas=yes
+	gnu_ld=yes
+	stabs=yes
 	;;
 i[34567]86-*-coff*)
 	tm_file="${tm_file} i386/unix.h i386/bsd.h i386/gas.h dbxcoff.h i386/i386-coff.h"
@@ -1280,9 +1285,16 @@
 	;;
 ia64*-*-linux*)
 	tm_file="${tm_file} dbxelf.h elfos.h svr4.h linux.h ia64/sysv4.h ia64/linux.h"
-	tmake_file="t-slibgcc-elf-ver t-linux ia64/t-ia64 t-libunwind ia64/t-glibc"
-	if test x$with_system_libunwind != xyes ; then
-		tmake_file="${tmake_file} t-libunwind-elf ia64/t-glibc-libunwind"
+	tmake_file="t-slibgcc-elf-ver t-linux ia64/t-ia64"
+	if test x${target} = x${host} && test x${target} = x${build} \
+	   && grep gelf_getverdef /usr/include/gelf.h > /dev/null 2>&1 \
+	   && test -f /usr/lib/libelf.so; then
+		tmake_file="${tmake_file} ia64/t-glibc-no-libunwind"
+	else
+		tmake_file="${tmake_file} t-libunwind ia64/t-glibc"
+		if test x$with_system_libunwind != xyes ; then
+			tmake_file="${tmake_file} t-libunwind-elf ia64/t-glibc-libunwind"
+		fi
 	fi
 	target_cpu_default="MASK_GNU_AS|MASK_GNU_LD"
 	extra_parts="crtbegin.o crtend.o crtbeginS.o crtendS.o crtfastmath.o"
@@ -2026,7 +2038,8 @@
 	;;
 sparc-*-openbsd*)
 	tm_defines=OBSD_OLD_GAS
-	tm_file="sparc/sparc.h openbsd.h sparc/openbsd.h"
+	tm_file="sparc/sparc.h elfos.h svr4.h sparc/sysv4.h ${tm_file}"
+	tm_file="${tm_file} exec-stack.h"
 	# needed to unconfuse gdb
 	tmake_file="t-libc-ok t-openbsd sparc/t-openbsd"
 	# we need collect2 until our bug is fixed...
diff -r -u -N gcc-3.4.6_orig/gcc/configure.ac gcc-3.4.6/gcc/configure.ac
--- gcc-3.4.6_orig/gcc/configure.ac	2007-09-30 14:28:09.000000000 +0200
+++ gcc-3.4.6/gcc/configure.ac	2007-09-30 14:37:00.000000000 +0200
@@ -2218,7 +2218,7 @@
 	tls_first_minor=14
 	tls_as_opt="-m64 -Aesame --fatal-warnings"
 	;;
-  sh-*-* | sh[34]-*-*)
+  sh-*-* | sh[34]*-*-*)
     conftest_s='
 	.section ".tdata","awT",@progbits
 foo:	.long	25
diff -r -u -N gcc-3.4.6_orig/gcc/cp/class.c gcc-3.4.6/gcc/cp/class.c
--- gcc-3.4.6_orig/gcc/cp/class.c	2007-09-30 14:28:19.000000000 +0200
+++ gcc-3.4.6/gcc/cp/class.c	2007-09-30 14:37:24.000000000 +0200
@@ -6803,14 +6803,8 @@
 static void
 initialize_array (tree decl, tree inits)
 {
-  tree context;
-
-  context = DECL_CONTEXT (decl);
-  DECL_CONTEXT (decl) = NULL_TREE;
   DECL_INITIAL (decl) = build_constructor (NULL_TREE, inits);
-  TREE_HAS_CONSTRUCTOR (DECL_INITIAL (decl)) = 1;
   cp_finish_decl (decl, DECL_INITIAL (decl), NULL_TREE, 0);
-  DECL_CONTEXT (decl) = context;
 }
 
 /* Build the VTT (virtual table table) for T.
diff -r -u -N gcc-3.4.6_orig/gcc/cp/cp-tree.h gcc-3.4.6/gcc/cp/cp-tree.h
--- gcc-3.4.6_orig/gcc/cp/cp-tree.h	2007-09-30 14:28:20.000000000 +0200
+++ gcc-3.4.6/gcc/cp/cp-tree.h	2007-09-30 14:37:24.000000000 +0200
@@ -75,6 +75,7 @@
           or FIELD_DECL).
       NEED_TEMPORARY_P (in REF_BIND, BASE_CONV)
       IDENTIFIER_TYPENAME_P (in IDENTIFIER_NODE)
+      DECL_TINFO_P (in VAR_DECL)
    5: C_IS_RESERVED_WORD (in IDENTIFIER_NODE)
       DECL_VTABLE_OR_VTT_P (in VAR_DECL)
    6: For future expansion
@@ -1008,7 +1009,12 @@
 #define PUBLICLY_UNIQUELY_DERIVED_P(PARENT, TYPE) \
   (lookup_base ((TYPE), (PARENT),  ba_not_special | ba_quiet, NULL) \
    != NULL_TREE)
-
+
+/* Gives the visibility specification for a class type.  */
+#define CLASSTYPE_VISIBILITY(TYPE)		DECL_VISIBILITY (TYPE_NAME (TYPE))
+#define CLASSTYPE_VISIBILITY_SPECIFIED(TYPE)	DECL_VISIBILITY_SPECIFIED (TYPE_NAME (TYPE))
+
+
 /* This is a few header flags for 'struct lang_type'.  Actually,
    all but the first are used only for lang_type_class; they
    are put in this structure to save space.  */
@@ -2064,6 +2070,10 @@
   (DECL_CONTEXT (NODE) \
    && TREE_CODE (DECL_CONTEXT (NODE)) == FUNCTION_DECL)
 
+/* 1 iff VAR_DECL node NODE is a type-info decl.  This flag is set for
+   both the primary typeinfo object and the associated NTBS name.  */
+#define DECL_TINFO_P(NODE) TREE_LANG_FLAG_4 (VAR_DECL_CHECK (NODE))
+
 /* 1 iff VAR_DECL node NODE is virtual table or VTT.  */
 #define DECL_VTABLE_OR_VTT_P(NODE) TREE_LANG_FLAG_5 (VAR_DECL_CHECK (NODE))
 
@@ -2440,13 +2450,17 @@
    When appearing in a SAVE_EXPR, it means that underneath
    is a call to a constructor.
 
-   When appearing in a CONSTRUCTOR, it means that it was
-   a GNU C constructor expression.
+   When appearing in a CONSTRUCTOR, the expression is a
+   compound literal.
 
    When appearing in a FIELD_DECL, it means that this field
    has been duly initialized in its constructor.  */
 #define TREE_HAS_CONSTRUCTOR(NODE) (TREE_LANG_FLAG_4 (NODE))
 
+/* True if NODE is a brace-enclosed initializer.  */
+#define BRACE_ENCLOSED_INITIALIZER_P(NODE) \
+  (TREE_CODE (NODE) == CONSTRUCTOR && !TREE_TYPE (NODE))
+
 #define EMPTY_CONSTRUCTOR_P(NODE) (TREE_CODE (NODE) == CONSTRUCTOR	   \
 				   && CONSTRUCTOR_ELTS (NODE) == NULL_TREE \
 				   && ! TREE_HAS_CONSTRUCTOR (NODE))
@@ -3668,7 +3682,7 @@
 extern tree check_tag_decl			(tree);
 extern tree shadow_tag				(tree);
 extern tree groktypename			(tree);
-extern tree start_decl				(tree, tree, int, tree, tree);
+extern tree start_decl				(tree, tree, int, tree, tree, bool *);
 extern void start_decl_1			(tree);
 extern void cp_finish_decl			(tree, tree, tree, int);
 extern void finish_decl				(tree, tree, tree);
@@ -3753,6 +3767,7 @@
 extern tree coerce_new_type (tree);
 extern tree coerce_delete_type (tree);
 extern void comdat_linkage (tree);
+extern void determine_visibility (tree);
 extern void import_export_vtable (tree, tree, int);
 extern void import_export_decl (tree);
 extern void import_export_tinfo	(tree, tree, bool);
diff -r -u -N gcc-3.4.6_orig/gcc/cp/decl.c gcc-3.4.6/gcc/cp/decl.c
--- gcc-3.4.6_orig/gcc/cp/decl.c	2007-09-30 14:28:19.000000000 +0200
+++ gcc-3.4.6/gcc/cp/decl.c	2007-09-30 14:37:24.000000000 +0200
@@ -1863,17 +1863,20 @@
   DECL_COMMON (newdecl) = DECL_COMMON (olddecl);
   COPY_DECL_ASSEMBLER_NAME (olddecl, newdecl);
 
-  /* If either declaration has a nondefault visibility, use it.  */
-  if (DECL_VISIBILITY (olddecl) != VISIBILITY_DEFAULT)
+  /* Warn about conflicting visibility specifications.  */
+  if (DECL_VISIBILITY_SPECIFIED (olddecl) 
+      && DECL_VISIBILITY_SPECIFIED (newdecl)
+      && DECL_VISIBILITY (newdecl) != DECL_VISIBILITY (olddecl))
+    {
+      warning ("%J'%D': visibility attribute ignored because it",
+	       newdecl, newdecl);
+      warning ("%Jconflicts with previous declaration here", olddecl);
+    }
+  /* Choose the declaration which specified visibility.  */
+  if (DECL_VISIBILITY_SPECIFIED (olddecl))
     {
-      if (DECL_VISIBILITY (newdecl) != VISIBILITY_DEFAULT
-	  && DECL_VISIBILITY (newdecl) != DECL_VISIBILITY (olddecl))
-	{
-	  warning ("%J'%D': visibility attribute ignored because it",
-		   newdecl, newdecl);
-	  warning ("%Jconflicts with previous declaration here", olddecl);
-	}
       DECL_VISIBILITY (newdecl) = DECL_VISIBILITY (olddecl);
+      DECL_VISIBILITY_SPECIFIED (newdecl) = 1;
     }
 
   if (TREE_CODE (newdecl) == FUNCTION_DECL)
@@ -3286,6 +3289,10 @@
   TREE_NOTHROW (fn) = 1;
   SET_OVERLOADED_OPERATOR_CODE (fn, operator_code);
   SET_DECL_LANGUAGE (fn, lang_c);
+  /* Runtime library routines are, by definition, available in an
+     external shared object.  */
+  DECL_VISIBILITY (fn) = VISIBILITY_DEFAULT;
+  DECL_VISIBILITY_SPECIFIED (fn) = 1;
   return fn;
 }
 
@@ -3649,7 +3656,8 @@
             tree declspecs, 
             int initialized, 
             tree attributes, 
-            tree prefix_attributes)
+            tree prefix_attributes,
+            bool *pop_scope_p)
 {
   tree decl;
   tree type, tem;
@@ -3685,14 +3693,11 @@
 
   context = DECL_CONTEXT (decl);
 
-  if (initialized && context && TREE_CODE (context) == NAMESPACE_DECL
-      && context != current_namespace && TREE_CODE (decl) == VAR_DECL)
-    {
-      /* When parsing the initializer, lookup should use the object's
-	 namespace.  */
-      push_decl_namespace (context);
-    }
-
+  if (context)
+    *pop_scope_p = push_scope (context);
+  else
+    *pop_scope_p = false;
+  
   /* We are only interested in class contexts, later.  */
   if (context && TREE_CODE (context) == NAMESPACE_DECL)
     context = NULL_TREE;
@@ -3748,8 +3753,6 @@
 
   if (context && COMPLETE_TYPE_P (complete_type (context)))
     {
-      push_nested_class (context);
-
       if (TREE_CODE (decl) == VAR_DECL)
 	{
 	  tree field = lookup_field (context, DECL_NAME (decl), 0, false);
@@ -4260,8 +4263,7 @@
      enclosed elements.  Advance past the brace-enclosed initializer
      now.  */
   if (TREE_CODE (old_init_value) == CONSTRUCTOR
-      && TREE_TYPE (old_init_value) == NULL_TREE
-      && TREE_HAS_CONSTRUCTOR (old_init_value))
+      && BRACE_ENCLOSED_INITIALIZER_P (old_init_value))
     {
       *initp = TREE_CHAIN (old_init);
       TREE_CHAIN (old_init) = NULL_TREE;
@@ -4333,8 +4335,7 @@
   else
     {
       /* Build a CONSTRUCTOR to hold the contents of the aggregate.  */  
-      new_init = build_constructor (type, NULL_TREE);
-      TREE_HAS_CONSTRUCTOR (new_init) = 1;
+      new_init = build_constructor (NULL_TREE, NULL_TREE);
 
       if (CLASS_TYPE_P (type))
 	{
@@ -4394,7 +4395,8 @@
 		}
 	    }
 	}
-      else if ((TREE_CODE (type) == ARRAY_TYPE)|| (TREE_CODE (type) == VECTOR_TYPE))
+      else if (TREE_CODE (type) == ARRAY_TYPE
+	       || TREE_CODE (type) == VECTOR_TYPE)
 	{
 	  tree max_index;
 
@@ -4492,7 +4494,8 @@
     init = grok_reference_init (decl, type, init, cleanup);
   else if (init)
     {
-      if (TREE_CODE (init) == CONSTRUCTOR && TREE_HAS_CONSTRUCTOR (init))
+      if (TREE_CODE (init) == CONSTRUCTOR 
+	  && BRACE_ENCLOSED_INITIALIZER_P (init))
 	{
 	  /* [dcl.init] paragraph 13,
 	     If T is a scalar type, then a declaration of the form
@@ -4517,15 +4520,13 @@
 	 array size from the initializer.  */
       maybe_deduce_size_from_array_init (decl, init);
       type = TREE_TYPE (decl);
-      if (TREE_CODE (init) == CONSTRUCTOR && TREE_HAS_CONSTRUCTOR (init))
-	TREE_TYPE (init) = type;
 
       if (TYPE_HAS_CONSTRUCTOR (type) || TYPE_NEEDS_CONSTRUCTING (type))
 	{
 	  if (TREE_CODE (type) == ARRAY_TYPE)
 	    goto initialize_aggr;
 	  else if (TREE_CODE (init) == CONSTRUCTOR
-		   && TREE_HAS_CONSTRUCTOR (init))
+		   && BRACE_ENCLOSED_INITIALIZER_P (init))
 	    {
 	      if (TYPE_NON_AGGREGATE_CLASS (type))
 		{
@@ -4785,20 +4786,10 @@
       && (DECL_INITIAL (decl) || init))
     DECL_INITIALIZED_IN_CLASS_P (decl) = 1;
 
-  if (TREE_CODE (decl) == VAR_DECL
-      && DECL_CONTEXT (decl)
-      && TREE_CODE (DECL_CONTEXT (decl)) == NAMESPACE_DECL
-      && DECL_CONTEXT (decl) != current_namespace
-      && init)
-    {
-      /* Leave the namespace of the object.  */
-      pop_decl_namespace ();
-    }
-
   type = TREE_TYPE (decl);
 
   if (type == error_mark_node)
-    goto finish_end0;
+    goto finish_end;
 
   if (TYPE_HAS_MUTABLE_P (type))
     TREE_READONLY (decl) = 0;
@@ -4815,7 +4806,7 @@
 	  && !DECL_PRETTY_FUNCTION_P (decl)
 	  && !dependent_type_p (TREE_TYPE (decl)))
 	maybe_deduce_size_from_array_init (decl, init);
-      goto finish_end0;
+      goto finish_end;
     }
 
   /* Parameters are handled by store_parm_decls, not cp_finish_decl.  */
@@ -4918,6 +4909,9 @@
 	     the class specifier.  */
 	  if (!DECL_EXTERNAL (decl))
 	    var_definition_p = true;
+	  /* The variable is being defined, so determine its
+	     visibility.  */
+	  determine_visibility (decl);
 	}
       /* If the variable has an array type, lay out the type, even if
 	 there is no initializer.  It is valid to index through the
@@ -5003,26 +4997,6 @@
 	  if (var_definition_p && TREE_STATIC (decl))
 	    expand_static_init (decl, init); 
 	}
-    finish_end0:
-
-      /* Undo call to `pushclass' that was done in `start_decl'
-	 due to initialization of qualified member variable.
-	 I.e., Foo::x = 10;  */
-      {
-	tree context = CP_DECL_CONTEXT (decl);
-	if (context
-	    && TYPE_P (context)
-	    && (TREE_CODE (decl) == VAR_DECL
-		/* We also have a pushclass done that we need to undo here
-		   if we're at top level and declare a method.  */
-		|| TREE_CODE (decl) == FUNCTION_DECL)
-	    /* If size hasn't been set, we're still defining it,
-	       and therefore inside the class body; don't pop
-	       the binding level..  */
-	    && COMPLETE_TYPE_P (context)
-	    && context == current_class_type)
-	  pop_nested_class ();
-      }
     }
 
   /* If a CLEANUP_STMT was created to destroy a temporary bound to a
@@ -10244,6 +10218,9 @@
       && lookup_attribute ("noinline", attrs))
     warning ("%Jinline function '%D' given attribute noinline", decl1, decl1);
 
+  /* Determine the ELF visibility attribute for the function.  */
+  determine_visibility (decl1);
+
   if (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (decl1))
     /* This is a constructor, we must ensure that any default args
        introduced by this definition are propagated to the clones
diff -r -u -N gcc-3.4.6_orig/gcc/cp/decl2.c gcc-3.4.6/gcc/cp/decl2.c
--- gcc-3.4.6_orig/gcc/cp/decl2.c	2007-09-30 14:28:20.000000000 +0200
+++ gcc-3.4.6/gcc/cp/decl2.c	2007-09-30 14:32:55.000000000 +0200
@@ -1661,6 +1661,63 @@
   return true;
 }
 
+/* Determine the ELF symbol visibility for DECL.  */
+
+void
+determine_visibility (tree decl)
+{
+  tree class_type;
+
+  /* Cloned constructors and destructors get the same visibility as
+     the underlying function.  That should be set up in
+     maybe_clone_body.  */
+  if (DECL_CLONED_FUNCTION_P (decl))
+    return;
+
+  if (DECL_CLASS_SCOPE_P (decl))
+    class_type = DECL_CONTEXT (decl);
+  else if (TREE_CODE (decl) == VAR_DECL
+	   && DECL_TINFO_P (decl)
+	   && CLASS_TYPE_P (TREE_TYPE (DECL_NAME (decl))))
+    class_type = TREE_TYPE (DECL_NAME (decl));
+  else
+    {
+      /* Virtual tables have DECL_CONTEXT set to their associated class,
+	 so they are automatically handled above.  */
+      my_friendly_assert (!(TREE_CODE (decl) == VAR_DECL
+			    && DECL_VTABLE_OR_VTT_P (decl)), 20040803);
+      /* Entities not associated with any class just get the
+	 visibility specified by their attributes.  */
+      return;
+    }
+
+  /* By default, static data members and function members receive
+     the visibility of their containing class.  */
+  if (class_type
+      && (TREE_CODE (decl) == VAR_DECL 
+	  || TREE_CODE (decl) == FUNCTION_DECL)
+      && !lookup_attribute ("visibility", DECL_ATTRIBUTES (decl)))
+    {
+      if (TREE_CODE (decl) == FUNCTION_DECL
+	  && DECL_DECLARED_INLINE_P (decl)
+	  && visibility_options.inlines_hidden)
+	{
+	  /* Don't change it if it has been set explicitly by user.  */
+	  if (!DECL_VISIBILITY_SPECIFIED (decl))
+	    {
+	      DECL_VISIBILITY (decl) = VISIBILITY_HIDDEN;
+	      DECL_VISIBILITY_SPECIFIED (decl) = 1;
+	    }
+	}
+      else
+	{
+	  DECL_VISIBILITY (decl) = CLASSTYPE_VISIBILITY (class_type);
+	  DECL_VISIBILITY_SPECIFIED (decl)
+	    = CLASSTYPE_VISIBILITY_SPECIFIED (class_type);
+	}
+    }
+}
+
 /* Determines the proper settings of TREE_PUBLIC and DECL_EXTERNAL for an
    inline function or template instantiation at end-of-file.  */
 
diff -r -u -N gcc-3.4.6_orig/gcc/cp/init.c gcc-3.4.6/gcc/cp/init.c
--- gcc-3.4.6_orig/gcc/cp/init.c	2007-09-30 14:28:20.000000000 +0200
+++ gcc-3.4.6/gcc/cp/init.c	2007-09-30 14:37:24.000000000 +0200
@@ -341,8 +341,7 @@
 	  finish_expr_stmt (init);
 	}
     }
-  else if (TYPE_NEEDS_CONSTRUCTING (type)
-	   || (init && TYPE_HAS_CONSTRUCTOR (type)))
+  else if (TYPE_NEEDS_CONSTRUCTING (type))
     {
       if (explicit
 	  && TREE_CODE (type) == ARRAY_TYPE
@@ -1092,34 +1091,23 @@
 
   if (TREE_CODE (type) == ARRAY_TYPE)
     {
-      /* Must arrange to initialize each element of EXP
-	 from elements of INIT.  */
-      tree itype = init ? TREE_TYPE (init) : NULL_TREE;
-      
-      if (init && !itype)
+      /* An array may not be initialized use the parenthesized
+	 initialization form -- unless the initializer is "()".  */
+      if (init && TREE_CODE (init) == TREE_LIST)
 	{
-	  /* Handle bad initializers like:
-	     class COMPLEX {
-	     public:
-	       double re, im;
-	       COMPLEX(double r = 0.0, double i = 0.0) {re = r; im = i;};
-	       ~COMPLEX() {};
-	     };
-
-	     int main(int argc, char **argv) {
-	       COMPLEX zees(1.0, 0.0)[10];
-	     }
-	  */
 	  error ("bad array initializer");
 	  return error_mark_node;
 	}
+      /* Must arrange to initialize each element of EXP
+	 from elements of INIT.  */
+      tree itype = init ? TREE_TYPE (init) : NULL_TREE;
       if (cp_type_quals (type) != TYPE_UNQUALIFIED)
 	TREE_TYPE (exp) = TYPE_MAIN_VARIANT (type);
       if (itype && cp_type_quals (itype) != TYPE_UNQUALIFIED)
-	TREE_TYPE (init) = TYPE_MAIN_VARIANT (itype);
+	itype = TREE_TYPE (init) = TYPE_MAIN_VARIANT (itype);
       stmt_expr = build_vec_init (exp, NULL_TREE, init,
-				  init && same_type_p (TREE_TYPE (init),
-						       TREE_TYPE (exp)));
+				  itype && same_type_p (itype,
+							TREE_TYPE (exp)));
       TREE_READONLY (exp) = was_const;
       TREE_THIS_VOLATILE (exp) = was_volatile;
       TREE_TYPE (exp) = type;
@@ -1195,8 +1183,7 @@
 	   to run a new constructor; and catching an exception, where we
 	   have already built up the constructor call so we could wrap it
 	   in an exception region.  */;
-      else if (TREE_CODE (init) == CONSTRUCTOR 
-	       && TREE_HAS_CONSTRUCTOR (init))
+      else if (BRACE_ENCLOSED_INITIALIZER_P (init))
 	{
 	  /* A brace-enclosed initializer for an aggregate.  */
 	  my_friendly_assert (CP_AGGREGATE_TYPE_P (type), 20021016);
diff -r -u -N gcc-3.4.6_orig/gcc/cp/method.c gcc-3.4.6/gcc/cp/method.c
--- gcc-3.4.6_orig/gcc/cp/method.c	2007-09-30 14:28:19.000000000 +0200
+++ gcc-3.4.6/gcc/cp/method.c	2007-09-30 14:32:40.000000000 +0200
@@ -410,6 +410,8 @@
      rewrite.  */
   TREE_PUBLIC (thunk_fndecl) = TREE_PUBLIC (function);
   DECL_VISIBILITY (thunk_fndecl) = DECL_VISIBILITY (function);
+  DECL_VISIBILITY_SPECIFIED (thunk_fndecl)
+    = DECL_VISIBILITY_SPECIFIED (function);
 
   if (flag_syntax_only)
     {
diff -r -u -N gcc-3.4.6_orig/gcc/cp/optimize.c gcc-3.4.6/gcc/cp/optimize.c
--- gcc-3.4.6_orig/gcc/cp/optimize.c	2007-09-30 14:28:19.000000000 +0200
+++ gcc-3.4.6/gcc/cp/optimize.c	2007-09-30 14:32:22.000000000 +0200
@@ -155,6 +155,7 @@
       DECL_NOT_REALLY_EXTERN (clone) = DECL_NOT_REALLY_EXTERN (fn);
       TREE_PUBLIC (clone) = TREE_PUBLIC (fn);
       DECL_VISIBILITY (clone) = DECL_VISIBILITY (fn);
+      DECL_VISIBILITY_SPECIFIED (clone) = DECL_VISIBILITY_SPECIFIED (fn);
 
       /* Adjust the parameter names and locations.  */
       parm = DECL_ARGUMENTS (fn);
diff -r -u -N gcc-3.4.6_orig/gcc/cp/parser.c gcc-3.4.6/gcc/cp/parser.c
--- gcc-3.4.6_orig/gcc/cp/parser.c	2007-09-30 14:28:21.000000000 +0200
+++ gcc-3.4.6/gcc/cp/parser.c	2007-09-30 14:37:24.000000000 +0200
@@ -5855,10 +5855,13 @@
 	 for sure.  */
       if (cp_parser_parse_definitely (parser))
 	{
+	  bool pop_p;
+
 	  /* Create the declaration.  */
 	  decl = start_decl (declarator, type_specifiers, 
 			     /*initialized_p=*/true,
-			     attributes, /*prefix_attributes=*/NULL_TREE);
+			     attributes, /*prefix_attributes=*/NULL_TREE,
+			     &pop_p);
 	  /* Parse the assignment-expression.  */
 	  initializer = cp_parser_assignment_expression (parser);
 	  
@@ -5867,7 +5870,9 @@
 			  initializer, 
 			  asm_specification, 
 			  LOOKUP_ONLYCONVERTING);
-	  
+	  if (pop_p)
+	    pop_scope (DECL_CONTEXT (decl));
+
 	  return convert_from_reference (decl);
 	}
     }
@@ -10105,12 +10110,12 @@
 	  have_extern_spec = false;
 	}
       decl = start_decl (declarator, decl_specifiers,
-			 is_initialized, attributes, prefix_attributes);
+			 is_initialized, attributes, prefix_attributes,
+			 &pop_p);
     }
-
-  /* Enter the SCOPE.  That way unqualified names appearing in the
-     initializer will be looked up in SCOPE.  */
-  if (scope)
+  else if (scope)
+    /* Enter the SCOPE.  That way unqualified names appearing in the
+       initializer will be looked up in SCOPE.  */
     pop_p = push_scope (scope);
 
   /* Perform deferred access control checks, now that we know in which
@@ -10157,17 +10162,13 @@
     if (cp_parser_attributes_opt (parser))
       warning ("attributes after parenthesized initializer ignored");
 
-  /* Leave the SCOPE, now that we have processed the initializer.  It
-     is important to do this before calling cp_finish_decl because it
-     makes decisions about whether to create DECL_STMTs or not based
-     on the current scope.  */
-  if (pop_p)
-    pop_scope (scope);
-
   /* For an in-class declaration, use `grokfield' to create the
      declaration.  */
   if (member_p)
     {
+      if (pop_p)
+	pop_scope (scope);
+
       decl = grokfield (declarator, decl_specifiers,
 			initializer, /*asmspec=*/NULL_TREE,
 			/*attributes=*/NULL_TREE);
@@ -10178,15 +10179,19 @@
   /* Finish processing the declaration.  But, skip friend
      declarations.  */
   if (!friend_p && decl)
-    cp_finish_decl (decl, 
-		    initializer, 
-		    asm_specification,
-		    /* If the initializer is in parentheses, then this is
-		       a direct-initialization, which means that an
-		       `explicit' constructor is OK.  Otherwise, an
-		       `explicit' constructor cannot be used.  */
-		    ((is_parenthesized_init || !is_initialized)
-		     ? 0 : LOOKUP_ONLYCONVERTING));
+    {
+      cp_finish_decl (decl, 
+		      initializer, 
+		      asm_specification,
+		      /* If the initializer is in parentheses, then this is
+			 a direct-initialization, which means that an
+			 `explicit' constructor is OK.  Otherwise, an
+			 `explicit' constructor cannot be used.  */
+		      ((is_parenthesized_init || !is_initialized)
+		       ? 0 : LOOKUP_ONLYCONVERTING));
+      if (pop_p)
+	pop_scope (DECL_CONTEXT (decl));
+    }
 
   /* Remember whether or not variables were initialized by
      constant-expressions.  */
@@ -11610,10 +11615,6 @@
       cp_lexer_consume_token (parser->lexer);
       /* Create a CONSTRUCTOR to represent the braced-initializer.  */
       initializer = make_node (CONSTRUCTOR);
-      /* Mark it with TREE_HAS_CONSTRUCTOR.  This should not be
-	 necessary, but check_initializer depends upon it, for 
-	 now.  */
-      TREE_HAS_CONSTRUCTOR (initializer) = 1;
       /* If it's not a `}', then there is a non-trivial initializer.  */
       if (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_BRACE))
 	{
diff -r -u -N gcc-3.4.6_orig/gcc/cp/pt.c gcc-3.4.6/gcc/cp/pt.c
--- gcc-3.4.6_orig/gcc/cp/pt.c	2007-09-30 14:28:19.000000000 +0200
+++ gcc-3.4.6/gcc/cp/pt.c	2007-09-30 14:32:40.000000000 +0200
@@ -11297,20 +11297,13 @@
 	}
       else
 	{
-	  /* This is done in analogous to `start_decl'.  It is
-	     required for correct access checking.  */
+	  /* Enter the scope of D so that access-checking works correctly.  */
 	  push_nested_class (DECL_CONTEXT (d));
 	  cp_finish_decl (d, 
 			  (!DECL_INITIALIZED_IN_CLASS_P (d) 
 			   ? DECL_INITIAL (d) : NULL_TREE),
 			  NULL_TREE, 0);
-	  /* Normally, pop_nested_class is called by cp_finish_decl
-	     above.  But when instantiate_decl is triggered during
-	     instantiate_class_template processing, its DECL_CONTEXT
-	     is still not completed yet, and pop_nested_class isn't
-	     called.  */
-	  if (!COMPLETE_TYPE_P (DECL_CONTEXT (d)))
-	    pop_nested_class ();
+	  pop_nested_class ();
 	}
       /* We're not deferring instantiation any more.  */
       TI_PENDING_TEMPLATE_FLAG (DECL_TEMPLATE_INFO (d)) = 0;
diff -r -u -N gcc-3.4.6_orig/gcc/cp/rtti.c gcc-3.4.6/gcc/cp/rtti.c
--- gcc-3.4.6_orig/gcc/cp/rtti.c	2007-09-30 14:28:20.000000000 +0200
+++ gcc-3.4.6/gcc/cp/rtti.c	2007-09-30 14:37:24.000000000 +0200
@@ -354,17 +354,16 @@
       TREE_READONLY (d) = 1;
       TREE_STATIC (d) = 1;
       DECL_EXTERNAL (d) = 1;
+      DECL_TINFO_P (d) = 1;
       DECL_COMDAT (d) = 1;
       TREE_PUBLIC (d) = 1;
       SET_DECL_ASSEMBLER_NAME (d, name);
-
-      pushdecl_top_level_and_finish (d, NULL_TREE);
-
+      /* Remember the type it is for.  */
+      TREE_TYPE (name) = type;
       if (CLASS_TYPE_P (type))
 	CLASSTYPE_TYPEINFO_VAR (TYPE_MAIN_VARIANT (type)) = d;
 
-      /* Remember the type it is for.  */
-      TREE_TYPE (name) = type;
+      pushdecl_top_level_and_finish (d, NULL_TREE);
 
       /* Add decl to the global array of tinfo decls.  */
       my_friendly_assert (unemitted_tinfo_decls != 0, 20030312);
@@ -751,19 +750,20 @@
                      NULL_TREE);
     tree name_string = tinfo_name (target);
 
+    /* Determine the name of the variable -- and remember with which
+       type it is associated.  */
     name_name = mangle_typeinfo_string_for_type (target);
+    TREE_TYPE (name_name) = target;
+
     name_decl = build_lang_decl (VAR_DECL, name_name, name_type);
-    
+    SET_DECL_ASSEMBLER_NAME (name_decl, name_name);
     DECL_ARTIFICIAL (name_decl) = 1;
     TREE_READONLY (name_decl) = 1;
     TREE_STATIC (name_decl) = 1;
     DECL_EXTERNAL (name_decl) = 0;
+    DECL_TINFO_P (name_decl) = 1;
     TREE_PUBLIC (name_decl) = 1;
     import_export_tinfo (name_decl, target, typeinfo_in_lib_p (target));
-    /* External name of the string containing the type's name has a
-       special name.  */
-    SET_DECL_ASSEMBLER_NAME (name_decl,
-			     mangle_typeinfo_string_for_type (target));
     DECL_INITIAL (name_decl) = name_string;
     mark_used (name_decl);
     pushdecl_top_level_and_finish (name_decl, name_string);
@@ -807,7 +807,7 @@
   init = tree_cons (NULL_TREE, decay_conversion (name_decl), init);
   
   init = build_constructor (NULL_TREE, nreverse (init));
-  TREE_HAS_CONSTRUCTOR (init) = TREE_CONSTANT (init) = TREE_STATIC (init) = 1;
+  TREE_CONSTANT (init) = TREE_STATIC (init) = 1;
   init = tree_cons (NULL_TREE, init, NULL_TREE);
   
   return init;
@@ -823,7 +823,7 @@
   tree init = tinfo_base_init (desc, target);
   
   init = build_constructor (NULL_TREE, init);
-  TREE_HAS_CONSTRUCTOR (init) = TREE_CONSTANT (init) = TREE_STATIC (init) = 1;
+  TREE_CONSTANT (init) = TREE_STATIC (init) = 1;
   return init;
 }
 
@@ -850,7 +850,7 @@
                     init);
   
   init = build_constructor (NULL_TREE, nreverse (init));
-  TREE_HAS_CONSTRUCTOR (init) = TREE_CONSTANT (init) = TREE_STATIC (init) = 1;
+  TREE_CONSTANT (init) = TREE_STATIC (init) = 1;
   return init;
 }
 
@@ -887,7 +887,7 @@
 		    init);  
   
   init = build_constructor (NULL_TREE, nreverse (init));
-  TREE_HAS_CONSTRUCTOR (init) = TREE_CONSTANT (init) = TREE_STATIC (init) = 1;
+  TREE_CONSTANT (init) = TREE_STATIC (init) = 1;
   return init;  
 }
 
@@ -955,7 +955,7 @@
   
   TREE_CHAIN (init) = trail;
   init = build_constructor (NULL_TREE, init);
-  TREE_HAS_CONSTRUCTOR (init) = TREE_CONSTANT (init) = TREE_STATIC (init) = 1;
+  TREE_CONSTANT (init) = TREE_STATIC (init) = 1;
   return init;  
 }
 
@@ -1072,11 +1072,9 @@
               base_init = tree_cons (NULL_TREE, offset, base_init);
               base_init = tree_cons (NULL_TREE, tinfo, base_init);
               base_init = build_constructor (NULL_TREE, base_init);
-	      TREE_HAS_CONSTRUCTOR (base_init) = 1;
               base_inits = tree_cons (NULL_TREE, base_init, base_inits);
             }
 	  base_inits = build_constructor (NULL_TREE, base_inits);
-	  TREE_HAS_CONSTRUCTOR (base_inits) = 1;
 	  base_inits = tree_cons (NULL_TREE, base_inits, NULL_TREE);
 	  /* Prepend the number of bases.  */
 	  base_inits = tree_cons (NULL_TREE,
diff -r -u -N gcc-3.4.6_orig/gcc/cp/typeck2.c gcc-3.4.6/gcc/cp/typeck2.c
--- gcc-3.4.6_orig/gcc/cp/typeck2.c	2007-09-30 14:28:19.000000000 +0200
+++ gcc-3.4.6/gcc/cp/typeck2.c	2007-09-30 14:37:24.000000000 +0200
@@ -479,8 +479,6 @@
   enum tree_code code = TREE_CODE (type);
   tree element = NULL_TREE;
   tree old_tail_contents = NULL_TREE;
-  /* Nonzero if INIT is a braced grouping.  */
-  int raw_constructor;
 
   /* By default, assume we use one element from a list.
      We correct this later in the sole case where it is not true.  */
@@ -510,10 +508,7 @@
   if (TREE_CODE (init) == NON_LVALUE_EXPR)
     init = TREE_OPERAND (init, 0);
 
-  raw_constructor = (TREE_CODE (init) == CONSTRUCTOR 
-		     && TREE_HAS_CONSTRUCTOR (init));
-
-  if (raw_constructor
+  if (BRACE_ENCLOSED_INITIALIZER_P (init)
       && CONSTRUCTOR_ELTS (init) != 0
       && TREE_CHAIN (CONSTRUCTOR_ELTS (init)) == 0)
     {
@@ -585,7 +580,7 @@
       || code == BOOLEAN_TYPE || code == COMPLEX_TYPE
       || TYPE_PTR_TO_MEMBER_P (type))
     {
-      if (raw_constructor)
+      if (BRACE_ENCLOSED_INITIALIZER_P (init))
 	{
 	  if (element == 0)
 	    {
@@ -594,7 +589,7 @@
 	    }
 	  init = element;
 	}
-      while (TREE_CODE (init) == CONSTRUCTOR && TREE_HAS_CONSTRUCTOR (init))
+      while (BRACE_ENCLOSED_INITIALIZER_P (init))
 	{
 	  pedwarn ("braces around scalar initializer for `%T'", type);
 	  init = CONSTRUCTOR_ELTS (init);
@@ -618,15 +613,16 @@
 
   if (code == ARRAY_TYPE || code == VECTOR_TYPE || IS_AGGR_TYPE_CODE (code))
     {
-      if (raw_constructor && TYPE_NON_AGGREGATE_CLASS (type)
-	  && TREE_HAS_CONSTRUCTOR (init))
+      if (BRACE_ENCLOSED_INITIALIZER_P (init))
 	{
-	  error ("subobject of type `%T' must be initialized by constructor, not by `%E'",
-		    type, init);
-	  return error_mark_node;
+	  if (TYPE_NON_AGGREGATE_CLASS (type))
+	    {
+	      error ("subobject of type `%T' must be initialized by constructor, not by `%E'",
+		     type, init);
+	      return error_mark_node;
+	    }
+	  return process_init_constructor (type, init, (tree *)0);
 	}
-      else if (raw_constructor)
-	return process_init_constructor (type, init, (tree *)0);
       else if (can_convert_arg (type, TREE_TYPE (init), init)
 	       || TYPE_NON_AGGREGATE_CLASS (type))
 	/* These are never initialized from multiple constructor elements.  */;
@@ -868,7 +864,7 @@
 
 	      /* Warn when some struct elements are implicitly initialized.  */
 	      if (extra_warnings
-	          && (!init || TREE_HAS_CONSTRUCTOR (init)))
+	          && (!init || BRACE_ENCLOSED_INITIALIZER_P (init)))
 		warning ("missing initializer for member `%D'", field);
 	    }
 	  else
@@ -884,7 +880,7 @@
 	      /* Warn when some struct elements are implicitly initialized
 		 to zero.  */
 	      if (extra_warnings
-	          && (!init || TREE_HAS_CONSTRUCTOR (init)))
+	          && (!init || BRACE_ENCLOSED_INITIALIZER_P (init)))
 		warning ("missing initializer for member `%D'", field);
 
 	      if (! zero_init_p (TREE_TYPE (field)))
diff -r -u -N gcc-3.4.6_orig/gcc/cppfiles.c gcc-3.4.6/gcc/cppfiles.c
--- gcc-3.4.6_orig/gcc/cppfiles.c	2007-09-30 14:28:12.000000000 +0200
+++ gcc-3.4.6/gcc/cppfiles.c	2007-09-30 14:36:37.000000000 +0200
@@ -339,8 +339,17 @@
 
   if (file->err_no != ENOENT)
     {
-      open_file_failed (pfile, file, 0);
-      return true;
+      if (file->err_no == EACCES)
+        {
+          /* make EACCES non-fatal to fix bug ?? (glibc 2.3.3 on reiser4) */
+          cpp_errno (pfile, CPP_DL_WARNING, file->path);
+          return false;
+        }
+      else
+        {
+          open_file_failed (pfile, file, 0);
+          return true;
+        }
     }
 
   free (path);
diff -r -u -N gcc-3.4.6_orig/gcc/diagnostic.c gcc-3.4.6/gcc/diagnostic.c
--- gcc-3.4.6_orig/gcc/diagnostic.c	2007-09-30 14:28:19.000000000 +0200
+++ gcc-3.4.6/gcc/diagnostic.c	2007-09-30 14:31:16.000000000 +0200
@@ -272,14 +272,14 @@
 	real_abort ();
 
       fnotice (stderr, bug_report_request, bug_report_url);
-      exit (FATAL_EXIT_CODE);
+      exit (ICE_EXIT_CODE);
 
     case DK_FATAL:
       if (context->abort_on_error)
 	real_abort ();
 
       fnotice (stderr, "compilation terminated.\n");
-      exit (FATAL_EXIT_CODE);
+      exit (ICE_EXIT_CODE);
 
     default:
       real_abort ();
@@ -571,7 +571,7 @@
   fnotice (stderr,
 	   "Internal compiler error: Error reporting routines re-entered.\n");
   fnotice (stderr, bug_report_request, bug_report_url);
-  exit (FATAL_EXIT_CODE);
+  exit (ICE_EXIT_CODE);
 }
 
 /* Report an internal compiler error in a friendly manner.  This is
diff -r -u -N gcc-3.4.6_orig/gcc/doc/invoke.texi gcc-3.4.6/gcc/doc/invoke.texi
--- gcc-3.4.6_orig/gcc/doc/invoke.texi	2007-09-30 14:28:11.000000000 +0200
+++ gcc-3.4.6/gcc/doc/invoke.texi	2007-09-30 14:32:23.000000000 +0200
@@ -183,7 +183,8 @@
 -fno-optional-diags  -fpermissive @gol
 -frepo  -fno-rtti  -fstats  -ftemplate-depth-@var{n} @gol
 -fuse-cxa-atexit  -fno-weak  -nostdinc++ @gol
--fno-default-inline  -Wabi  -Wctor-dtor-privacy @gol
+-fno-default-inline  -fvisibility-inlines-hidden @gol
+-Wabi  -Wctor-dtor-privacy @gol
 -Wnon-virtual-dtor  -Wreorder @gol
 -Weffc++  -Wno-deprecated @gol
 -Wno-non-template-friend  -Wold-style-cast @gol
@@ -678,7 +679,8 @@
 -fargument-alias  -fargument-noalias @gol
 -fargument-noalias-global  -fleading-underscore @gol
 -ftls-model=@var{model} @gol
--ftrapv  -fwrapv  -fbounds-check}
+-ftrapv  -fwrapv  -fbounds-check @gol
+-fvisibility}
 @end table
 
 @menu
@@ -1437,6 +1439,20 @@
 destructors, but will only work if your C library supports
 @code{__cxa_atexit}.
 
+@item -fvisibility-inlines-hidden
+@opindex fvisibility-inlines-hidden
+Causes all inlined methods to be marked with
+@code{__attribute__ ((visibility ("hidden")))} so that they do not
+appear in the export table of a DSO and do not require a PLT indirection
+when used within the DSO. Enabling this option can have a dramatic effect
+on load and link times of a DSO as it massively reduces the size of the
+dynamic export table when the library makes heavy use of templates. While
+it can cause bloating through duplication of code within each DSO where
+it is used, often the wastage is less than the considerable space occupied
+by a long symbol name in the export table which is typical when using
+templates and namespaces. For even more savings, combine with the
+@code{-fvisibility=hidden} switch.
+
 @item -fno-weak
 @opindex fno-weak
 Do not use weak symbol support, even if it is provided by the linker.
@@ -11284,6 +11300,54 @@
 
 The default without @option{-fpic} is @code{initial-exec}; with
 @option{-fpic} the default is @code{global-dynamic}.
+
+@item -fvisibility=@var{default|internal|hidden|protected}
+@opindex fvisibility
+Set the default ELF image symbol visibility to the specified option - all
+symbols will be marked with this unless overrided within the code.
+Using this feature can very substantially improve linking and
+load times of shared object libraries, produce more optimised
+code, provide near-perfect API export and prevent symbol clashes.
+It is @strong{strongly} recommended that you use this in any shared objects
+you distribute.
+     
+Despite the nomenclature, @code{default} always means public ie;
+available to be linked against from outside the shared object.
+@code{protected} and @code{internal} are pretty useless in real-world
+usage so the only other commonly used option will be @code{hidden}.
+The default if -fvisibility isn't specified is @code{default} ie; make every
+symbol public - this causes the same behaviour as previous versions of
+GCC.
+     
+A good explanation of the benefits offered by ensuring ELF
+symbols have the correct visibility is given by ``How To Write
+Shared Libraries'' by Ulrich Drepper (which can be found at
+@w{@uref{http://people.redhat.com/~drepper/}}) - however a superior
+solution made possible by this option to marking things hidden when
+the default is public is to make the default hidden and mark things
+public. This is the norm with DLL's on Windows and with @option{-fvisibility=hidden}
+and @code{__attribute__ ((visibility("default")))} instead of
+@code{__declspec(dllexport)} you get almost identical semantics with
+identical syntax. This is a great boon to those working with
+cross-platform projects.
+
+For those adding visibility support to existing code, you may find
+@samp{#pragma GCC visibility} of use. This works by you enclosing
+the declarations you wish to set visibility for with (for example)
+@samp{#pragma GCC visibility push(hidden)} and
+@samp{#pragma GCC visibility pop}. These can be nested up to sixteen
+times. Bear in mind that symbol visibility should be viewed @strong{as
+part of the API interface contract} and thus all new code should
+always specify visibility when it is not the default ie; declarations
+only for use within the local DSO should @strong{always} be marked explicitly
+as hidden as so to avoid PLT indirection overheads - making this
+abundantly clear also aids readability and self-documentation of the code.
+Note that due to ISO C++ specification requirements, operator new and
+operator delete must always be of default visibility.
+
+An overview of these techniques, their benefits and how to use them
+is at @w{@uref{http://www.nedprod.com/programs/gccvisibility.html}}.
+
 @end table
 
 @c man end
diff -r -u -N gcc-3.4.6_orig/gcc/final.c gcc-3.4.6/gcc/final.c
--- gcc-3.4.6_orig/gcc/final.c	2007-09-30 14:28:07.000000000 +0200
+++ gcc-3.4.6/gcc/final.c	2007-09-30 14:34:07.000000000 +0200
@@ -1881,7 +1881,7 @@
 		{
 		  int log_align;
 
-		  readonly_data_section ();
+		  function_readonly_data_section (current_function_decl);
 
 #ifdef ADDR_VEC_ALIGN
 		  log_align = ADDR_VEC_ALIGN (NEXT_INSN (insn));
diff -r -u -N gcc-3.4.6_orig/gcc/flags.h gcc-3.4.6/gcc/flags.h
--- gcc-3.4.6_orig/gcc/flags.h	2007-09-30 14:28:18.000000000 +0200
+++ gcc-3.4.6/gcc/flags.h	2007-09-30 14:32:22.000000000 +0200
@@ -60,6 +60,30 @@
 /* Nonzero means emit debugging information only for symbols which are used.  */
 extern int flag_debug_only_used_symbols;
 
+/* Enumerate visibility settings.  */
+#ifndef SYMBOL_VISIBILITY_DEFINED
+#define SYMBOL_VISIBILITY_DEFINED
+enum symbol_visibility
+{
+  VISIBILITY_DEFAULT,
+  VISIBILITY_INTERNAL,
+  VISIBILITY_HIDDEN,
+  VISIBILITY_PROTECTED
+};
+#endif
+
+/* The default visibility for all symbols (unless overridden).  */
+extern enum symbol_visibility default_visibility;
+
+struct visibility_flags
+{
+  unsigned inpragma : 1;	/* True when in #pragma GCC visibility.  */
+  unsigned inlines_hidden : 1;	/* True when -finlineshidden in effect.  */
+};
+
+/* Global visibility options.  */
+extern struct visibility_flags visibility_options;
+
 /* Nonzero means do optimizations.  -opt.  */
 
 extern int optimize;
@@ -771,4 +795,8 @@
 #define HONOR_SIGN_DEPENDENT_ROUNDING(MODE) \
   (MODE_HAS_SIGN_DEPENDENT_ROUNDING (MODE) && flag_rounding_math)
 
+/* Warn whenever a trampoline is generated. */
+
+extern bool warn_trampolines;
+
 #endif /* ! GCC_FLAGS_H */
diff -r -u -N gcc-3.4.6_orig/gcc/flow.c gcc-3.4.6/gcc/flow.c
--- gcc-3.4.6_orig/gcc/flow.c	2007-09-30 14:28:09.000000000 +0200
+++ gcc-3.4.6/gcc/flow.c	2007-09-30 14:33:19.000000000 +0200
@@ -1884,6 +1884,7 @@
 	  rtx set_src = SET_SRC (pc_set (BB_END (bb)));
 	  rtx cond_true = XEXP (set_src, 0);
 	  rtx reg = XEXP (cond_true, 0);
+ 	  enum rtx_code inv_cond;
 
 	  if (GET_CODE (reg) == SUBREG)
 	    reg = SUBREG_REG (reg);
@@ -1892,11 +1893,13 @@
 	     in the form of a comparison of a register against zero.  
 	     If the condition is more complex than that, then it is safe
 	     not to record any information.  */
-	  if (GET_CODE (reg) == REG
+ 	  inv_cond = reversed_comparison_code (cond_true, BB_END (bb));
+ 	  if (inv_cond != UNKNOWN
+	      && GET_CODE (reg) == REG
 	      && XEXP (cond_true, 1) == const0_rtx)
 	    {
 	      rtx cond_false
-		= gen_rtx_fmt_ee (reverse_condition (GET_CODE (cond_true)),
+		= gen_rtx_fmt_ee (inv_cond,
 				  GET_MODE (cond_true), XEXP (cond_true, 0),
 				  XEXP (cond_true, 1));
 	      if (GET_CODE (XEXP (set_src, 1)) == PC)
diff -r -u -N gcc-3.4.6_orig/gcc/function.c gcc-3.4.6/gcc/function.c
--- gcc-3.4.6_orig/gcc/function.c	2007-09-30 14:28:12.000000000 +0200
+++ gcc-3.4.6/gcc/function.c	2007-09-30 14:30:34.000000000 +0200
@@ -135,6 +135,9 @@
 /* Nonzero if at least one trampoline has been created.  */
 int trampolines_created;
 
+/* Warn when a trampoline is generated. */
+bool warn_trampolines = 1;
+
 /* Assign unique numbers to labels generated for profiling, debugging, etc.  */
 static GTY(()) int funcdef_no;
 
@@ -7014,6 +7017,9 @@
 
       /* Put those insns at entry to the containing function (this one).  */
       emit_insn_before (seq, tail_recursion_reentry);
+
+      if (warn_trampolines)
+	warning ("generating trampoline in object (requires executable stack)");
     }
 
   /* If we are doing stack checking and this function makes calls,
diff -r -u -N gcc-3.4.6_orig/gcc/gcc.c gcc-3.4.6/gcc/gcc.c
--- gcc-3.4.6_orig/gcc/gcc.c	2007-09-30 14:28:18.000000000 +0200
+++ gcc-3.4.6/gcc/gcc.c	2007-09-30 14:31:16.000000000 +0200
@@ -354,6 +354,9 @@
 #if defined(HAVE_TARGET_OBJECT_SUFFIX) || defined(HAVE_TARGET_EXECUTABLE_SUFFIX)
 static const char *convert_filename (const char *, int, int);
 #endif
+#if !(defined (__MSDOS__) || defined (OS2) || defined (VMS))
+static void retry_ice (const char *prog, const char **argv);
+#endif
 
 static const char *if_exists_spec_function (int, const char **);
 static const char *if_exists_else_spec_function (int, const char **);
@@ -2770,7 +2773,7 @@
       if (commands[i].pid == -1)
 	pfatal_pexecute (errmsg_fmt, errmsg_arg);
 
-      if (string != commands[i].prog)
+      if (i && string != commands[i].prog)
 	free ((void *) string);
     }
 
@@ -2848,6 +2851,17 @@
 	      else if (WIFEXITED (status)
 		       && WEXITSTATUS (status) >= MIN_FATAL_STATUS)
 		{
+#if !(defined (__MSDOS__) || defined (OS2) || defined (VMS))
+		  /* For ICEs in cc1, cc1obj, cc1plus see if it is
+		     reproducible or not.  */
+		  char *p;
+		  if (WEXITSTATUS (status) == ICE_EXIT_CODE
+		      && j == 0
+		      && (p = strrchr (commands[j].argv[0], DIR_SEPARATOR))
+		      && ! strncmp (p + 1, "cc1", 3))
+		    retry_ice (commands[j].prog, commands[j].argv);
+#endif
+
 		  if (WEXITSTATUS (status) > greatest_status)
 		    greatest_status = WEXITSTATUS (status);
 		  ret_code = -1;
@@ -2859,6 +2873,10 @@
 	      break;
 	    }
       }
+
+    if (commands[0].argv[0] != commands[0].prog)
+      free ((PTR) commands[0].argv[0]);
+
     return ret_code;
   }
 }
@@ -3101,6 +3119,8 @@
   int have_c = 0;
   int have_o = 0;
   int lang_n_infiles = 0;
+  int m64 = 0;
+  int used_B = 0;
 #ifdef MODIFY_TARGET_NAME
   int is_modify_target_name;
   int j;
@@ -3619,6 +3639,7 @@
 			    PREFIX_PRIORITY_B_OPT, 0, &warn_B, 0);
 		add_prefix (&include_prefixes, concat (value, "include", NULL),
 			    NULL, PREFIX_PRIORITY_B_OPT, 0, NULL, 0);
+		used_B = 1;
 		n_switches++;
 	      }
 	      break;
@@ -3681,6 +3702,13 @@
 #endif
 	      goto normal_switch;
 
+	    /* HACK START */
+	    case 'm':
+	      if (p[1] == '6' && p[2] == '4')
+		m64 = 1;
+	    /* FALLTHROUGH */
+	    /* HACK END */
+
 	    default:
 	    normal_switch:
 
@@ -3758,6 +3786,26 @@
   /* Use 2 as fourth arg meaning try just the machine as a suffix,
      as well as trying the machine and the version.  */
 #ifndef OS2
+  /* HACK START */
+  if (!m64 && !used_B && !strncmp (spec_machine, "sparc64-", 8))
+    {
+      const char *sparc32_exec_prefix =
+	concat (standard_libexec_prefix, "sparc-", spec_machine + 8,
+		dir_separator_str, spec_version, dir_separator_str, NULL);
+      add_prefix (&exec_prefixes, sparc32_exec_prefix, "GCC",
+		  PREFIX_PRIORITY_LAST, 0, warn_std_ptr, 0);
+    }
+  /* HACK END */
+  /* HACK START */
+  if (!m64 && !used_B && !strncmp (spec_machine, "ppc64-", 6))
+    {
+      const char *ppc32_exec_prefix =
+	concat (standard_libexec_prefix, "ppc-", spec_machine + 6,
+		dir_separator_str, spec_version, dir_separator_str, NULL);
+      add_prefix (&exec_prefixes, ppc32_exec_prefix, "GCC",
+		  PREFIX_PRIORITY_LAST, 0, warn_std_ptr, 0);
+    }
+  /* HACK END */
   add_prefix (&exec_prefixes, standard_libexec_prefix, "GCC",
 	      PREFIX_PRIORITY_LAST, 1, warn_std_ptr, 0);
   add_prefix (&exec_prefixes, standard_libexec_prefix, "BINUTILS",
@@ -5802,6 +5850,224 @@
   switches[switchnum].validated = 1;
 }
 
+#if !(defined (__MSDOS__) || defined (OS2) || defined (VMS))
+#define RETRY_ICE_ATTEMPTS 2
+
+static void
+retry_ice (const char *prog, const char **argv)
+{
+  int nargs, out_arg = -1, quiet = 0, attempt;
+  int pid, retries, sleep_interval;
+  const char **new_argv;
+  char *temp_filenames[RETRY_ICE_ATTEMPTS * 2 + 2];
+
+  if (input_filename == NULL || ! strcmp (input_filename, "-"))
+    return;
+
+  for (nargs = 0; argv[nargs] != NULL; ++nargs)
+    /* Only retry compiler ICEs, not preprocessor ones.  */
+    if (! strcmp (argv[nargs], "-E"))
+      return;
+    else if (argv[nargs][0] == '-' && argv[nargs][1] == 'o')
+      {
+	if (out_arg == -1)
+	  out_arg = nargs;
+	else
+	  return;
+      }
+    /* If the compiler is going to output any time information,
+       it might varry between invocations.  */
+    else if (! strcmp (argv[nargs], "-quiet"))
+      quiet = 1;
+    else if (! strcmp (argv[nargs], "-ftime-report"))
+      return;
+
+  if (out_arg == -1 || !quiet)
+    return;
+
+  memset (temp_filenames, '\0', sizeof (temp_filenames));
+  new_argv = alloca ((nargs + 3) * sizeof (const char *));
+  memcpy (new_argv, argv, (nargs + 1) * sizeof (const char *));
+  new_argv[nargs++] = "-frandom-seed=0";
+  new_argv[nargs] = NULL;
+  if (new_argv[out_arg][2] == '\0')
+    new_argv[out_arg + 1] = "-";
+  else
+    new_argv[out_arg] = "-o-";
+
+  for (attempt = 0; attempt < RETRY_ICE_ATTEMPTS + 1; ++attempt)
+    {
+      int fd;
+      int status;
+
+      temp_filenames[attempt * 2] = make_temp_file (".out");
+      temp_filenames[attempt * 2 + 1] = make_temp_file (".err");
+
+      if (attempt == RETRY_ICE_ATTEMPTS)
+        {
+	  int i;
+	  int fd1, fd2;
+	  struct stat st1, st2;
+	  size_t n, len;
+	  char *buf;
+
+	  buf = xmalloc (8192);
+
+	  for (i = 0; i < 2; ++i)
+	    {
+	      fd1 = open (temp_filenames[i], O_RDONLY);
+	      fd2 = open (temp_filenames[2 + i], O_RDONLY);
+
+	      if (fd1 < 0 || fd2 < 0)
+		{
+		  i = -1;
+		  close (fd1);
+		  close (fd2);
+		  break;
+		}
+
+	      if (fstat (fd1, &st1) < 0 || fstat (fd2, &st2) < 0)
+		{
+		  i = -1;
+		  close (fd1);
+		  close (fd2);
+		  break;
+		}
+
+	      if (st1.st_size != st2.st_size)
+		{
+		  close (fd1);
+		  close (fd2);
+		  break;
+		}
+
+	      len = 0;
+	      for (n = st1.st_size; n; n -= len)
+		{
+		  len = n;
+		  if (len > 4096)
+		    len = 4096;
+
+		  if (read (fd1, buf, len) != (int) len
+		      || read (fd2, buf + 4096, len) != (int) len)
+		    {
+		      i = -1;
+		      break;
+		    }
+
+		  if (memcmp (buf, buf + 4096, len) != 0)
+		    break;
+		}
+
+	      close (fd1);
+	      close (fd2);
+
+	      if (n)
+		break;
+	    }
+
+	  free (buf);
+	  if (i == -1)
+	    break;
+
+	  if (i != 2)
+	    {
+	      notice ("The bug is not reproducible, so it is likely a hardware or OS problem.\n");
+	      break;
+	    }
+
+          fd = open (temp_filenames[attempt * 2], O_RDWR);
+	  if (fd < 0)
+	    break;
+	  write (fd, "//", 2);
+	  for (i = 0; i < nargs; i++)
+	    {
+	      write (fd, " ", 1);
+	      write (fd, new_argv[i], strlen (new_argv[i]));
+	    }
+	  write (fd, "\n", 1);
+	  new_argv[nargs] = "-E";
+	  new_argv[nargs + 1] = NULL;
+        }
+
+      /* Fork a subprocess; wait and retry if it fails.  */
+      sleep_interval = 1;
+      pid = -1;
+      for (retries = 0; retries < 4; retries++)
+	{
+	  pid = fork ();
+	  if (pid >= 0)
+	    break;
+	  sleep (sleep_interval);
+	  sleep_interval *= 2;
+	}
+
+      if (pid < 0)
+	break;
+      else if (pid == 0)
+	{
+	  if (attempt != RETRY_ICE_ATTEMPTS)
+	    fd = open (temp_filenames[attempt * 2], O_RDWR);
+	  if (fd < 0)
+	    exit (-1);
+	  if (fd != 1)
+	    {
+	      close (1);
+	      dup (fd);
+	      close (fd);
+	    }
+
+	  fd = open (temp_filenames[attempt * 2 + 1], O_RDWR);
+	  if (fd < 0)
+	    exit (-1);
+	  if (fd != 2)
+	    {
+	      close (2);
+	      dup (fd);
+	      close (fd);
+	    }
+
+	  if (prog == new_argv[0])
+	    execvp (prog, (char *const *) new_argv);
+	  else
+	    execv (new_argv[0], (char *const *) new_argv);
+	  exit (-1);
+	}
+
+      if (waitpid (pid, &status, 0) < 0)
+	break;
+
+      if (attempt < RETRY_ICE_ATTEMPTS
+	  && (! WIFEXITED (status) || WEXITSTATUS (status) != ICE_EXIT_CODE))
+	{
+	  notice ("The bug is not reproducible, so it is likely a hardware or OS problem.\n");
+	  break;
+	}
+      else if (attempt == RETRY_ICE_ATTEMPTS)
+	{
+	  close (fd);
+	  if (WIFEXITED (status)
+	      && WEXITSTATUS (status) == SUCCESS_EXIT_CODE)
+	    {
+	      notice ("Preprocessed source stored into %s file, please attach this to your bugreport.\n",
+		      temp_filenames[attempt * 2]);
+	      /* Make sure it is not deleted.  */
+	      free (temp_filenames[attempt * 2]);
+	      temp_filenames[attempt * 2] = NULL;
+	      break;
+	    }
+	}
+    }
+
+  for (attempt = 0; attempt < RETRY_ICE_ATTEMPTS * 2 + 2; attempt++)
+    if (temp_filenames[attempt])
+      {
+	unlink (temp_filenames[attempt]);
+	free (temp_filenames[attempt]);
+      }
+}
+#endif
+
 /* Search for a file named NAME trying various prefixes including the
    user's -B prefix and some standard ones.
    Return the absolute file name found.  If nothing is found, return NAME.  */
diff -r -u -N gcc-3.4.6_orig/gcc/genpeep.c gcc-3.4.6/gcc/genpeep.c
--- gcc-3.4.6_orig/gcc/genpeep.c	2007-09-30 14:28:19.000000000 +0200
+++ gcc-3.4.6/gcc/genpeep.c	2007-09-30 14:33:09.000000000 +0200
@@ -381,6 +381,7 @@
   printf ("#include \"recog.h\"\n");
   printf ("#include \"except.h\"\n\n");
   printf ("#include \"function.h\"\n\n");
+  printf ("#include \"flags.h\"\n\n");
 
   printf ("#ifdef HAVE_peephole\n");
   printf ("extern rtx peep_operand[];\n\n");
diff -r -u -N gcc-3.4.6_orig/gcc/mklibgcc.in gcc-3.4.6/gcc/mklibgcc.in
--- gcc-3.4.6_orig/gcc/mklibgcc.in	2007-09-30 14:28:10.000000000 +0200
+++ gcc-3.4.6/gcc/mklibgcc.in	2007-09-30 14:31:44.000000000 +0200
@@ -41,6 +41,7 @@
 # SHLIB_NM_FLAGS
 # SHLIB_INSTALL
 # MULTILIB_OSDIRNAMES
+# GCC_FOR_TARGET
 
 # Make needs VPATH to be literal.
 echo 'srcdir = @srcdir@'
@@ -513,8 +514,8 @@
       shlib_slibdir_qual=
       if [ -n "$MULTILIB_OSDIRNAMES" ]; then
 	if [ "$dir" != . ]; then
-	  gcc_multilib_dir=`./xgcc -B./ $flags --print-multi-directory`
-	  os_multilib_dir=`./xgcc -B./ $flags --print-multi-os-directory`
+	  gcc_multilib_dir=`$GCC_FOR_TARGET -B./ $flags --print-multi-directory`
+	  os_multilib_dir=`$GCC_FOR_TARGET -B./ $flags --print-multi-os-directory`
 	  shlib_dir="$dir"/
 	  gcc_multilib_sup=`echo $gcc_multilib_dir | sed 's~^[^/]*/~~'`
 	  os_multilib_base=`echo $os_multilib_dir | sed -n "s~/${gcc_multilib_sup}\$~~p"`
@@ -707,8 +708,8 @@
       shlib_dir=
       shlib_slibdir_qual=
       if [ -n "$MULTILIB_OSDIRNAMES" ]; then
-	gcc_multilib_dir=`./xgcc -B./ $flags --print-multi-directory`
-	os_multilib_dir=`./xgcc -B./ $flags --print-multi-os-directory`
+	gcc_multilib_dir=`$GCC_FOR_TARGET -B./ $flags --print-multi-directory`
+	os_multilib_dir=`$GCC_FOR_TARGET -B./ $flags --print-multi-os-directory`
 	if [ "$dir" != . ]; then
 	  shlib_dir="$dir"/
 	fi
diff -r -u -N gcc-3.4.6_orig/gcc/opts.c gcc-3.4.6/gcc/opts.c
--- gcc-3.4.6_orig/gcc/opts.c	2007-09-30 14:28:18.000000000 +0200
+++ gcc-3.4.6/gcc/opts.c	2007-09-30 14:32:22.000000000 +0200
@@ -142,6 +142,12 @@
    write_symbols is set to DBX_DEBUG, XCOFF_DEBUG, or DWARF_DEBUG.  */
 bool use_gnu_debug_info_extensions;
 
+/* The default visibility for all symbols (unless overridden) */
+enum symbol_visibility default_visibility = VISIBILITY_DEFAULT;
+
+/* Global visibility options.  */
+struct visibility_flags visibility_options;
+
 /* Columns of --help display.  */
 static unsigned int columns = 80;
 
@@ -1214,6 +1220,21 @@
       flag_profile_values = value;
       break;
 
+    case OPT_fvisibility_:
+      {
+        if (!strcmp(arg, "default"))
+          default_visibility = VISIBILITY_DEFAULT;
+        else if (!strcmp(arg, "internal"))
+          default_visibility = VISIBILITY_INTERNAL;
+        else if (!strcmp(arg, "hidden"))
+          default_visibility = VISIBILITY_HIDDEN;
+        else if (!strcmp(arg, "protected"))
+          default_visibility = VISIBILITY_PROTECTED;
+        else
+          error ("unrecognised visibility value \"%s\"", arg);
+      }
+      break;
+
     case OPT_fvpt:
       flag_value_profile_transformations_set = value;
       flag_value_profile_transformations = value;
diff -r -u -N gcc-3.4.6_orig/gcc/output.h gcc-3.4.6/gcc/output.h
--- gcc-3.4.6_orig/gcc/output.h	2007-09-30 14:28:08.000000000 +0200
+++ gcc-3.4.6/gcc/output.h	2007-09-30 14:34:07.000000000 +0200
@@ -213,6 +213,10 @@
 /* Tell assembler to switch to the section for function DECL.  */
 extern void function_section (tree);
 
+/* Tell assembler to switch to the readonly data section associated
+   with function DECL.  */
+extern void function_readonly_data_section (tree);
+
 /* Tell assembler to switch to the section for string merging.  */
 extern void mergeable_string_section (tree, unsigned HOST_WIDE_INT,
 				      unsigned int);
diff -r -u -N gcc-3.4.6_orig/gcc/po/ca.po gcc-3.4.6/gcc/po/ca.po
--- gcc-3.4.6_orig/gcc/po/ca.po	2007-09-30 14:28:08.000000000 +0200
+++ gcc-3.4.6/gcc/po/ca.po	2007-09-30 14:37:30.000000000 +0200
@@ -17340,7 +17340,7 @@
 
 #: cp/typeck.c:5684
 msgid "%s of negative value `%E' to `%T'"
-msgstr "%s de valor negatiu `%I' a \"%T\""
+msgstr "%s de valor negatiu `%E' a \"%T\""
 
 #: cp/typeck.c:5772
 msgid "cannot convert `%T' to `%T' for argument `%P' to `%D'"
diff -r -u -N gcc-3.4.6_orig/gcc/po/es.po gcc-3.4.6/gcc/po/es.po
--- gcc-3.4.6_orig/gcc/po/es.po	2007-09-30 14:28:08.000000000 +0200
+++ gcc-3.4.6/gcc/po/es.po	2007-09-30 14:37:34.000000000 +0200
@@ -1901,12 +1901,12 @@
 #: c-format.c:2027
 #, c-format
 msgid "%s does not support the `%%%c' %s format"
-msgstr "%1$s no tiene soporte para el formato %3$s `%%%2$c'"
+msgstr "%s no tiene soporte para el formato `%%%c' %s"
 
 #: c-format.c:2043
 #, c-format
 msgid "%s used with `%%%c' %s format"
-msgstr "se us %1$s con el formato %3$s `%%%2$c'"
+msgstr "se us %s con el formato `%%%c' %s"
 
 #: c-format.c:2052
 #, c-format
@@ -1916,12 +1916,12 @@
 #: c-format.c:2061
 #, c-format
 msgid "%s does not support %s with the `%%%c' %s format"
-msgstr "%1$s no tiene soporte para %2$s con el formato %4$s `%%%3$c'"
+msgstr "%s no tiene soporte para %s con el formato `%%%c' %s"
 
 #: c-format.c:2094
 #, c-format
 msgid "%s ignored with %s and `%%%c' %s format"
-msgstr "se ignora %1$s con %2$s y el formato %4$s `%%%3$c'"
+msgstr "se ignora %s con %s y el formato `%%%c' %s"
 
 #: c-format.c:2098
 #, c-format
@@ -1931,7 +1931,7 @@
 #: c-format.c:2104
 #, c-format
 msgid "use of %s and %s together with `%%%c' %s format"
-msgstr "uso de %1$s y %2$s junto con el formato %4$s `%%%3$c'"
+msgstr "uso de %s y %s junto con el formato `%%%c' %s"
 
 #: c-format.c:2108
 #, c-format
@@ -1962,7 +1962,7 @@
 #: c-format.c:2180
 #, c-format
 msgid "%s does not support the `%%%s%c' %s format"
-msgstr "%1$s no tiene soporte para el formato %4$s `%%%2$s%3$c'"
+msgstr "%s no tiene soporte para el formato `%%%s%c' %s"
 
 #: c-format.c:2195
 msgid "operand number specified with suppressed assignment"
diff -r -u -N gcc-3.4.6_orig/gcc/system.h gcc-3.4.6/gcc/system.h
--- gcc-3.4.6_orig/gcc/system.h	2007-09-30 14:28:07.000000000 +0200
+++ gcc-3.4.6/gcc/system.h	2007-09-30 14:31:16.000000000 +0200
@@ -154,6 +154,10 @@
 # endif
 #endif
 
+#ifndef ICE_EXIT_CODE
+# define ICE_EXIT_CODE 27
+#endif
+
 #ifdef HAVE_UNISTD_H
 # include <unistd.h>
 #endif
diff -r -u -N gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/assign1.C gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/assign1.C
--- gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/assign1.C	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/assign1.C	2007-09-30 14:32:44.000000000 +0200
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+/* { dg-require-visibility "" } */
+/* { dg-final { scan-hidden "_ZN1DaSERKS_" } } */
+
+struct B {
+  B& operator=(const B&);
+};
+
+struct D : public B {
+  // The implicit assignment operator should be hidden.
+} __attribute__((visibility("hidden")));
+
+D d1, d2;
+
+void f() {
+  d1 = d2;
+}
diff -r -u -N gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/fvisibility-inlines-hidden.C gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/fvisibility-inlines-hidden.C
--- gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/fvisibility-inlines-hidden.C	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/fvisibility-inlines-hidden.C	2007-09-30 14:32:44.000000000 +0200
@@ -0,0 +1,18 @@
+/* Test that -fvisibility-inlines-hidden affects class members. */
+/* { dg-do compile } */
+/* { dg-require-visibility "" } */
+/* { dg-options "-fvisibility-inlines-hidden" } */
+/* { dg-final { scan-hidden "_ZN3Foo6methodEv" } } */
+
+class Foo
+{
+public:
+  void method() { }
+};
+
+int main(void)
+{
+  Foo f;
+  f.method();
+  return 0;
+}
diff -r -u -N gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/fvisibility-override1.C gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/fvisibility-override1.C
--- gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/fvisibility-override1.C	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/fvisibility-override1.C	2007-09-30 14:32:31.000000000 +0200
@@ -0,0 +1,12 @@
+/* Test that -fvisibility does not override class member specific settings. */
+/* { dg-do compile } */
+/* { dg-require-visibility "" } */
+/* { dg-options "-fvisibility=hidden" } */
+/* { dg-final { scan-assembler "\\.internal.*Foo.methodEv" } } */
+
+class __attribute__ ((visibility ("internal"))) Foo
+{
+  void method();
+};
+
+void Foo::method() { }
diff -r -u -N gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/fvisibility-override2.C gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/fvisibility-override2.C
--- gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/fvisibility-override2.C	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/fvisibility-override2.C	2007-09-30 14:32:31.000000000 +0200
@@ -0,0 +1,12 @@
+/* Test that -fvisibility does not override class member specific settings. */
+/* { dg-do compile } */
+/* { dg-require-visibility "" } */
+/* { dg-options "-fvisibility=hidden" } */
+/* { dg-final { scan-assembler "\\.internal.*Foo.methodEv" } } */
+
+class Foo
+{
+  __attribute__ ((visibility ("internal"))) void method();
+};
+
+void Foo::method() { }
diff -r -u -N gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/fvisibility.C gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/fvisibility.C
--- gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/fvisibility.C	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/fvisibility.C	2007-09-30 14:32:44.000000000 +0200
@@ -0,0 +1,12 @@
+/* Test that -fvisibility affects class members. */
+/* { dg-do compile } */
+/* { dg-require-visibility "" } */
+/* { dg-options "-fvisibility=hidden" } */
+/* { dg-final { scan-hidden "_ZN3Foo6methodEv" } } */
+
+class Foo
+{
+  void method();
+};
+
+void Foo::method() { }
diff -r -u -N gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/memfuncts.C gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/memfuncts.C
--- gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/memfuncts.C	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/memfuncts.C	2007-09-30 14:32:44.000000000 +0200
@@ -0,0 +1,11 @@
+/* Test that setting visibility for class member functions works. */
+/* { dg-do compile } */
+/* { dg-require-visibility "" } */
+/* { dg-final { scan-hidden "_ZN3Foo6methodEv" } } */
+
+class __attribute__ ((visibility ("hidden"))) Foo
+{
+  void method();
+};
+
+void Foo::method() { }
diff -r -u -N gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/new1.C gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/new1.C
--- gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/new1.C	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/new1.C	2007-09-30 14:32:44.000000000 +0200
@@ -0,0 +1,13 @@
+// { dg-require-visibility "" }
+// { dg-options "-fvisibility=hidden" }
+// { dg-final { scan-not-hidden "_Znwj" } }
+
+void f() {
+  new int;
+}
+
+void *g();
+
+void *operator new(__SIZE_TYPE__) {
+  return g();
+}
diff -r -u -N gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/noPLT.C gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/noPLT.C
--- gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/noPLT.C	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/noPLT.C	2007-09-30 14:32:31.000000000 +0200
@@ -0,0 +1,20 @@
+/* Test that -fvisibility=hidden prevents PLT. */
+/* { dg-do compile } */
+/* { dg-require-visibility "" } */
+/* { dg-options "-fPIC -fvisibility=hidden" } */
+/* { dg-final { scan-assembler-not "methodEv@PLT" } } */
+
+class Foo
+{
+public:
+  void method();
+};
+
+void Foo::method() { }
+
+int main(void)
+{
+  Foo f;
+  f.method();
+  return 0;
+}
diff -r -u -N gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/pragma-override1.C gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/pragma-override1.C
--- gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/pragma-override1.C	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/pragma-override1.C	2007-09-30 14:32:31.000000000 +0200
@@ -0,0 +1,13 @@
+/* Test that #pragma GCC visibility does not override class member specific settings. */
+/* { dg-do compile } */
+/* { dg-require-visibility "" } */
+/* { dg-final { scan-assembler "\\.internal.*Foo.methodEv" } } */
+
+#pragma GCC visibility push(hidden)
+class __attribute__ ((visibility ("internal"))) Foo
+{
+  void method();
+};
+#pragma GCC visibility pop
+
+void Foo::method() { }
diff -r -u -N gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/pragma-override2.C gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/pragma-override2.C
--- gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/pragma-override2.C	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/pragma-override2.C	2007-09-30 14:32:31.000000000 +0200
@@ -0,0 +1,13 @@
+/* Test that #pragma GCC visibility does not override class member specific settings. */
+/* { dg-do compile } */
+/* { dg-require-visibility "" } */
+/* { dg-final { scan-assembler "\\.internal.*Foo.methodEv" } } */
+
+#pragma GCC visibility push(hidden)
+class Foo
+{
+  __attribute__ ((visibility ("internal"))) void method();
+};
+#pragma GCC visibility pop
+
+void Foo::method() { }
diff -r -u -N gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/pragma.C gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/pragma.C
--- gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/pragma.C	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/pragma.C	2007-09-30 14:32:44.000000000 +0200
@@ -0,0 +1,13 @@
+/* Test that #pragma GCC visibility affects class members. */
+/* { dg-do compile } */
+/* { dg-require-visibility "" } */
+/* { dg-final { scan-hidden "_ZN3Foo6methodEv" } } */
+
+#pragma GCC visibility push(hidden)
+class Foo
+{
+  void method();
+};
+#pragma GCC visibility pop
+
+void Foo::method() { }
diff -r -u -N gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/staticmemfuncts.C gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/staticmemfuncts.C
--- gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/staticmemfuncts.C	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/staticmemfuncts.C	2007-09-30 14:32:44.000000000 +0200
@@ -0,0 +1,11 @@
+/* Test that setting visibility for static class member functions works. */
+/* { dg-do compile } */
+/* { dg-require-visibility "" } */
+/* { dg-final { scan-hidden "_ZN3Foo6methodEv" } } */
+
+class __attribute__ ((visibility ("hidden"))) Foo
+{
+  static void method();
+};
+
+void Foo::method() { }
diff -r -u -N gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/virtual.C gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/virtual.C
--- gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/virtual.C	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/virtual.C	2007-09-30 14:32:44.000000000 +0200
@@ -0,0 +1,11 @@
+/* Test that setting visibility for class affects virtual table. */
+/* { dg-do compile } */
+/* { dg-require-visibility "" } */
+/* { dg-final { scan-hidden "ZTV3Foo" } } */
+
+class __attribute__ ((visibility ("hidden"))) Foo
+{
+  virtual void method();
+};
+
+void Foo::method() { }
diff -r -u -N gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/visibility-1.C gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/visibility-1.C
--- gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/visibility-1.C	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/visibility-1.C	2007-09-30 14:32:44.000000000 +0200
@@ -0,0 +1,8 @@
+/* Test visibility attribute on function definition. */
+/* { dg-require-visibility "" }
+/* { dg-final { scan-hidden "_Z3foov" } } */
+
+void
+__attribute__((visibility ("hidden")))
+foo()
+{ }
diff -r -u -N gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/visibility-2.C gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/visibility-2.C
--- gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/visibility-2.C	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/visibility-2.C	2007-09-30 14:32:44.000000000 +0200
@@ -0,0 +1,7 @@
+/* Test that visibility attribute on declaration extends to definition. */
+/* { dg-require-visibility "" }
+/* { dg-final { scan-hidden "_Z3foov" } } */
+
+void __attribute__((visibility ("hidden"))) foo();
+
+void foo() { }
diff -r -u -N gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/visibility-3.C gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/visibility-3.C
--- gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/visibility-3.C	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/visibility-3.C	2007-09-30 14:32:44.000000000 +0200
@@ -0,0 +1,7 @@
+/* Test visibility attribute on forward declaration of global variable */
+/* { dg-require-visibility "" }
+/* { dg-final { scan-hidden "xyzzy" } } */
+
+int
+__attribute__((visibility ("hidden")))
+xyzzy = 5;
diff -r -u -N gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/visibility-4.C gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/visibility-4.C
--- gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/visibility-4.C	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/visibility-4.C	2007-09-30 14:32:44.000000000 +0200
@@ -0,0 +1,8 @@
+/* Test visibility attribute on forward declaration of global variable */
+/* { dg-require-visibility "" }
+/* { dg-final { scan-hidden "xyzzy" } } */
+
+extern int __attribute__ ((visibility ("hidden")))
+xyzzy;
+
+int xyzzy = 5;
diff -r -u -N gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/visibility-5.C gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/visibility-5.C
--- gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/visibility-5.C	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/visibility-5.C	2007-09-30 14:32:44.000000000 +0200
@@ -0,0 +1,11 @@
+/* Test visibility attribute on definition of a function that has
+   already had a forward declaration. */
+/* { dg-require-visibility "" }
+/* { dg-final { scan-hidden "_Z3foov" } } */
+
+void foo();
+
+void 
+ __attribute__((visibility ("hidden")))
+foo() 
+{ }
diff -r -u -N gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/visibility-6.C gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/visibility-6.C
--- gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/visibility-6.C	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/visibility-6.C	2007-09-30 14:32:44.000000000 +0200
@@ -0,0 +1,10 @@
+/* Test visibility attribute on definition of global variable that has
+   already had a forward declaration. */
+/* { dg-require-visibility "" }
+/* { dg-final { scan-hidden "xyzzy" } } */
+
+extern int xyzzy;
+
+int 
+__attribute__((visibility ("hidden")))
+xyzzy = 5;
diff -r -u -N gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/visibility-7.C gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/visibility-7.C
--- gcc-3.4.6_orig/gcc/testsuite/g++.dg/ext/visibility/visibility-7.C	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc/testsuite/g++.dg/ext/visibility/visibility-7.C	2007-09-30 14:32:44.000000000 +0200
@@ -0,0 +1,11 @@
+/* Test warning from conflicting visibility specifications. */
+/* { dg-require-visibility "" } */
+/* { dg-final { scan-hidden "xyzzy" } } */
+
+extern int 
+__attribute__((visibility ("hidden")))
+xyzzy; /* { dg-warning "previous declaration here" "" } */
+
+int 
+__attribute__((visibility ("protected")))
+xyzzy = 5; /* { dg-warning "visibility attribute ignored" "" } */
diff -r -u -N gcc-3.4.6_orig/gcc/testsuite/g++.old-deja/g++.other/comdat4-aux.cc gcc-3.4.6/gcc/testsuite/g++.old-deja/g++.other/comdat4-aux.cc
--- gcc-3.4.6_orig/gcc/testsuite/g++.old-deja/g++.other/comdat4-aux.cc	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc/testsuite/g++.old-deja/g++.other/comdat4-aux.cc	2007-09-30 14:34:07.000000000 +0200
@@ -0,0 +1,40 @@
+extern void
+bar (int x);
+
+inline void
+foo (int i)
+{
+  switch (i)
+    {
+    case 3:
+    case 5:
+    case 6:
+    case 9:
+    case 15:
+      bar (1);
+      break;
+    case 2:
+    case 4:
+    case 7:
+    case 10:
+    case 11:
+    case 12:
+      bar (2);
+      break;
+    case 0:
+    case 1:
+    case 8:
+    case 13:
+    case 16:
+      bar (3);
+      break;
+    case 14:
+      bar (4);
+      break;
+    default:
+      bar (5);
+      break;
+    }
+}
+
+void *fooaddr2 = (void *) foo;
diff -r -u -N gcc-3.4.6_orig/gcc/testsuite/g++.old-deja/g++.other/comdat4.C gcc-3.4.6/gcc/testsuite/g++.old-deja/g++.other/comdat4.C
--- gcc-3.4.6_orig/gcc/testsuite/g++.old-deja/g++.other/comdat4.C	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc/testsuite/g++.old-deja/g++.other/comdat4.C	2007-09-30 14:34:07.000000000 +0200
@@ -0,0 +1,57 @@
+// PR c++/16276
+// { dg-do link }
+// { dg-additional-sources " comdat4-aux.cc" }
+// { dg-options "-O2" }
+
+extern void
+bar (int x);
+
+inline void
+foo (int i)
+{
+  switch (i)
+    {
+    case 3:
+    case 5:
+    case 6:
+    case 9:
+    case 15:
+      bar (1);
+      break;
+    case 2:
+    case 4:
+    case 7:
+    case 10:
+    case 11:
+    case 12:
+      bar (2);
+      break;
+    case 0:
+    case 1:
+    case 8:
+    case 13:
+    case 16:
+      bar (3);
+      break;
+    case 14:
+      bar (4);
+      break;
+    default:
+      bar (5);
+      break;
+    }
+}
+
+void *fooaddr = (void *) foo;
+
+void
+bar (int x)
+{
+  __asm __volatile ("" : : "r" (x));
+}
+
+int
+main (void)
+{
+  return 0;
+}
diff -r -u -N gcc-3.4.6_orig/gcc/testsuite/gcc.dg/ppc64-toc.c gcc-3.4.6/gcc/testsuite/gcc.dg/ppc64-toc.c
--- gcc-3.4.6_orig/gcc/testsuite/gcc.dg/ppc64-toc.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc/testsuite/gcc.dg/ppc64-toc.c	2007-09-30 14:32:01.000000000 +0200
@@ -0,0 +1,22 @@
+/* { dg-do link } */
+/* { dg-options "-m64 -mminimal-toc" { target powerpc64-*-* } } */
+
+char *strchr (const char *, int);
+
+int
+foo (int a)
+{
+  int b;
+
+  b = 0;
+  if ("/"[1] != '\0')
+    if (strchr ("/", a))
+      b = 1;
+  return b;
+}
+
+int
+main (void)
+{
+  return 0;
+}
diff -r -u -N gcc-3.4.6_orig/gcc/testsuite/gcc.dg/visibility-9.c gcc-3.4.6/gcc/testsuite/gcc.dg/visibility-9.c
--- gcc-3.4.6_orig/gcc/testsuite/gcc.dg/visibility-9.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc/testsuite/gcc.dg/visibility-9.c	2007-09-30 14:32:31.000000000 +0200
@@ -0,0 +1,9 @@
+/* Test that -fvisibility works. */
+/* { dg-do compile } */
+/* { dg-require-visibility "" } */
+/* { dg-options "-fvisibility=hidden" } */
+/* { dg-final { scan-assembler "\\.hidden.*foo" } } */
+
+void foo();
+
+void foo() { }
diff -r -u -N gcc-3.4.6_orig/gcc/testsuite/gcc.dg/visibility-a.c gcc-3.4.6/gcc/testsuite/gcc.dg/visibility-a.c
--- gcc-3.4.6_orig/gcc/testsuite/gcc.dg/visibility-a.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc/testsuite/gcc.dg/visibility-a.c	2007-09-30 14:32:31.000000000 +0200
@@ -0,0 +1,10 @@
+/* Test that #pragma GCC visibility works. */
+/* { dg-do compile } */
+/* { dg-require-visibility "" } */
+/* { dg-final { scan-assembler "\\.hidden.*foo" } } */
+
+#pragma GCC visibility push(hidden)
+void foo();
+#pragma GCC visibility pop
+
+void foo() { }
diff -r -u -N gcc-3.4.6_orig/gcc/tree.c gcc-3.4.6/gcc/tree.c
--- gcc-3.4.6_orig/gcc/tree.c	2007-09-30 14:28:12.000000000 +0200
+++ gcc-3.4.6/gcc/tree.c	2007-09-30 14:32:22.000000000 +0200
@@ -2563,6 +2563,11 @@
     layout_decl (t, 0);
   else if (code == FUNCTION_DECL)
     DECL_MODE (t) = FUNCTION_MODE;
+    
+  /* Set default visibility to whatever the user supplied with
+     visibility_specified depending on #pragma GCC visibility.  */
+  DECL_VISIBILITY (t) = default_visibility;
+  DECL_VISIBILITY_SPECIFIED (t) = visibility_options.inpragma;
 
   return t;
 }
diff -r -u -N gcc-3.4.6_orig/gcc/tree.h gcc-3.4.6/gcc/tree.h
--- gcc-3.4.6_orig/gcc/tree.h	2007-09-30 14:28:08.000000000 +0200
+++ gcc-3.4.6/gcc/tree.h	2007-09-30 14:32:22.000000000 +0200
@@ -1499,6 +1499,10 @@
 /* Value of the decls's visibility attribute */
 #define DECL_VISIBILITY(NODE) (DECL_CHECK (NODE)->decl.visibility)
 
+/* Nonzero means that the decl had its visibility specified rather than
+   being inferred.  */
+#define DECL_VISIBILITY_SPECIFIED(NODE) (DECL_CHECK (NODE)->decl.visibility_specified)
+
 /* In a FUNCTION_DECL, nonzero if the function cannot be inlined.  */
 #define DECL_UNINLINABLE(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.uninlinable)
 
@@ -1633,7 +1637,8 @@
    || TREE_CODE (DECL_CONTEXT (EXP)) == TRANSLATION_UNIT_DECL)
 
 /* Enumerate visibility settings.  */
-
+#ifndef SYMBOL_VISIBILITY_DEFINED
+#define SYMBOL_VISIBILITY_DEFINED
 enum symbol_visibility
 {
   VISIBILITY_DEFAULT,
@@ -1641,6 +1646,7 @@
   VISIBILITY_HIDDEN,
   VISIBILITY_PROTECTED
 };
+#endif
 
 struct function;
 
@@ -1684,8 +1690,7 @@
   unsigned thread_local_flag : 1;
   unsigned declared_inline_flag : 1;
   ENUM_BITFIELD(symbol_visibility) visibility : 2;
-  unsigned unused : 1;
-  /* one unused bit.  */
+  unsigned visibility_specified : 1;
 
   unsigned lang_flag_0 : 1;
   unsigned lang_flag_1 : 1;
diff -r -u -N gcc-3.4.6_orig/gcc/varasm.c gcc-3.4.6/gcc/varasm.c
--- gcc-3.4.6_orig/gcc/varasm.c	2007-09-30 14:28:09.000000000 +0200
+++ gcc-3.4.6/gcc/varasm.c	2007-09-30 14:34:07.000000000 +0200
@@ -535,6 +535,45 @@
     text_section ();
 }
 
+/* Switch to read-only data section associated with function DECL.
+
+   If DECL is NULL_TREE, switch to readonly_data_section ().  */
+
+void
+function_readonly_data_section (tree decl)
+{
+  if (decl != NULL_TREE && DECL_SECTION_NAME (decl))
+    {
+      const char *name = TREE_STRING_POINTER (DECL_SECTION_NAME (decl));
+
+      /* For .gnu.linkonce.t.foo we want to use .gnu.linkonce.r.foo.  */
+      if (DECL_ONE_ONLY (decl) && strncmp (name, ".gnu.linkonce.t.", 16) == 0)
+       {
+         size_t len = strlen (name) + 1;
+         char *rname = alloca (len);
+
+         memcpy (rname, name, len);
+         rname[14] = 'r';
+         named_section_flags (rname, SECTION_LINKONCE);
+         return;
+       }
+      /* For .text.foo we want to use .rodata.foo.  */
+      else if (flag_function_sections && flag_data_sections
+              && strncmp (name, ".text.", 6) == 0)
+       {
+         size_t len = strlen (name) + 1;
+         char *rname = alloca (len + 2);
+
+         memcpy (rname, ".rodata", 7);
+         memcpy (rname + 7, name + 5, len - 5);
+         named_section_flags (rname, 0);
+         return;
+       }
+    }
+
+  readonly_data_section ();
+}
+
 /* Switch to section for variable DECL.  RELOC is the same as the
    argument to SELECT_SECTION.  */
 
@@ -5211,8 +5250,8 @@
   /* Static variables are always local.  */
   else if (! TREE_PUBLIC (exp))
     local_p = true;
-  /* A variable is local if the user tells us so.  */
-  else if (DECL_VISIBILITY (exp) != VISIBILITY_DEFAULT)
+  /* A variable is local if the user explicitly tells us so.  */
+  else if (DECL_VISIBILITY_SPECIFIED (exp) && DECL_VISIBILITY (exp) != VISIBILITY_DEFAULT)
     local_p = true;
   /* Otherwise, variables defined outside this object may not be local.  */
   else if (DECL_EXTERNAL (exp))
@@ -5220,6 +5259,9 @@
   /* Linkonce and weak data are never local.  */
   else if (DECL_ONE_ONLY (exp) || DECL_WEAK (exp))
     local_p = false;
+  /* If none of the above and visibility is not default, make local.  */
+  else if (DECL_VISIBILITY (exp) != VISIBILITY_DEFAULT)
+    local_p = true;
   /* If PIC, then assume that any global name can be overridden by
      symbols resolved from other modules.  */
   else if (shlib)
diff -r -u -N gcc-3.4.6_orig/gcc-3.4.4/gcc/config/i386/openbsdelf.h gcc-3.4.6/gcc-3.4.4/gcc/config/i386/openbsdelf.h
--- gcc-3.4.6_orig/gcc-3.4.4/gcc/config/i386/openbsdelf.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.6/gcc-3.4.4/gcc/config/i386/openbsdelf.h	2007-09-30 14:32:12.000000000 +0200
@@ -0,0 +1,135 @@
+
+/* Configuration for an OpenBSD i386 target.
+   
+   Copyright (C) 1999 Free Software Foundation, Inc.
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* This gets defined in tm.h->linux.h->svr4.h, and keeps us from using
+   libraries compiled with the native cc, so undef it. */
+#undef NO_DOLLAR_IN_LABEL
+
+/* Override the default comment-starter of "/".  */
+#undef ASM_COMMENT_START
+#define ASM_COMMENT_START "#"
+
+
+/* This goes away when the math-emulator is fixed */
+#undef TARGET_DEFAULT
+#define TARGET_DEFAULT \
+  (MASK_80387 | MASK_IEEE_FP | MASK_FLOAT_RETURNS | MASK_NO_FANCY_MATH_387)
+
+/* Run-time target specifications */
+
+#define TARGET_OS_CPP_BUILTINS()		\
+  do						\
+    {						\
+    	OPENBSD_OS_CPP_BUILTINS_ELF();		\
+    }						\
+  while (0)
+
+/* As an elf system, we need crtbegin/crtend stuff.  */
+#undef STARTFILE_SPEC
+#define STARTFILE_SPEC "\
+	%{!shared: %{pg:gcrt0%O%s} %{!pg:%{p:gcrt0%O%s} %{!p:crt0%O%s}} \
+	crtbegin%O%s} %{shared:crtbeginS%O%s}"
+#undef ENDFILE_SPEC
+#define ENDFILE_SPEC "%{!shared:crtend%O%s} %{shared:crtendS%O%s}"
+
+/* Layout of source language data types.  */
+
+/* This must agree with <machine/ansi.h> */
+#undef SIZE_TYPE
+#define SIZE_TYPE "unsigned int"
+
+#undef PTRDIFF_TYPE
+#define PTRDIFF_TYPE "int"
+
+#undef WCHAR_TYPE
+#define WCHAR_TYPE "int"
+
+#undef WCHAR_TYPE_SIZE
+#define WCHAR_TYPE_SIZE BITS_PER_WORD
+
+/* Assembler format: overall framework.  */
+
+#undef ASM_APP_ON
+#define ASM_APP_ON "#APP\n"
+
+#undef ASM_APP_OFF
+#define ASM_APP_OFF "#NO_APP\n"
+
+#undef SET_ASM_OP
+#define SET_ASM_OP	"\t.set\t"
+
+/* The following macros were originally stolen from i386v4.h.
+   These have to be defined to get PIC code correct.  */
+
+/* Assembler format: dispatch tables.  */
+
+/* Assembler format: sections.  */
+
+/* Stack & calling: aggregate returns.  */
+
+/* Don't default to pcc-struct-return, because gcc is the only compiler, and
+   we want to retain compatibility with older gcc versions.  */
+#define DEFAULT_PCC_STRUCT_RETURN 0
+
+/* Assembler format: alignment output.  */
+
+#ifdef HAVE_GAS_MAX_SKIP_P2ALIGN
+#define ASM_OUTPUT_MAX_SKIP_ALIGN(FILE,LOG,MAX_SKIP) \
+  if ((LOG) != 0) {\
+    if ((MAX_SKIP) == 0) fprintf ((FILE), "\t.p2align %d\n", (LOG)); \
+    else fprintf ((FILE), "\t.p2align %d,,%d\n", (LOG), (MAX_SKIP)); \
+  }
+#endif
+
+/* Stack & calling: profiling.  */
+
+/* OpenBSD's profiler recovers all information from the stack pointer.
+   The icky part is not here, but in machine/profile.h.  */
+#undef FUNCTION_PROFILER
+#define FUNCTION_PROFILER(FILE, LABELNO)  \
+  fputs (flag_pic ? "\tcall __mcount@PLT\n": "\tcall __mcount\n", FILE);
+
+/* Assembler format: exception region output.  */
+
+/* our configuration still doesn't handle dwarf2 correctly */
+#define DWARF2_UNWIND_INFO 0
+
+/* Assembler format: alignment output.  */
+
+/* Note that we pick up ASM_OUTPUT_MAX_SKIP_ALIGN from i386/gas.h */
+
+/* Note that we pick up ASM_OUTPUT_MI_THUNK from unix.h.  */
+
+#undef LINK_SPEC
+#define LINK_SPEC \
+  "%{!shared:%{!nostdlib:%{!r*:%{!e*:-e __start}}}} \
+   %{shared:-shared} %{R*} \
+   %{static:-Bstatic} \
+   %{!static:-Bdynamic} \
+   %{assert*} \
+   %{!dynamic-linker:-dynamic-linker /usr/libexec/ld.so}"
+
+#define OBSD_HAS_CORRECT_SPECS
+
+/* pick up defines for mprotect (used in TRANSFER_FROM_TRANPOLINE) */
+#include <sys/types.h>
+#include <sys/mman.h>
diff -r -u -N gcc-3.4.6_orig/libiberty/splay-tree.c gcc-3.4.6/libiberty/splay-tree.c
--- gcc-3.4.6_orig/libiberty/splay-tree.c	2007-09-30 14:28:07.000000000 +0200
+++ gcc-3.4.6/libiberty/splay-tree.c	2007-09-30 14:37:44.000000000 +0200
@@ -59,18 +59,59 @@
      splay_tree sp;
      splay_tree_node node;
 {
+  splay_tree_node pending = 0;
+  splay_tree_node active = 0;
+
   if (!node)
     return;
 
-  splay_tree_delete_helper (sp, node->left);
-  splay_tree_delete_helper (sp, node->right);
+#define KDEL(x)  if (sp->delete_key) (*sp->delete_key)(x);
+#define VDEL(x)  if (sp->delete_value) (*sp->delete_value)(x);
+
+  KDEL (node->key);
+  VDEL (node->value);
+
+  /* We use the "key" field to hold the "next" pointer.  */
+  node->key = (splay_tree_key)pending;
+  pending = (splay_tree_node)node;
+
+  /* Now, keep processing the pending list until there aren't any
+     more.  This is a little more complicated than just recursing, but
+     it doesn't toast the stack for large trees.  */
+
+  while (pending)
+    {
+      active = pending;
+      pending = 0;
+      while (active)
+	{
+	  splay_tree_node temp;
+
+	  /* active points to a node which has its key and value
+	     deallocated, we just need to process left and right.  */
 
-  if (sp->delete_key)
-    (*sp->delete_key)(node->key);
-  if (sp->delete_value)
-    (*sp->delete_value)(node->value);
+	  if (active->left)
+	    {
+	      KDEL (active->left->key);
+	      VDEL (active->left->value);
+	      active->left->key = (splay_tree_key)pending;
+	      pending = (splay_tree_node)(active->left);
+	    }
+	  if (active->right)
+	    {
+	      KDEL (active->right->key);
+	      VDEL (active->right->value);
+	      active->right->key = (splay_tree_key)pending;
+	      pending = (splay_tree_node)(active->right);
+	    }
 
-  (*sp->deallocate) ((char*) node, sp->allocate_data);
+	  temp = active;
+	  active = (splay_tree_node)(temp->key);
+	  (*sp->deallocate) ((char*) temp, sp->allocate_data);
+	}
+    }
+#undef KDEL
+#undef VDEL
 }
 
 /* Help splay SP around KEY.  PARENT and GRANDPARENT are the parent
diff -r -u -N gcc-3.4.6_orig/libstdc++-v3/docs/doxygen/filter gcc-3.4.6/libstdc++-v3/docs/doxygen/filter
--- gcc-3.4.6_orig/libstdc++-v3/docs/doxygen/filter	2007-09-30 14:28:32.000000000 +0200
+++ gcc-3.4.6/libstdc++-v3/docs/doxygen/filter	2007-09-30 14:37:37.000000000 +0200
@@ -1,5 +1,7 @@
 #!/bin/sh
 
+export LC_ALL=C
+
 script=$1
 file=$2
 
diff -r -u -N gcc-3.4.6_orig/libstdc++-v3/include/bits/allocator.h gcc-3.4.6/libstdc++-v3/include/bits/allocator.h
--- gcc-3.4.6_orig/libstdc++-v3/include/bits/allocator.h	2007-09-30 14:28:32.000000000 +0200
+++ gcc-3.4.6/libstdc++-v3/include/bits/allocator.h	2007-09-30 14:32:56.000000000 +0200
@@ -51,6 +51,8 @@
 // Define the base class to std::allocator.
 #include <bits/c++allocator.h>
 
+#pragma GCC visibility push(default)
+
 namespace std
 {
   template<typename _Tp>
@@ -127,4 +129,6 @@
 #undef ___glibcxx_base_allocator
 } // namespace std
 
+#pragma GCC visibility pop
+
 #endif
diff -r -u -N gcc-3.4.6_orig/libstdc++-v3/include/bits/basic_string.h gcc-3.4.6/libstdc++-v3/include/bits/basic_string.h
--- gcc-3.4.6_orig/libstdc++-v3/include/bits/basic_string.h	2007-09-30 14:28:32.000000000 +0200
+++ gcc-3.4.6/libstdc++-v3/include/bits/basic_string.h	2007-09-30 14:32:56.000000000 +0200
@@ -45,6 +45,8 @@
 #include <bits/atomicity.h>
 #include <debug/debug.h>
 
+#pragma GCC visibility push(default)
+
 namespace std
 {
   /**
@@ -2362,4 +2364,6 @@
 	    basic_string<_CharT, _Traits, _Alloc>& __str);
 } // namespace std
 
+#pragma GCC visibility pop
+
 #endif /* _BASIC_STRING_H */
diff -r -u -N gcc-3.4.6_orig/libstdc++-v3/include/std/std_fstream.h gcc-3.4.6/libstdc++-v3/include/std/std_fstream.h
--- gcc-3.4.6_orig/libstdc++-v3/include/std/std_fstream.h	2007-09-30 14:28:32.000000000 +0200
+++ gcc-3.4.6/libstdc++-v3/include/std/std_fstream.h	2007-09-30 14:32:56.000000000 +0200
@@ -49,6 +49,8 @@
 #include <bits/basic_file.h>
 #include <bits/gthr.h>
 
+#pragma GCC visibility push(default)
+
 namespace std
 {
   // [27.8.1.1] template class basic_filebuf
@@ -840,4 +842,6 @@
 # include <bits/fstream.tcc>
 #endif
 
+#pragma GCC visibility pop
+
 #endif /* _GLIBCXX_FSTREAM */
diff -r -u -N gcc-3.4.6_orig/libstdc++-v3/include/std/std_istream.h gcc-3.4.6/libstdc++-v3/include/std/std_istream.h
--- gcc-3.4.6_orig/libstdc++-v3/include/std/std_istream.h	2007-09-30 14:28:32.000000000 +0200
+++ gcc-3.4.6/libstdc++-v3/include/std/std_istream.h	2007-09-30 14:32:56.000000000 +0200
@@ -45,6 +45,8 @@
 #include <ios>
 #include <limits> // For numeric_limits
 
+#pragma GCC visibility push(default)
+
 namespace std
 {
   // [27.6.1.1] Template class basic_istream
@@ -771,4 +773,6 @@
 # include <bits/istream.tcc>
 #endif
 
+#pragma GCC visibility pop
+
 #endif	/* _GLIBCXX_ISTREAM */
diff -r -u -N gcc-3.4.6_orig/libstdc++-v3/include/std/std_ostream.h gcc-3.4.6/libstdc++-v3/include/std/std_ostream.h
--- gcc-3.4.6_orig/libstdc++-v3/include/std/std_ostream.h	2007-09-30 14:28:32.000000000 +0200
+++ gcc-3.4.6/libstdc++-v3/include/std/std_ostream.h	2007-09-30 14:32:56.000000000 +0200
@@ -44,6 +44,8 @@
 
 #include <ios>
 
+#pragma GCC visibility push(default)
+
 namespace std
 {
   // [27.6.2.1] Template class basic_ostream
@@ -545,4 +547,6 @@
 # include <bits/ostream.tcc>
 #endif
 
+#pragma GCC visibility pop
+
 #endif	/* _GLIBCXX_OSTREAM */
diff -r -u -N gcc-3.4.6_orig/libstdc++-v3/src/Makefile.am gcc-3.4.6/libstdc++-v3/src/Makefile.am
--- gcc-3.4.6_orig/libstdc++-v3/src/Makefile.am	2007-09-30 14:28:34.000000000 +0200
+++ gcc-3.4.6/libstdc++-v3/src/Makefile.am	2007-09-30 14:34:26.000000000 +0200
@@ -210,6 +210,12 @@
 	  $(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) $(LDFLAGS) -o $@
 
 
+install-exec-local:
+ifeq ($(enable_shared),yes)
+	$(AR) cru libstdc++_pic.a .libs/*.o $(top_builddir)/libsupc++/*.o
+	$(INSTALL_DATA) libstdc++_pic.a $(DESTDIR)$(toolexeclibdir)
+endif
+
 # Added bits to build debug library.
 if GLIBCXX_BUILD_DEBUG
 all-local: build_debug
diff -r -u -N gcc-3.4.6_orig/libstdc++-v3/src/Makefile.in gcc-3.4.6/libstdc++-v3/src/Makefile.in
--- gcc-3.4.6_orig/libstdc++-v3/src/Makefile.in	2007-09-30 14:28:34.000000000 +0200
+++ gcc-3.4.6/libstdc++-v3/src/Makefile.in	2007-09-30 14:34:26.000000000 +0200
@@ -592,7 +592,7 @@
 
 install-data-am: install-data-local
 
-install-exec-am: install-toolexeclibLTLIBRARIES
+install-exec-am: install-toolexeclibLTLIBRARIES install-exec-local
 
 install-info: install-info-am
 
@@ -625,6 +625,7 @@
 	distclean-tags distdir dvi dvi-am info info-am install \
 	install-am install-data install-data-am install-data-local \
 	install-exec install-exec-am install-info install-info-am \
+	install-exec-local \
 	install-man install-strip install-toolexeclibLTLIBRARIES \
 	installcheck installcheck-am installdirs maintainer-clean \
 	maintainer-clean-generic mostlyclean mostlyclean-compile \
@@ -709,6 +710,13 @@
 install_debug:
 	(cd ${debugdir} && $(MAKE) \
 	toolexeclibdir=$(glibcxx_toolexeclibdir)/debug install)
+
+install-exec-local:
+ifeq ($(enable_shared),yes)
+	$(AR) cru libstdc++_pic.a .libs/*.o $(top_builddir)/libsupc++/*.o
+	$(INSTALL_DATA) libstdc++_pic.a $(DESTDIR)$(toolexeclibdir)
+endif
+
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
 .NOEXPORT:
