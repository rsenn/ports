diff -ruN bash-3.2_orig/BashDiff.log bash-3.2/BashDiff.log
--- bash-3.2_orig/BashDiff.log	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/BashDiff.log	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,276 @@
+NOTES:
+======
+
+1.  Copyright (c) 2003-2007 by William Park <opengeometry@yahoo.ca>.
+
+
+2.  http://freshmeat.net/projects/bashdiff/		-- announcement
+    http://home.eol.ca/~parkw/index.html#bashdiff	-- docs
+    http://home.eol.ca/~parkw/bashdiff/			-- download
+
+
+3.  To add *.def files as C source files,
+	ctags -R --langmap=c:+.def .
+    or from top directory,
+	make tags
+
+
+4.  These files are identical and should be hard linked:
+	builtins/subroutines.[ch]
+	examples/loadables/william/subroutines.[ch]
+
+
+LOGS:
+=====
+
+1.12
+    - added ${var|-}
+    - cleaned up ${var|...} code, so that string and array variables uses same
+      code, if the meaning applies to string variable.
+
+1.13
+    - corrected 'arraycat' helpfile.
+    - added DESTDIR to ./examples/loadables/william/Makefile
+    - added 'install-bin-strip' to ./Makefile
+
+1.14
+    - touched up '${var|...}' helpfile
+    - corrected typo in 'arraycat' helpfile
+    - added ${var|.strip}, ${var|.upper}, ${var|.lower}, ${var|.capitalize},
+      ${var|.swapcase}, ${var|.rev}, ${var|.strfry},
+    - added ${var|-regex}, ${var|+regex}.
+
+1.15
+    - added ${var|.singlequote}, ${var|.doublequote}, ${var|.backslashquote},
+      ${var|.ansicquote}
+    - added 'pp_read' for reading from positional parameters or array.
+    - added ${var|.capwords}, ${var|.title}
+    - added 'isnumber letter'
+    - added ${var|,sep} for joining elements into a single concatenated string.
+
+1.16
+    - added 'pp_uniq', 'pp_collapse'
+    - added ${var|.basename}, ${var|.dirname}.  dirname(3) gives wrong answer in
+      glibc-2.3.2/gcc-3.2.3
+    - cleaned up 'array', and removed redundant features.
+    - cleaned up ${var|.method} code.
+    - added ${var|[i]} variation to ${var|[a:b]}
+    - ${*|[a:b]} and ${*|[i]} was off by one.  Fixed.
+
+1.17
+    - cleaned up 'match' and internal regex_match().
+    - added ${var|.ascii}
+    - removed 'chnumber', since ${var|.lower}, ${var|.upper}, ${var|.ascii} does
+      the same thing.
+    - added 'binary' to convert decimal to binary (also, octal/hex) with
+      zero-padding.
+    - reintroduced ${var|<n}, ${var|>n}
+    - changed 'gdbm' to return immediately on error or test failure.
+    - added 'pp_trim' to delete from the end.
+
+1.18
+    - change to single .diff file, instead of 2.
+    - for convenience, 'Lsql', 'Msql', and 'Psql' returns variables NF and NR
+      from the last query result.
+    - 'raise' now uses string exception which is easier to remember than
+      integer.
+    - ${var|,sep} is now symmetrical split/join.  ${string|,sep} will split the
+      string into list, and ${list|,sep} will join the list into single string.
+      "${string|,sep}" follows "$@" behaviour.  ${string|,} will split CSV
+      format.
+    - ${var|.csvdequote} and ${var|.csvquote} will quote to and unquote from CSV
+      format.
+    - ${var|+regex} and ${var|-regex} now do regex splitting.  Builtin 'array'
+      is no longer needed, hence, has been removed.
+    - removed ${var|.basename}, ${var|.dirname}.
+
+1.19
+    - added -C option 'read' for CSV format line.
+    - added ./configure options to exclude PostgreSQL, MySQL, SQLite, GDBM, and
+      Expat interfaces.  So, ./configure --disable-postgresql --disable-mysql
+      --disable-sqlite --disable-gdbm --disable-expat will result in minimal
+      patch.
+    - FIX: segfault was occuring in build_eval_string() in subroutines.c
+    - changed 'basp' and 'xml' to read from file/stdin, instead of string.  So,
+      'basp < file' or 'basp file...'.  Same with 'xml'.
+
+1.20
+    - read BUFSIZ chars (instead of 128 chars) from file or stdin.
+    - added ${var|.htmlquote}, ${var|.urldequote}
+    - added CSV support (-C option) within Awk emulation (-A option) of 'read'
+      builtin.  Undecided until now, because Awk doesn't do CSV.
+    - cleaned up 'pp_*' code internally to handle indexes better.
+    - added ${var|@key} which does cheap emulation of associative array lookup,
+      using linear key/value pairs.
+    - added -[Ddui] options to 'pp_uniq', similar to options to 'uniq' command.
+
+1.21
+    - added Libwebserver-0.6.0-18 interface using 'webserver' and 'ClientInfo'
+      builtins
+    - fixed blank output in 'vplot'
+    - fixed dangling pointers in ${var|?command}
+    - added more doc to http://home.eol.ca/~parkw/index.html#bashdiff
+    - relaxed command syntax in 'xml', 'arraymap', and 'webserver'.  But,
+      ${var|command} and ${var|?command} are strictly checked.
+    
+1.22
+    - added check for Libwebserver-0.5.3/0.6.0-19 during compile
+    - fixed Maikefile.in and lib/readline/Makefile.in, so that 'make -j3' works
+    - documentations have been re-organized, and added lots of new things
+    - added 'herefile', which is same as 'cat', except that input is considered
+      as here-document and expanded as such.
+    - added '<<<<' operator for here-file.
+
+1.23
+    - changed <<+ to strip both spaces and tabs (8 spaces).
+    - changed 'xml' to 'expat'.
+    - added 'gtk' builtin, which is interface to GTK+ 2.6.1 using XML syntax for
+      the layout.
+
+1.24
+    - more GTK+ widgets
+
+1.25
+    - fixed --disable-gtk2 omission in ./configure.in
+
+1.26
+    - GTK+ 
+	- child windows are destroyed when the parent window is deleted
+	- will check for toplevel window before running gtk_main(),
+	- enabled callbacks to set shell variables and run shell commands.
+
+1.27
+    - fixed ${var|,}.  'regex', 'glob', and 'sep' are now expanded, and
+      expansion of empty string returned NULL, which removed the expression.
+    - removed Python interface, which has not been used for long time.
+
+1.28
+    - fixed 'read -D -n'.  \r wasn't being removed if -n is specified, even
+      though complete line is read.
+    - added 'rpn', RPN calculator.
+    - removed `=...` $(=...), since 'rpn' can do floating-point much better.
+
+1.29
+    - added statistic, linear regression, numerical integration, and root solver
+      to 'rpn' calculator.
+
+1.30
+    - removed 'hms->hour' and 'hour->hms', and added 'hms++' and 'hms--' to
+      add/substract H, M, S.sss separately.  Separation is needed to avoid
+      roundoff errors.
+    - added D (day) to 'hms++' and 'hms--'.
+
+1.31
+    - added XML_TAG_STACK in 'expat' to keep track of just the tag names.
+    - fixed typo in website documentation.  'patch -p1' should be 'patch -p2'.
+
+1.32
+    - added 'strinterval' builtin to extract substring with 'begin' and 'end'
+      pattern.
+    - updated doc for 'basp'... input is read from FILE or stdin.
+    - fixed typo in argv_from_list() function in 'subroutines.c' which caused
+      'vplot' to segfault when data points are given on command line.
+
+1.33
+    - 'Msql' builtin (MySQL interface) is removed, due to name clash in
+      MySQL-4.1.14 (my_list.h) for list functions.
+
+1.34
+    - fixed segfault in ${var|>n} and ${var|<n}.  It was returning unterminated
+      string.
+    - add ability to read from stdin for 'vplot', 'tostring', 'tonumber',
+      'binary'.
+
+1.35
+    - add -[io] options for base 2 to 36 to 'binary'.  Remove -[oOhHd] options.
+    - generate negative integers in {a..b}, in keeping with default Bash-3.0
+      behaviour.
+    - add -a to 'vplot' to preserve aspect ratio when plotting.
+
+1.36
+    - add -hv (instead of -a) to 'vplot' to preserve horizontal and vertical
+      aspect separately.
+    
+1.37
+    - add 'crypt' builtin, a wrapper for crypt(3).
+
+1.38
+    - 'strcat' and 'strcpy' can now access (already existing) positional
+      parameter.
+    - upgraded PostgreSQL from 7.4.3 (libpg.so.3) to 8.1.4 (libpg.so.4).  No
+      change in my code.
+
+1.39
+    - 'strcat' and 'strcpy' read from stdin or file.
+    - added 'image' option to 'gtk' builtin (patch from Raul Suarez
+      <rarsa@yahoo.com>, KWLUG)
+
+1.40
+    - add 'creditcard' to check for typos in credit card number, using Modulus
+      10 method.
+    - add 'vcat' to do "variable cat" as opposed to "file cat".
+
+1.41
+    - add 'match -F ...' option for fixed string pattern (think grep -F).
+    - add ability to specify weight to 'creditcard', and add -c option to just
+      print the check-digit.
+
+1.42
+    - fixed segfault when running pp_sort/pp_uniq on empty parameters.  argv[]
+      was returning NULL, when it should return argv[0]=NULL.
+
+1.43
+    - add ${var|.regexquote} for escaping non-alphanumeric.
+    - add ${var|.strip0} for removing leading 0s.
+    - add rint(3) wrapper to 'rpn' builtin.
+    - ${var|.cent}, ${var|.dollar} to handle implied decimal.  Eg.
+	123 = $1.23
+	1.23 = $1.23
+    - For some reason, strfry(3) is causing segfault.  So, commented out.
+    - add 'readtrack' builtin for extracting track 1 and 2 from magnetic card
+      swipe.
+    - add 'vcat', 'vset', and 'vfile' builtins
+    - add 'strstr', 'strspn', 'strcspn' builtins, wrapper for strstr(3),
+      strspn(3), and strcspn(3).
+    - change 'match' API -- now includes prefix/suffix strings.
+    - add 'protobase' builtin
+    - add 'pp_prune' to remove empty array elements, while preserving index.
+    - add 'maskcard' builtin
+
+1.44
+    - add 'multi' builtin for extracting Multi response into ANS, RCP, RCT, and
+      for writing fixed-width request string.
+    - add ${var|.base36} to convert oct/dec/hex to base36 [0-9A-Z].
+    - change syntax for 'arrayzip', 'arrayunzip'.  No longer need array option.
+      Use 'vcat' and 'vset' instead.
+    - add 'fixedstring' for cutting fixed-width string segment
+    - modified ${var|@} (empty string after '@') to serialize array variable
+    - change API for 'match' and 'case ... in' for regex matching.  Include
+      prefix and suffix.
+    - replaced 'readtrack' with 'cardswipe' which read/write track 1 and
+      2 data.
+
+
+TODO:
+=====
+
+- vcursor init name...
+  vcursor up
+  vcursor down
+  vcursor top
+  vcursor bottom
+  vcursor insert
+  vcursor append
+  vcursor replace
+  vcursor delete
+
+- pcursor init
+  pcursor up
+  pcursor down
+  pcursor top
+  pcursor bottom
+  pcursor insert
+  pcursor append
+  pcursor replace
+  pcursor delete
+
--- bash-3.2_orig/Makefile.in	2008-04-05 08:42:57.000000000 +0000
+++ bash-3.2/Makefile.in	2008-04-05 08:52:20.000000000 +0000
@@ -125,7 +125,7 @@
 CFLAGS_FOR_BUILD = @CFLAGS_FOR_BUILD@ @CROSS_COMPILE@
 CPPFLAGS = @CPPFLAGS@
 CPPFLAGS_FOR_BUILD = @CPPFLAGS_FOR_BUILD@
-LOCAL_CFLAGS = @LOCAL_CFLAGS@ ${DEBUG} ${MALLOC_DEBUG}
+LOCAL_CFLAGS = @LOCAL_CFLAGS@ ${DEBUG} ${MALLOC_DEBUG} $(GTK2_CFLAGS) $(GLIB2_CFLAGS)
 DEFS = @DEFS@ -DLOCALSTATEDIR=\"$(localstatedir)\" -DBINDIR=\"$(bindir)\" -DSBINDIR=\"$(sbindir)\" -DTMPDIR=\"$(tmpdir)\" -DPROCDIR=\"$(procdir)\" -DDEVDIR=\"$(devdir)\" -DSYSCONFDIR=\"$(sysconfdir)\"
 LOCAL_DEFS = @LOCAL_DEFS@
 
@@ -462,11 +462,18 @@
 	       $(DEFSRC)/ulimit.def $(DEFSRC)/umask.def $(DEFSRC)/wait.def \
 	       $(DEFSRC)/getopts.def $(DEFSRC)/reserved.def \
 	       $(DEFSRC)/pushd.def $(DEFSRC)/shopt.def $(DEFSRC)/printf.def
+
 BUILTIN_C_SRC  = $(DEFSRC)/mkbuiltins.c $(DEFSRC)/common.c \
 		 $(DEFSRC)/evalstring.c $(DEFSRC)/evalfile.c \
-		 $(DEFSRC)/bashgetopt.c $(GETOPT_SOURCE)
+		 $(DEFSRC)/bashgetopt.c $(GETOPT_SOURCE) \
+		 $(DEFSRC)/subroutines.c
+# --William
+
 BUILTIN_C_OBJ  = $(DEFDIR)/common.o $(DEFDIR)/evalstring.o \
-		 $(DEFDIR)/evalfile.o $(DEFDIR)/bashgetopt.o
+		 $(DEFDIR)/evalfile.o $(DEFDIR)/bashgetopt.o \
+		 $(DEFDIR)/subroutines.o
+# --William
+
 BUILTIN_OBJS = $(DEFDIR)/alias.o $(DEFDIR)/bind.o $(DEFDIR)/break.o \
 	       $(DEFDIR)/builtin.o $(DEFDIR)/cd.o $(DEFDIR)/colon.o \
 	       $(DEFDIR)/command.o $(DEFDIR)/caller.o $(DEFDIR)/declare.o \
@@ -515,7 +522,9 @@
 		    lib/sh/Makefile lib/tilde/Makefile lib/malloc/Makefile \
 		    lib/termcap/Makefile examples/loadables/Makefile \
 		    examples/loadables/perl/Makefile support/Makefile \
-		    lib/intl/Makefile po/Makefile po/Makefile.in
+		    lib/intl/Makefile po/Makefile po/Makefile.in \
+		    examples/loadables/william/Makefile
+# --William
 
 # Keep GNU Make from exporting the entire environment for small machines.
 .NOEXPORT:
@@ -533,6 +542,49 @@
 	$(RM) $@
 	$(PURIFY) $(CC) -static $(BUILTINS_LDFLAGS) $(LIBRARY_LDFLAGS) $(LDFLAGS) -o $(Program).static $(OBJECTS) $(LIBS)
 
+
+################################################################################
+# Everything linked statically  --William
+#
+GDBM_LIB = @GDBM_LIB@
+EXPAT_LIB = @EXPAT_LIB@
+SQLITE_LIB = @SQLITE_LIB@
+POSTGRESQL_LIB = @POSTGRESQL_LIB@
+MYSQL_LIB = @MYSQL_LIB@
+LIBWEBSERVER_LIB = @LIBWEBSERVER_LIB@
+
+POSTGRESQL_LDFLAGS = @POSTGRESQL_LDFLAGS@
+MYSQL_LDFLAGS = @MYSQL_LDFLAGS@
+
+GTK2_LIBS = @GTK2_LIBS@
+GTK2_CFLAGS = @GTK2_CFLAGS@
+
+GLIB2_LIBS = @GLIB2_LIBS@
+GLIB2_CFLAGS = @GLIB2_CFLAGS@
+
+ALL_LIBS = $(GDBM_LIB) $(EXPAT_LIB) $(SQLITE_LIB) $(POSTGRESQL_LIB) $(MYSQL_LIB) $(LIBWEBSERVER_LIB) $(GTK2_LIBS) $(GLIB2_LIBS) -lm -lcrypt
+ALL_LDFLAGS = $(POSTGRESQL_LDFLAGS) $(MYSQL_LDFLAGS)
+
+WILLIAM_DIR = $(dot)/examples/loadables/william
+
+bash+william:  .build $(OBJECTS) $(WILLIAM_DIR)/libbuiltins.a $(LIBDEP)
+	$(RM) $@
+	$(PURIFY) $(CC) -L$(WILLIAM_DIR) $(LIBRARY_LDFLAGS) $(LDFLAGS) $(ALL_LDFLAGS) -o $@ $(OBJECTS) $(ALL_LIBS) $(LIBS)
+	ls -l $@
+	size $@
+
+$(WILLIAM_DIR)/libbuiltins.a:
+	@(cd $(WILLIAM_DIR) && $(MAKE) $(MFLAGS) clean && \
+	    $(MAKE) $(MFLAGS) libbuiltins.a) || exit 1
+
+install-bin install-bin-strip:
+	$(INSTALL_PROGRAM) -s $(INSTALLMODE) bash+william $(DESTDIR)$(bindir)/bash+william
+	$(INSTALL_PROGRAM) -s $(INSTALLMODE) $(Program) $(DESTDIR)$(bindir)/$(Program)
+	$(INSTALL_SCRIPT) $(INSTALLMODE2) bashbug $(DESTDIR)$(bindir)/bashbug
+#
+################################################################################
+
+
 .build:	$(SOURCES) config.h Makefile version.h $(VERSPROG)
 	@echo
 	@echo "	  ***********************************************************"
@@ -757,11 +809,17 @@
 .PHONY: basic-clean clean realclean maintainer-clean distclean mostlyclean maybe-clean
 
 LIB_SUBDIRS = ${RL_LIBDIR}  ${HIST_LIBDIR} ${TERM_LIBDIR} ${GLOB_LIBDIR} \
-		${INTL_LIBDIR} ${TILDE_LIBDIR} ${ALLOC_LIBDIR} ${SH_LIBDIR}
+		${INTL_LIBDIR} ${TILDE_LIBDIR} ${ALLOC_LIBDIR} ${SH_LIBDIR} \
+		examples/loadables/william
+# Remove loadables also.  --William 
 
 basic-clean:
 	$(RM) $(OBJECTS) $(Program) bashbug
-	$(RM) .build .made version.h 
+	$(RM) .build .made version.h  # pathnames.h
+	$(RM) bash+william
+# Add 'bash+william', because it should be removed when 'bash' is removed.
+# --William
+
 
 clean:	basic-clean
 	( cd $(DOCDIR) && $(MAKE) $(MFLAGS) $@ )
@@ -792,6 +850,10 @@
 	-( cd $(PO_DIR) ; $(MAKE) $(MFLAGS) DESTDIR=$(DESTDIR) $@ )
 	$(RM) $(CREATED_CONFIGURE) tags TAGS 
 	$(RM) $(CREATED_SUPPORT) Makefile $(CREATED_MAKEFILES) pathnames.h
+	$(RM) pathnames.h
+# Since pathnames.h is created when Makefiles are created, it should be
+# removed when Makefiles are removed.  This enables 'make clean; make -j3' to
+# work.  --William
 
 maintainer-clean:	basic-clean
 	@echo This command is intended for maintainers to use.
@@ -805,7 +867,11 @@
 	done
 	-( cd $(PO_DIR) ; $(MAKE) $(MFLAGS) DESTDIR=$(DESTDIR) $@ )
 	$(RM) $(CREATED_CONFIGURE) $(CREATED_MAKEFILES)
-	$(RM) $(CREATED_SUPPORT) Makefile pathnames.h
+	$(RM) $(CREATED_SUPPORT) Makefile
+	$(RM) pathnames.h
+# Since pathnames.h is created when Makefiles are created, it should be
+# removed when Makefiles are removed.  This enables 'make clean; make -j3' to
+# work.  --William
 
 maybe-clean:
 	-if test "X$(topdir)" != "X$(BUILD_DIR)" ; then \
@@ -1039,6 +1105,12 @@
 version.o:  conftypes.h patchlevel.h version.h
 xmalloc.o: config.h bashtypes.h ${BASHINCDIR}/ansi_stdlib.h error.h
 
+# --William
+subst.o: subst.2.c $(DEFSRC)/subroutines.h
+braces.o: braces.2.c $(DEFSRC)/subroutines.h
+execute_cmd.o: $(DEFSRC)/subroutines.h
+redir.o: $(DEFSRC)/subroutines.h
+
 # job control
 
 jobs.o: config.h bashtypes.h trap.h ${BASHINCDIR}/filecntl.h input.h ${BASHINCDIR}/shtty.h
@@ -1439,6 +1511,10 @@
 builtins/echo.o: $(DEFSRC)/echo.def
 builtins/enable.o: $(DEFSRC)/enable.def
 builtins/eval.o: $(DEFSRC)/eval.def
+
+# --William
+builtins/subroutines.o: $(DEFSRC)/subroutines.c $(DEFSRC)/subroutines.h
+
 builtins/exec.o: $(DEFSRC)/exec.def
 builtins/exit.o: $(DEFSRC)/exit.def
 builtins/fc.o: $(DEFSRC)/fc.def
--- bash-3.2_orig/array.c	2008-04-05 08:42:57.000000000 +0000
+++ bash-3.2/array.c	2008-04-05 08:43:09.000000000 +0000
@@ -263,6 +263,14 @@
 
 	a->max_index = element_index(a->head->prev);
 
+	/* Fix:  If array is empty and you shift 5, then 'max_index' increases
+	 * from -1 to 4.  But, you still have empty array (if S is NULL) or have
+	 * only element (ie. array[0]=S).  Later on, array_insert() cannot find
+	 * place to insert for array[1] to array[4].  Adjust 'max_index' after
+	 * all other indexes have been incremented.  --William
+	 */
+	a->max_index = element_index (a->head->prev);
+
 	return (a->num_elements);
 }
 
--- bash-3.2_orig/braces.2.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/braces.2.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,178 @@
+/*******************************************************************************
+ * Okey, found a standalone brace expression without ','.
+ *
+ * For {a..b}, generate integer sequence from 'a' to 'b' inclusive, using either
+ * {a,a+1,...,b-1,b} or {a,a-1,...,b+1,b}.  If 'a' or 'b' has leading 0, then
+ * zero pad the numbers.  The format size is the maximum size of 'a' or 'b'.
+ * Eg.
+ *     {1..5}              --> {1,2,3,4,5}
+ *     {05..01}            --> {05,04,03,02,01}
+ * 
+ * If 'a' or 'b' is a regular shell variable (not positional parameter or array
+ * element), then replace it with its value $a or $b.  If 'a' or 'b' starts with
+ * '!', then indirect substitution will be tried, similiar to ${!a} or ${!b}.
+ * If 'a' or 'b' is '#', then replace it with $#.  In any case, if the final
+ * 'a..b' is pure number, then generate the corresponding integer sequence.  Eg.
+ *     {x..y}              --> seq $x $y
+ *     {!x..!y}            --> seq ${!x} ${!y}
+ *     {1..#}              --> seq 1 $#
+ * 
+ * If the expression is 'a--b', where 'a' and 'b' are single letters, then
+ * generate letter sequence from 'a' to 'b'.  Uppercase and lowercase can be
+ * mixed, and the output will consist of letters only.  Eg.
+ *     {a--c}              --> {a,b,c}
+ *     {Z--c}              --> {Z,a,b,c}
+ * 
+ * For {**} or {##}, do brace expansion using positional parameters, ie.
+ * {$1,$2,...} or {1,2,...$#} respectively.  If there are no parameters, then
+ * they expand to nothing, that is, they are removed along with preamble and
+ * postamble.
+ * 
+ * For {^var}, do brace expansion using array elements.  If 'var' is empty
+ * array, then remove the pattern.
+ * 
+ * Otherwise, return the original string back to shell as is, like before.
+ *
+ * --William
+ */
+
+#include "builtins/subroutines.h"
+
+
+static char **
+expand_seqterm (amble, alen)	/* replacement of expand_seqterm() */
+    char *amble;
+    size_t alen;
+{
+    char **tack, *a, *b, *t;
+    int zeropad, compareflag, x, y, i, n;
+    size_t size;
+    SHELL_VAR *var;
+
+    tack = (char **)NULL;
+    a = b = (char *)NULL;
+
+    if (t = strstr (amble, "--")) {
+	a = substring (amble, 0, t - amble);
+	b = substring (amble, t - amble + 2, alen);
+	if (! (strlen (a) == 1 && strlen (b) == 1 && ISLETTER (*a) && ISLETTER (*b)))
+	    goto New_Tack;
+
+	/* By this point, 'a' and 'b' are single char and lower/upper case.
+	*/
+	n = abs (*b - *a) + 1;
+	tack = strvec_create (n + 1);
+	i = 0;
+	do {
+	    tack[i++] = savestring (a);
+	    if (*a == *b) {
+		tack[i] = (char *)NULL;
+		break;
+	    }
+	    else if (*a < *b)
+		do
+		    ++*a;
+		while (! ISLETTER (*a));	/* skip non-letters */
+	    else if (*a > *b)
+		do
+		    --*a;
+		while (! ISLETTER (*a));	/* skip non-letters */
+	} while (1);
+    }
+    else if (t = strstr (amble, "..")) {
+	a = substring (amble, 0, t - amble);
+	b = substring (amble, t - amble + 2, alen);
+	zeropad = 0;
+
+	if (legal_identifier (a) && (t = get_string_value (a))) {
+	    FREE (a);
+	    a = savestring (t);
+	}
+	else if (*a == '!') {
+	    if (legal_identifier (a + 1) && (t = get_string_value (a + 1))) 
+		if (legal_identifier (t) && (t = get_string_value (t))) {
+		    FREE (a);
+		    a = savestring (t);
+		}
+	}
+	else if (*a == '#' && a[1] == '\0') {
+	    FREE (a);
+	    a = itos (number_of_args ());
+	}
+
+	if (legal_identifier (b) && (t = get_string_value (b))) {
+	    FREE (b);
+	    b = savestring (t);
+	}
+	else if (*b == '!') {
+	    if (legal_identifier (b + 1) && (t = get_string_value (b + 1))) 
+		if (legal_identifier (t) && (t = get_string_value (t))) {
+		    FREE (b);
+		    b = savestring (t);
+		}
+	}
+	else if (*b == '#' && b[1] == '\0') {
+	    FREE (b);
+	    b = itos (number_of_args ());
+	}
+
+	/* By this point, 'a' and 'b' must be all positive/negative integers.
+	 */
+	if (! legal_integer (a, &x) || ! legal_integer (b, &y))
+	    goto New_Tack;
+
+	if ((a[0] == '0' && a[1]) || (a[0] == '-' && a[1] == '0' && a[2]) ||
+	    (b[0] == '0' && b[1]) || (b[0] == '-' && b[1] == '0' && b[2]))
+	    zeropad = 1;
+
+	size = imax (strlen (a), strlen (b));
+	n = abs (y - x) + 1;
+	tack = strvec_create (n + 1);
+	i = 0;
+	do {
+	    t = (char *)xmalloc (size + 1);	/* number + \0 */
+	    if (zeropad)
+		sprintf (t, "%0*d", size, x);
+	    else
+		sprintf (t, "%d", x);
+	    tack[i++] = t;
+	    if (x == y) {
+		tack[i] = (char *)NULL;
+		break;
+	    }
+	    else if (x < y)
+		++x;
+	    else if (x > y)
+		--x;
+	} while (1);
+    }
+    else if (amble[0] == '*' && amble[1] == '*' && amble[2] == '\0') {	/* {**} */
+	tack = argv_from_parameters (1 /* alloc */);
+    }
+    else if (amble[0] == '#' && amble[1] == '#' && amble[2] == '\0') {	/* {##} */
+	n = number_of_args();
+	tack = strvec_create (n + 1);
+	for (i = 0; i < n; i++)
+	    tack[i] = itos (i+1);
+	tack[i] = (char *)NULL;
+    }
+#if defined (ARRAY_VARS)
+    else if (amble[0] == '^') {		/* {^array} */
+	b = substring (amble, 1, alen);
+	var = find_variable (b);
+	if (var && array_p (var)) {
+	    tack = argv_from_array (array_cell (var), 1 /* alloc */);
+	    if (tack == 0) {	/* if empty, remove the pattern */
+		tack = strvec_create (1);
+		tack[0] = (char *)NULL;
+	    }
+	}
+    }
+#endif
+
+New_Tack:
+    FREE (a);
+    FREE (b);
+    return (tack);	/* NULL or new tack */
+}
+/******************************************************************************/
--- bash-3.2_orig/braces.c	2008-04-05 08:42:57.000000000 +0000
+++ bash-3.2/braces.c	2008-04-05 08:43:09.000000000 +0000
@@ -298,6 +298,8 @@
   return (result);
 }
 
+
+#if 0			/* replaced by braces.2.c  --William */
 #define ST_BAD	0
 #define ST_INT	1
 #define ST_CHAR	2
@@ -408,6 +410,10 @@
 
   return (result);
 }
+#else
+#include "braces.2.c"		/* --William */
+#endif
+
 
 /* Start at INDEX, and skip characters in TEXT. Set INDEX to the
    index of the character matching SATISFY.  This understands about
--- bash-3.2_orig/builtins/Makefile.in	2008-04-05 08:42:57.000000000 +0000
+++ bash-3.2/builtins/Makefile.in	2008-04-05 08:43:09.000000000 +0000
@@ -149,7 +149,9 @@
 	exit.o fc.o fg_bg.o hash.o help.o history.o jobs.o kill.o let.o \
 	pushd.o read.o return.o set.o setattr.o shift.o source.o \
 	suspend.o test.o times.o trap.o type.o ulimit.o umask.o \
-	wait.o getopts.o shopt.o printf.o getopt.o bashgetopt.o complete.o
+	wait.o getopts.o shopt.o printf.o getopt.o bashgetopt.o complete.o \
+	subroutines.o
+# --William
 
 CREATED_FILES = builtext.h builtins.c psize.aux pipesize.h
 
@@ -253,6 +255,10 @@
 echo.o: echo.def
 enable.o: enable.def
 eval.o: eval.def
+
+# --William
+subroutines.o: subroutines.c subroutines.h
+
 exec.o: exec.def
 exit.o: exit.def
 fc.o: fc.def
--- bash-3.2_orig/builtins/break.def	2008-04-05 08:42:57.000000000 +0000
+++ bash-3.2/builtins/break.def	2008-04-05 08:43:09.000000000 +0000
@@ -130,3 +130,51 @@
 
   return (loop_level);
 }
+
+
+/*******************************************************************************
+ * Raise string exception for try-block.  --William
+ */
+$BUILTIN raise
+$FUNCTION raise_builtin
+$SHORT_DOC raise [exception]
+Raise string exception (default '') which will be caught in 'try' block.
+$END
+
+char *exception = (char *)NULL;	
+int try_level = 0;		/* similar to loop_level above */
+
+#include "bashgetopt.h"		/* loptend */
+
+
+int
+raise_builtin (list)
+    WORD_LIST *list;
+{
+    if (no_options (list))
+	return (EX_BADUSAGE);
+    list = loptend;             /* skip over possible `--' */
+
+    if (exception) {
+	builtin_error ("exception is already raised.");
+	return (EXECUTION_FAILURE);
+    }
+    if (try_level == 0) {
+#if defined (BREAK_COMPLAINS)
+	if (posixly_correct == 0)
+	    builtin_error ("meaningful only in a `try' block");
+#endif
+	return (EXECUTION_SUCCESS);
+    }
+    if (list == 0) {		/* 0 argument */
+	exception = savestring ("");
+	return (EXECUTION_SUCCESS);
+    }
+    if (list->next == 0) {	/* 1 argument */
+	exception = savestring (list->word->word);
+	return (EXECUTION_SUCCESS);
+    }
+    builtin_usage ();		/* 2 or more arguments */
+    return (EX_BADUSAGE);
+}
+/******************************************************************************/
--- bash-3.2_orig/builtins/echo.def	2008-04-05 08:42:57.000000000 +0000
+++ bash-3.2/builtins/echo.def	2008-04-05 08:43:09.000000000 +0000
@@ -57,6 +57,17 @@
 with the -E option.
 $END
 
+
+/* --William */
+$BUILTIN echo -D
+$DOCNAME echo_DOS
+$DEPENDS_ON V9_ECHO
+$SHORT_DOC echo [-...] [-D] [arg ...]
+The following options are added:
+    -D      print DOS line with trailing '\r\n' instead of normal '\n'.
+$END
+
+
 $BUILTIN echo
 $FUNCTION echo_builtin
 $DEPENDS_ON !V9_ECHO
@@ -65,7 +76,7 @@
 $END
 
 #if defined (V9_ECHO)
-#  define VALID_ECHO_OPTIONS "neE"
+#  define VALID_ECHO_OPTIONS "neED"	/* add D  --William */
 #else /* !V9_ECHO */
 #  define VALID_ECHO_OPTIONS "n"
 #endif /* !V9_ECHO */
@@ -93,6 +104,8 @@
   int display_return, do_v9, i, len;
   char *temp, *s;
 
+  int echo_DOS = 0;	/* print DOS line  --William */
+
   do_v9 = xpg_echo;
   display_return = 1;
 
@@ -132,6 +145,11 @@
 	    case 'E':
 	      do_v9 = 0;
 	      break;
+
+	    case 'D':		/* print DOS line  --William */
+		echo_DOS = 1;
+		break;
+
 #endif /* V9_ECHO */
 	    default:
 	      goto just_echo;	/* XXX */
@@ -173,8 +191,11 @@
 	putchar(' ');
     }
 
-  if (display_return)
-    putchar ('\n');
+  if (display_return) {
+      if (echo_DOS)		/* \r just before \n  --William */
+	  putchar ('\r');
+      putchar ('\n');		/* original code */
+  }
   fflush (stdout);
   if (ferror (stdout))
     {
--- bash-3.2_orig/builtins/mk-17932	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/builtins/mk-17932	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,1284 @@
+/* builtins.c -- the built in shell commands. */
+
+/* This file is manufactured by ./mkbuiltins, and should not be
+   edited by hand.  See the source to mkbuiltins for details. */
+
+/* Copyright (C) 1987-2002 Free Software Foundation, Inc.
+
+   This file is part of GNU Bash, the Bourne Again SHell.
+
+   Bash is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   Bash is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Bash; see the file COPYING.  If not, write to the Free
+   Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
+
+/* The list of shell builtins.  Each element is name, function, flags,
+   long-doc, short-doc.  The long-doc field contains a pointer to an array
+   of help lines.  The function takes a WORD_LIST *; the first word in the
+   list is the first arg to the command.  The list has already had word
+   expansion performed.
+
+   Functions which need to look at only the simple commands (e.g.
+   the enable_builtin ()), should ignore entries where
+   (array[i].function == (sh_builtin_func_t *)NULL).  Such entries are for
+   the list of shell reserved control structures, like `if' and `while'.
+   The end of the list is denoted with a NULL name field. */
+
+#include "../builtins.h"
+#include "builtext.h"
+#include "bashintl.h"
+
+struct builtin static_shell_builtins[] = {
+#if defined (ALIAS)
+  { "alias", alias_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | ASSIGNMENT_BUILTIN, alias_doc,
+     "alias [-p] [name[=value] ... ]", (char *)NULL },
+#endif /* ALIAS */
+#if defined (ALIAS)
+  { "unalias", unalias_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, unalias_doc,
+     "unalias [-a] name [name ...]", (char *)NULL },
+#endif /* ALIAS */
+#if defined (READLINE)
+  { "bind", bind_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, bind_doc,
+     "bind [-lpvsPVS] [-m keymap] [-f filename] [-q name] [-u name] [-r keyseq] [-x keyseq:shell-command] [keyseq:readline-function or readline-command]", (char *)NULL },
+#endif /* READLINE */
+  { "break", break_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | SPECIAL_BUILTIN, break_doc,
+     "break [n]", (char *)NULL },
+  { "continue", continue_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | SPECIAL_BUILTIN, continue_doc,
+     "continue [n]", (char *)NULL },
+  { "raise", raise_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, raise_doc,
+     "raise [exception]", (char *)NULL },
+  { "builtin", builtin_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, builtin_doc,
+     "builtin [shell-builtin [arg ...]]", (char *)NULL },
+#if defined (DEBUGGER)
+  { "caller", caller_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, caller_doc,
+     "caller [EXPR]", (char *)NULL },
+#endif /* DEBUGGER */
+  { "cd", cd_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, cd_doc,
+     "cd [-L|-P] [dir]", (char *)NULL },
+  { "pwd", pwd_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, pwd_doc,
+     "pwd [-PL]", (char *)NULL },
+  { ":", colon_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | SPECIAL_BUILTIN, colon_doc,
+     ":", (char *)NULL },
+  { "true", colon_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, true_doc,
+     "true", (char *)NULL },
+  { "false", false_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, false_doc,
+     "false", (char *)NULL },
+  { "command", command_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, command_doc,
+     "command [-pVv] command [arg ...]", (char *)NULL },
+  { "declare", declare_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | ASSIGNMENT_BUILTIN, declare_doc,
+     "declare [-afFirtx] [-p] [name[=value] ...]", (char *)NULL },
+  { "typeset", declare_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | ASSIGNMENT_BUILTIN, typeset_doc,
+     "typeset [-afFirtx] [-p] name[=value] ...", (char *)NULL },
+  { "local", local_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | ASSIGNMENT_BUILTIN, local_doc,
+     "local name[=value] ...", (char *)NULL },
+#if defined (V9_ECHO)
+  { "echo", echo_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, echo_doc,
+     "echo [-neE] [arg ...]", (char *)NULL },
+#endif /* V9_ECHO */
+#if defined (V9_ECHO)
+  { "echo -D", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, echo_DOS_doc,
+     "echo [-...] [-D] [arg ...]", (char *)NULL },
+#endif /* V9_ECHO */
+#if !defined (V9_ECHO)
+  { "echo", echo_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, echo_doc,
+     "echo [-n] [arg ...]", (char *)NULL },
+#endif /* !V9_ECHO */
+  { "enable", enable_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, enable_doc,
+     "enable [-pnds] [-a] [-f filename] [name ...]", (char *)NULL },
+  { "eval", eval_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | SPECIAL_BUILTIN, eval_doc,
+     "eval [arg ...]", (char *)NULL },
+  { "getopts", getopts_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, getopts_doc,
+     "getopts optstring name [arg]", (char *)NULL },
+  { "exec", exec_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | SPECIAL_BUILTIN, exec_doc,
+     "exec [-cl] [-a name] file [redirection ...]", (char *)NULL },
+  { "exit", exit_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | SPECIAL_BUILTIN, exit_doc,
+     "exit [n]", (char *)NULL },
+  { "logout", logout_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, logout_doc,
+     "logout", (char *)NULL },
+#if defined (HISTORY)
+  { "fc", fc_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, fc_doc,
+     "fc [-e ename] [-nlr] [first] [last] or fc -s [pat=rep] [cmd]", (char *)NULL },
+#endif /* HISTORY */
+#if defined (JOB_CONTROL)
+  { "fg", fg_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, fg_doc,
+     "fg [job_spec]", (char *)NULL },
+#endif /* JOB_CONTROL */
+#if defined (JOB_CONTROL)
+  { "bg", bg_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, bg_doc,
+     "bg [job_spec]", (char *)NULL },
+#endif /* JOB_CONTROL */
+  { "hash", hash_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, hash_doc,
+     "hash [-lr] [-p pathname] [-dt] [name ...]", (char *)NULL },
+#if defined (HELP_BUILTIN)
+  { "help", help_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, help_doc,
+     "help [-s] [pattern ...]", (char *)NULL },
+#endif /* HELP_BUILTIN */
+#if defined (HISTORY)
+  { "history", history_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, history_doc,
+     "history [-c] [-d offset] [n] or history -awrn [filename] or history -ps arg [arg...]", (char *)NULL },
+#endif /* HISTORY */
+#if defined (JOB_CONTROL)
+  { "jobs", jobs_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, jobs_doc,
+     "jobs [-lnprs] [jobspec ...] or jobs -x command [args]", (char *)NULL },
+#endif /* JOB_CONTROL */
+#if defined (JOB_CONTROL)
+  { "disown", disown_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, disown_doc,
+     "disown [-h] [-ar] [jobspec ...]", (char *)NULL },
+#endif /* JOB_CONTROL */
+  { "kill", kill_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, kill_doc,
+     "kill [-s sigspec | -n signum | -sigspec] [pid | job]... or kill -l [sigspec]", (char *)NULL },
+  { "let", let_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, let_doc,
+     "let arg [arg ...]", (char *)NULL },
+  { "read", read_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, read_doc,
+     "read [-ers] [-u fd] [-t timeout] [-p prompt] [-a array] [-n nchars] [-d delim] [name ...]", (char *)NULL },
+  { "read -ADC", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, read_DOS_doc,
+     "read [-...] [-ADC] [name ...]", (char *)NULL },
+  { "return", return_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | SPECIAL_BUILTIN, return_doc,
+     "return [n]", (char *)NULL },
+  { "set", set_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | SPECIAL_BUILTIN, set_doc,
+     "set [--abefhkmnptuvxBCHP] [-o option] [arg ...]", (char *)NULL },
+  { "unset", unset_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | SPECIAL_BUILTIN, unset_doc,
+     "unset [-f] [-v] [name ...]", (char *)NULL },
+  { "export", export_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | SPECIAL_BUILTIN | ASSIGNMENT_BUILTIN, export_doc,
+     "export [-nf] [name[=value] ...] or export -p", (char *)NULL },
+  { "readonly", readonly_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | SPECIAL_BUILTIN | ASSIGNMENT_BUILTIN, readonly_doc,
+     "readonly [-af] [name[=value] ...] or readonly -p", (char *)NULL },
+  { "shift", shift_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | SPECIAL_BUILTIN, shift_doc,
+     "shift [n]", (char *)NULL },
+  { "source", source_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | SPECIAL_BUILTIN, source_doc,
+     "source filename [arguments]", (char *)NULL },
+  { ".", source_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | SPECIAL_BUILTIN, dot_doc,
+     ". filename [arguments]", (char *)NULL },
+#if defined (JOB_CONTROL)
+  { "suspend", suspend_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, suspend_doc,
+     "suspend [-f]", (char *)NULL },
+#endif /* JOB_CONTROL */
+  { "test", test_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, test_doc,
+     "test [expr]", (char *)NULL },
+  { "[", test_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, test_bracket_doc,
+     "[ arg... ]", (char *)NULL },
+  { "times", times_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, times_doc,
+     "times", (char *)NULL },
+  { "trap", trap_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | SPECIAL_BUILTIN, trap_doc,
+     "trap [-lp] [[arg] signal_spec ...]", (char *)NULL },
+  { "type", type_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, type_doc,
+     "type [-afptP] name [name ...]", (char *)NULL },
+#if !defined (_MINIX)
+  { "ulimit", ulimit_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, ulimit_doc,
+     "ulimit [-SHacdflmnpstuv] [limit]", (char *)NULL },
+#endif /* !_MINIX */
+  { "umask", umask_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, umask_doc,
+     "umask [-p] [-S] [mode]", (char *)NULL },
+#if defined (JOB_CONTROL)
+  { "wait", wait_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, wait_doc,
+     "wait [n]", (char *)NULL },
+#endif /* JOB_CONTROL */
+#if !defined (JOB_CONTROL)
+  { "wait", wait_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, wait_doc,
+     "wait [n]", (char *)NULL },
+#endif /* !JOB_CONTROL */
+  { "for", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, for_doc,
+     "for NAME [in WORDS ... ;] do COMMANDS; done", (char *)NULL },
+  { "for ((", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, arith_for_doc,
+     "for (( exp1; exp2; exp3 )); do COMMANDS; done", (char *)NULL },
+  { "select", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, select_doc,
+     "select NAME [in WORDS ... ;] do COMMANDS; done", (char *)NULL },
+  { "time", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, time_doc,
+     "time [-p] PIPELINE", (char *)NULL },
+  { "case", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, case_doc,
+     "case WORD in [PATTERN [| PATTERN]...) COMMANDS ;;]... esac", (char *)NULL },
+  { "if", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, if_doc,
+     "if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]... [ else COMMANDS; ] fi", (char *)NULL },
+  { "while", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, while_doc,
+     "while COMMANDS; do COMMANDS; done", (char *)NULL },
+  { "until", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, until_doc,
+     "until COMMANDS; do COMMANDS; done", (char *)NULL },
+  { "function", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, function_doc,
+     "function NAME { COMMANDS ; } or NAME () { COMMANDS ; }", (char *)NULL },
+  { "{ ... }", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, grouping_braces_doc,
+     "{ COMMANDS ; }", (char *)NULL },
+  { "%", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, fg_percent_doc,
+     "%[DIGITS | WORD] [&]", (char *)NULL },
+  { "(( ... ))", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, arith_doc,
+     "(( expression ))", (char *)NULL },
+  { "[[ ... ]]", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, conditional_doc,
+     "[[ expression ]]", (char *)NULL },
+  { "variables", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, variable_help_doc,
+     "variables - Some variable names and meanings", (char *)NULL },
+  { "case then else", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, case_then_else_doc,
+     "case WORD in [PATTERN [| PATTERN]...[) | ))] COMMANDS (;;|;&|;;&)]... esac [then COMMANDS; else COMMANDS; fi]", (char *)NULL },
+  { "for then else", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, for_then_else_doc,
+     "for NAME [in WORDS ... ;] do COMMANDS; done [then COMMANDS; else COMMANDS; fi]", (char *)NULL },
+  { "while then else", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, while_then_else_doc,
+     "while COMMANDS; do COMMANDS; done [then COMMANDS; else COMMANDS; fi]", (char *)NULL },
+  { "until then else", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, until_then_else_doc,
+     "until COMMANDS; do COMMANDS; done [then COMMANDS; else COMMANDS; fi]", (char *)NULL },
+  { "{a..b} {a--b} {**} {##} {^var}", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, sequence_generator_doc,
+     "{int..int} {string--string} {**} {##} {^array}", (char *)NULL },
+  { "${var|command}", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, list_comprehension_doc,
+     "${var|command}", (char *)NULL },
+  { "try", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, try_doc,
+     "try COMMANDS; done [in CASE-PATTERN-LIST;; esac [then COMMANDS; else COMMANDS; fi]]", (char *)NULL },
+  { "<<+", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, here_document_using_firstline_doc,
+     "<<+ word", (char *)NULL },
+  { "<<<<", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, here_file_doc,
+     "<<<< word", (char *)NULL },
+#if defined (PUSHD_AND_POPD)
+  { "pushd", pushd_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, pushd_doc,
+     "pushd [dir | +N | -N] [-n]", (char *)NULL },
+#endif /* PUSHD_AND_POPD */
+#if defined (PUSHD_AND_POPD)
+  { "popd", popd_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, popd_doc,
+     "popd [+N | -N] [-n]", (char *)NULL },
+#endif /* PUSHD_AND_POPD */
+#if defined (PUSHD_AND_POPD)
+  { "dirs", dirs_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, dirs_doc,
+     "dirs [-clpv] [+N] [-N]", (char *)NULL },
+#endif /* PUSHD_AND_POPD */
+  { "shopt", shopt_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, shopt_doc,
+     "shopt [-pqsu] [-o long-option] optname [optname...]", (char *)NULL },
+  { "printf", printf_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, printf_doc,
+     "printf format [arguments]", (char *)NULL },
+#if defined (PROGRAMMABLE_COMPLETION)
+  { "complete", complete_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, complete_doc,
+     "complete [-abcdefgjksuv] [-pr] [-o option] [-A action] [-G globpat] [-W wordlist] [-P prefix] [-S suffix] [-X filterpat] [-F function] [-C command] [name ...]", (char *)NULL },
+#endif /* PROGRAMMABLE_COMPLETION */
+#if defined (PROGRAMMABLE_COMPLETION)
+  { "compgen", compgen_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, compgen_doc,
+     "compgen [-abcdefgjksuv] [-o option] [-A action] [-G globpat] [-W wordlist] [-P prefix] [-S suffix] [-X filterpat] [-F function] [-C command] [word]", (char *)NULL },
+#endif /* PROGRAMMABLE_COMPLETION */
+  { (char *)0x0, (sh_builtin_func_t *)0x0, 0, (char **)0x0, (char *)0x0 }
+};
+
+struct builtin *shell_builtins = static_shell_builtins;
+struct builtin *current_builtin;
+
+int num_shell_builtins =
+	sizeof (static_shell_builtins) / sizeof (struct builtin) - 1;
+#if defined (ALIAS)
+char * const alias_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("`alias' with no arguments or with the -p option prints the list"),
+  N_("of aliases in the form alias NAME=VALUE on standard output."),
+  N_("Otherwise, an alias is defined for each NAME whose VALUE is given."),
+  N_("A trailing space in VALUE causes the next word to be checked for"),
+  N_("alias substitution when the alias is expanded.  Alias returns"),
+  N_("true unless a NAME is given for which no alias has been defined."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* ALIAS */
+#if defined (ALIAS)
+char * const unalias_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Remove NAMEs from the list of defined aliases.  If the -a option is given,"),
+  N_("then remove all alias definitions."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* ALIAS */
+#if defined (READLINE)
+char * const bind_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Bind a key sequence to a Readline function or a macro, or set"),
+  N_("a Readline variable.  The non-option argument syntax is equivalent"),
+  N_("to that found in ~/.inputrc, but must be passed as a single argument:"),
+  N_("bind '\"\\C-x\\C-r\": re-read-init-file'."),
+  N_("bind accepts the following options:"),
+  N_("  -m  keymap         Use `keymap' as the keymap for the duration of this"),
+  N_("                     command.  Acceptable keymap names are emacs,"),
+  N_("                     emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,"),
+  N_("                     vi-command, and vi-insert."),
+  N_("  -l                 List names of functions."),
+  N_("  -P                 List function names and bindings."),
+  N_("  -p                 List functions and bindings in a form that can be"),
+  N_("                     reused as input."),
+  N_("  -r  keyseq         Remove the binding for KEYSEQ."),
+  N_("  -x  keyseq:shell-command	Cause SHELL-COMMAND to be executed when"),
+  N_("				KEYSEQ is entered."),
+  N_("  -f  filename       Read key bindings from FILENAME."),
+  N_("  -q  function-name  Query about which keys invoke the named function."),
+  N_("  -u  function-name  Unbind all keys which are bound to the named function."),
+  N_("  -V                 List variable names and values"),
+  N_("  -v                 List variable names and values in a form that can"),
+  N_("                     be reused as input."),
+  N_("  -S                 List key sequences that invoke macros and their values"),
+  N_("  -s                 List key sequences that invoke macros and their values"),
+  N_("                     in a form that can be reused as input."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* READLINE */
+char * const break_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Exit from within a FOR, WHILE or UNTIL loop.  If N is specified,"),
+  N_("break N levels."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const continue_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Resume the next iteration of the enclosing FOR, WHILE or UNTIL loop."),
+  N_("If N is specified, resume at the N-th enclosing loop."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const raise_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Raise string exception (default '') which will be caught in 'try' block."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const builtin_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Run a shell builtin.  This is useful when you wish to rename a"),
+  N_("shell builtin to be a function, but need the functionality of the"),
+  N_("builtin within the function itself."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#if defined (DEBUGGER)
+char * const caller_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Returns the context of the current subroutine call."),
+  N_(""),
+  N_("Without EXPR, returns returns \"$line $filename\".  With EXPR,"),
+  N_("returns \"$line $subroutine $filename\"; this extra information"),
+  N_("can be used used to provide a stack trace."),
+  N_(""),
+  N_("The value of EXPR indicates how many call frames to go back before the"),
+  N_("current one; the top frame is frame 0."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* DEBUGGER */
+char * const cd_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Change the current directory to DIR.  The variable $HOME is the"),
+  N_("default DIR.  The variable CDPATH defines the search path for"),
+  N_("the directory containing DIR.  Alternative directory names in CDPATH"),
+  N_("are separated by a colon (:).  A null directory name is the same as"),
+  N_("the current directory, i.e. `.'.  If DIR begins with a slash (/),"),
+  N_("then CDPATH is not used.  If the directory is not found, and the"),
+  N_("shell option `cdable_vars' is set, then try the word as a variable"),
+  N_("name.  If that variable has a value, then cd to the value of that"),
+  N_("variable.  The -P option says to use the physical directory structure"),
+  N_("instead of following symbolic links; the -L option forces symbolic links"),
+  N_("to be followed."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const pwd_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Print the current working directory.  With the -P option, pwd prints"),
+  N_("the physical directory, without any symbolic links; the -L option"),
+  N_("makes pwd follow symbolic links."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const colon_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("No effect; the command does nothing.  A zero exit code is returned."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const true_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Return a successful result."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const false_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Return an unsuccessful result."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const command_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Runs COMMAND with ARGS ignoring shell functions.  If you have a shell"),
+  N_("function called `ls', and you wish to call the command `ls', you can"),
+  N_("say \"command ls\".  If the -p option is given, a default value is used"),
+  N_("for PATH that is guaranteed to find all of the standard utilities.  If"),
+  N_("the -V or -v option is given, a string is printed describing COMMAND."),
+  N_("The -V option produces a more verbose description."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const declare_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Declare variables and/or give them attributes.  If no NAMEs are"),
+  N_("given, then display the values of variables instead.  The -p option"),
+  N_("will display the attributes and values of each NAME."),
+  N_(""),
+  N_("The flags are:"),
+  N_(""),
+  N_("  -a	to make NAMEs arrays (if supported)"),
+  N_("  -f	to select from among function names only"),
+  N_("  -F	to display function names (and line number and source file name if"),
+  N_("	debugging) without definitions"),
+  N_("  -i	to make NAMEs have the `integer' attribute"),
+  N_("  -r	to make NAMEs readonly"),
+  N_("  -t	to make NAMEs have the `trace' attribute"),
+  N_("  -x	to make NAMEs export"),
+  N_(""),
+  N_("Variables with the integer attribute have arithmetic evaluation (see"),
+  N_("`let') done when the variable is assigned to."),
+  N_(""),
+  N_("When displaying values of variables, -f displays a function's name"),
+  N_("and definition.  The -F option restricts the display to function"),
+  N_("name only."),
+  N_(""),
+  N_("Using `+' instead of `-' turns off the given attribute instead.  When"),
+  N_("used in a function, makes NAMEs local, as with the `local' command."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const typeset_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Obsolete.  See `declare'."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const local_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Create a local variable called NAME, and give it VALUE.  LOCAL"),
+  N_("can only be used within a function; it makes the variable NAME"),
+  N_("have a visible scope restricted to that function and its children."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#if defined (V9_ECHO)
+char * const echo_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Output the ARGs.  If -n is specified, the trailing newline is"),
+  N_("suppressed.  If the -e option is given, interpretation of the"),
+  N_("following backslash-escaped characters is turned on:"),
+  N_("	\\a	alert (bell)"),
+  N_("	\\b	backspace"),
+  N_("	\\c	suppress trailing newline"),
+  N_("	\\E	escape character"),
+  N_("	\\f	form feed"),
+  N_("	\\n	new line"),
+  N_("	\\r	carriage return"),
+  N_("	\\t	horizontal tab"),
+  N_("	\\v	vertical tab"),
+  N_("	\\\\	backslash"),
+  N_("	\\num	the character whose ASCII code is NUM (octal)."),
+  N_(""),
+  N_("You can explicitly turn off the interpretation of the above characters"),
+  N_("with the -E option."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* V9_ECHO */
+#if defined (V9_ECHO)
+char * const echo_DOS_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("The following options are added:"),
+  N_("    -D      print DOS line with trailing '\\r\\n' instead of normal '\\n'."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* V9_ECHO */
+#if !defined (V9_ECHO)
+char * const echo_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Output the ARGs.  If -n is specified, the trailing newline is suppressed."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* !V9_ECHO */
+char * const enable_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Enable and disable builtin shell commands.  This allows"),
+  N_("you to use a disk command which has the same name as a shell"),
+  N_("builtin without specifying a full pathname.  If -n is used, the"),
+  N_("NAMEs become disabled; otherwise NAMEs are enabled.  For example,"),
+  N_("to use the `test' found in $PATH instead of the shell builtin"),
+  N_("version, type `enable -n test'.  On systems supporting dynamic"),
+  N_("loading, the -f option may be used to load new builtins from the"),
+  N_("shared object FILENAME.  The -d option will delete a builtin"),
+  N_("previously loaded with -f.  If no non-option names are given, or"),
+  N_("the -p option is supplied, a list of builtins is printed.  The"),
+  N_("-a option means to print every builtin with an indication of whether"),
+  N_("or not it is enabled.  The -s option restricts the output to the POSIX.2"),
+  N_("`special' builtins.  The -n option displays a list of all disabled builtins."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const eval_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Read ARGs as input to the shell and execute the resulting command(s)."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const getopts_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Getopts is used by shell procedures to parse positional parameters."),
+  N_(""),
+  N_("OPTSTRING contains the option letters to be recognized; if a letter"),
+  N_("is followed by a colon, the option is expected to have an argument,"),
+  N_("which should be separated from it by white space."),
+  N_(""),
+  N_("Each time it is invoked, getopts will place the next option in the"),
+  N_("shell variable $name, initializing name if it does not exist, and"),
+  N_("the index of the next argument to be processed into the shell"),
+  N_("variable OPTIND.  OPTIND is initialized to 1 each time the shell or"),
+  N_("a shell script is invoked.  When an option requires an argument,"),
+  N_("getopts places that argument into the shell variable OPTARG."),
+  N_(""),
+  N_("getopts reports errors in one of two ways.  If the first character"),
+  N_("of OPTSTRING is a colon, getopts uses silent error reporting.  In"),
+  N_("this mode, no error messages are printed.  If an invalid option is"),
+  N_("seen, getopts places the option character found into OPTARG.  If a"),
+  N_("required argument is not found, getopts places a ':' into NAME and"),
+  N_("sets OPTARG to the option character found.  If getopts is not in"),
+  N_("silent mode, and an invalid option is seen, getopts places '?' into"),
+  N_("NAME and unsets OPTARG.  If a required argument is not found, a '?'"),
+  N_("is placed in NAME, OPTARG is unset, and a diagnostic message is"),
+  N_("printed."),
+  N_(""),
+  N_("If the shell variable OPTERR has the value 0, getopts disables the"),
+  N_("printing of error messages, even if the first character of"),
+  N_("OPTSTRING is not a colon.  OPTERR has the value 1 by default."),
+  N_(""),
+  N_("Getopts normally parses the positional parameters ($0 - $9), but if"),
+  N_("more arguments are given, they are parsed instead."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const exec_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Exec FILE, replacing this shell with the specified program."),
+  N_("If FILE is not specified, the redirections take effect in this"),
+  N_("shell.  If the first argument is `-l', then place a dash in the"),
+  N_("zeroth arg passed to FILE, as login does.  If the `-c' option"),
+  N_("is supplied, FILE is executed with a null environment.  The `-a'"),
+  N_("option means to make set argv[0] of the executed process to NAME."),
+  N_("If the file cannot be executed and the shell is not interactive,"),
+  N_("then the shell exits, unless the shell option `execfail' is set."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const exit_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Exit the shell with a status of N.  If N is omitted, the exit status"),
+  N_("is that of the last command executed."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const logout_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Logout of a login shell."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#if defined (HISTORY)
+char * const fc_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("fc is used to list or edit and re-execute commands from the history list."),
+  N_("FIRST and LAST can be numbers specifying the range, or FIRST can be a"),
+  N_("string, which means the most recent command beginning with that"),
+  N_("string."),
+  N_(""),
+  N_("   -e ENAME selects which editor to use.  Default is FCEDIT, then EDITOR,"),
+  N_("      then vi."),
+  N_(""),
+  N_("   -l means list lines instead of editing."),
+  N_("   -n means no line numbers listed."),
+  N_("   -r means reverse the order of the lines (making it newest listed first)."),
+  N_(""),
+  N_("With the `fc -s [pat=rep ...] [command]' format, the command is"),
+  N_("re-executed after the substitution OLD=NEW is performed."),
+  N_(""),
+  N_("A useful alias to use with this is r='fc -s', so that typing `r cc'"),
+  N_("runs the last command beginning with `cc' and typing `r' re-executes"),
+  N_("the last command."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* HISTORY */
+#if defined (JOB_CONTROL)
+char * const fg_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Place JOB_SPEC in the foreground, and make it the current job.  If"),
+  N_("JOB_SPEC is not present, the shell's notion of the current job is"),
+  N_("used."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* JOB_CONTROL */
+#if defined (JOB_CONTROL)
+char * const bg_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Place JOB_SPEC in the background, as if it had been started with"),
+  N_("`&'.  If JOB_SPEC is not present, the shell's notion of the current"),
+  N_("job is used."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* JOB_CONTROL */
+char * const hash_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("For each NAME, the full pathname of the command is determined and"),
+  N_("remembered.  If the -p option is supplied, PATHNAME is used as the"),
+  N_("full pathname of NAME, and no path search is performed.  The -r"),
+  N_("option causes the shell to forget all remembered locations.  The -d"),
+  N_("option causes the shell to forget the remembered location of each NAME."),
+  N_("If the -t option is supplied the full pathname to which each NAME"),
+  N_("corresponds is printed.  If multiple NAME arguments are supplied with"),
+  N_("-t, the NAME is printed before the hashed full pathname.  The -l option"),
+  N_("causes output to be displayed in a format that may be reused as input."),
+  N_("If no arguments are given, information about remembered commands is displayed."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#if defined (HELP_BUILTIN)
+char * const help_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Display helpful information about builtin commands.  If PATTERN is"),
+  N_("specified, gives detailed help on all commands matching PATTERN,"),
+  N_("otherwise a list of the builtins is printed.  The -s option"),
+  N_("restricts the output for each builtin command matching PATTERN to"),
+  N_("a short usage synopsis."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* HELP_BUILTIN */
+#if defined (HISTORY)
+char * const history_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Display the history list with line numbers.  Lines listed with"),
+  N_("with a `*' have been modified.  Argument of N says to list only"),
+  N_("the last N lines.  The `-c' option causes the history list to be"),
+  N_("cleared by deleting all of the entries.  The `-d' option deletes"),
+  N_("the history entry at offset OFFSET.  The `-w' option writes out the"),
+  N_("current history to the history file;  `-r' means to read the file and"),
+  N_("append the contents to the history list instead.  `-a' means"),
+  N_("to append history lines from this session to the history file."),
+  N_("Argument `-n' means to read all history lines not already read"),
+  N_("from the history file and append them to the history list."),
+  N_(""),
+  N_("If FILENAME is given, then that is used as the history file else"),
+  N_("if $HISTFILE has a value, that is used, else ~/.bash_history."),
+  N_("If the -s option is supplied, the non-option ARGs are appended to"),
+  N_("the history list as a single entry.  The -p option means to perform"),
+  N_("history expansion on each ARG and display the result, without storing"),
+  N_("anything in the history list."),
+  N_(""),
+  N_("If the $HISTTIMEFORMAT variable is set and not null, its value is used"),
+  N_("as a format string for strftime(3) to print the time stamp associated"),
+  N_("with each displayed history entry.  No time stamps are printed otherwise."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* HISTORY */
+#if defined (JOB_CONTROL)
+char * const jobs_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Lists the active jobs.  The -l option lists process id's in addition"),
+  N_("to the normal information; the -p option lists process id's only."),
+  N_("If -n is given, only processes that have changed status since the last"),
+  N_("notification are printed.  JOBSPEC restricts output to that job.  The"),
+  N_("-r and -s options restrict output to running and stopped jobs only,"),
+  N_("respectively.  Without options, the status of all active jobs is"),
+  N_("printed.  If -x is given, COMMAND is run after all job specifications"),
+  N_("that appear in ARGS have been replaced with the process ID of that job's"),
+  N_("process group leader."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* JOB_CONTROL */
+#if defined (JOB_CONTROL)
+char * const disown_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("By default, removes each JOBSPEC argument from the table of active jobs."),
+  N_("If the -h option is given, the job is not removed from the table, but is"),
+  N_("marked so that SIGHUP is not sent to the job if the shell receives a"),
+  N_("SIGHUP.  The -a option, when JOBSPEC is not supplied, means to remove all"),
+  N_("jobs from the job table; the -r option means to remove only running jobs."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* JOB_CONTROL */
+char * const kill_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Send the processes named by PID (or JOB) the signal SIGSPEC.  If"),
+  N_("SIGSPEC is not present, then SIGTERM is assumed.  An argument of `-l'"),
+  N_("lists the signal names; if arguments follow `-l' they are assumed to"),
+  N_("be signal numbers for which names should be listed.  Kill is a shell"),
+  N_("builtin for two reasons: it allows job IDs to be used instead of"),
+  N_("process IDs, and, if you have reached the limit on processes that"),
+  N_("you can create, you don't have to start a process to kill another one."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const let_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Each ARG is an arithmetic expression to be evaluated.  Evaluation"),
+  N_("is done in fixed-width integers with no check for overflow, though"),
+  N_("division by 0 is trapped and flagged as an error.  The following"),
+  N_("list of operators is grouped into levels of equal-precedence operators."),
+  N_("The levels are listed in order of decreasing precedence."),
+  N_(""),
+  N_("	id++, id--	variable post-increment, post-decrement"),
+  N_("	++id, --id	variable pre-increment, pre-decrement"),
+  N_("	-, +		unary minus, plus"),
+  N_("	!, ~		logical and bitwise negation"),
+  N_("	**		exponentiation"),
+  N_("	*, /, %		multiplication, division, remainder"),
+  N_("	+, -		addition, subtraction"),
+  N_("	<<, >>		left and right bitwise shifts"),
+  N_("	<=, >=, <, >	comparison"),
+  N_("	==, !=		equality, inequality"),
+  N_("	&		bitwise AND"),
+  N_("	^		bitwise XOR"),
+  N_("	|		bitwise OR"),
+  N_("	&&		logical AND"),
+  N_("	||		logical OR"),
+  N_("	expr ? expr : expr"),
+  N_("			conditional operator"),
+  N_("	=, *=, /=, %=,"),
+  N_("	+=, -=, <<=, >>=,"),
+  N_("	&=, ^=, |=	assignment"),
+  N_(""),
+  N_("Shell variables are allowed as operands.  The name of the variable"),
+  N_("is replaced by its value (coerced to a fixed-width integer) within"),
+  N_("an expression.  The variable need not have its integer attribute"),
+  N_("turned on to be used in an expression."),
+  N_(""),
+  N_("Operators are evaluated in order of precedence.  Sub-expressions in"),
+  N_("parentheses are evaluated first and may override the precedence"),
+  N_("rules above."),
+  N_(""),
+  N_("If the last ARG evaluates to 0, let returns 1; 0 is returned"),
+  N_("otherwise."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const read_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("One line is read from the standard input, or from file descriptor FD if the"),
+  N_("-u option is supplied, and the first word is assigned to the first NAME,"),
+  N_("the second word to the second NAME, and so on, with leftover words assigned"),
+  N_("to the last NAME.  Only the characters found in $IFS are recognized as word"),
+  N_("delimiters.  If no NAMEs are supplied, the line read is stored in the REPLY"),
+  N_("variable.  If the -r option is given, this signifies `raw' input, and"),
+  N_("backslash escaping is disabled.  The -d option causes read to continue"),
+  N_("until the first character of DELIM is read, rather than newline.  If the -p"),
+  N_("option is supplied, the string PROMPT is output without a trailing newline"),
+  N_("before attempting to read.  If -a is supplied, the words read are assigned"),
+  N_("to sequential indices of ARRAY, starting at zero.  If -e is supplied and"),
+  N_("the shell is interactive, readline is used to obtain the line.  If -n is"),
+  N_("supplied with a non-zero NCHARS argument, read returns after NCHARS"),
+  N_("characters have been read.  The -s option causes input coming from a"),
+  N_("terminal to not be echoed."),
+  N_(""),
+  N_("The -t option causes read to time out and return failure if a complete line"),
+  N_("of input is not read within TIMEOUT seconds.  If the TMOUT variable is set,"),
+  N_("its value is the default timeout.  The return code is zero, unless end-of-file"),
+  N_("is encountered, read times out, or an invalid file descriptor is supplied as"),
+  N_("the argument to -u."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const read_DOS_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("The following options are added:"),
+  N_("    -A  emulate Awk-style NF, NR variables, and $1 $2 ... parameters"),
+  N_("    -D  read DOS lines ending in \\r\\n (CRLF)"),
+  N_("    -C  read CSV (comma separated values) lines, while skipping over \"...\"."),
+  N_("        Fields are split on comma, while skipping over \"...\".  That is,"),
+  N_("        both record separator and field separator (ie. RS and FS in Awk)"),
+  N_("        can be embedded within double quotes.  Eg."),
+  N_("            read -C -a array"),
+  N_("        is equivalent to"),
+  N_("            read -C"),
+  N_("            array=( \"${REPLY|,}\" )"),
+  N_("        All whitespaces are preserved, so you must apply ${var|.lrstrip}"),
+  N_("        and ${var|.csvdequote} manually to remove fluffs."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const return_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Causes a function to exit with the return value specified by N.  If N"),
+  N_("is omitted, the return status is that of the last command."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const set_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("    -a  Mark variables which are modified or created for export."),
+  N_("    -b  Notify of job termination immediately."),
+  N_("    -e  Exit immediately if a command exits with a non-zero status."),
+  N_("    -f  Disable file name generation (globbing)."),
+  N_("    -h  Remember the location of commands as they are looked up."),
+  N_("    -k  All assignment arguments are placed in the environment for a"),
+  N_("        command, not just those that precede the command name."),
+  N_("    -m  Job control is enabled."),
+  N_("    -n  Read commands but do not execute them."),
+  N_("    -o option-name"),
+  N_("        Set the variable corresponding to option-name:"),
+  N_("            allexport    same as -a"),
+  N_("            braceexpand  same as -B"),
+#if defined (READLINE)
+  N_("            emacs        use an emacs-style line editing interface"),
+#endif /* READLINE */
+  N_("            errexit      same as -e"),
+  N_("            errtrace     same as -E"),
+  N_("            functrace    same as -T"),
+  N_("            hashall      same as -h"),
+#if defined (BANG_HISTORY)
+  N_("            histexpand   same as -H"),
+#endif /* BANG_HISTORY */
+#if defined (HISTORY)
+  N_("            history      enable command history"),
+#endif
+  N_("            ignoreeof    the shell will not exit upon reading EOF"),
+  N_("            interactive-comments"),
+  N_("                         allow comments to appear in interactive commands"),
+  N_("            keyword      same as -k"),
+  N_("            monitor      same as -m"),
+  N_("            noclobber    same as -C"),
+  N_("            noexec       same as -n"),
+  N_("            noglob       same as -f"),
+  N_("            nolog        currently accepted but ignored"),
+  N_("            notify       same as -b"),
+  N_("            nounset      same as -u"),
+  N_("            onecmd       same as -t"),
+  N_("            physical     same as -P"),
+  N_("            pipefail     the return value of a pipeline is the status of"),
+  N_("                         the last command to exit with a non-zero status,"),
+  N_("                         or zero if no command exited with a non-zero status"),
+  N_("            posix        change the behavior of bash where the default"),
+  N_("                         operation differs from the 1003.2 standard to"),
+  N_("                         match the standard"),
+  N_("            privileged   same as -p"),
+  N_("            verbose      same as -v"),
+#if defined (READLINE)
+  N_("            vi           use a vi-style line editing interface"),
+#endif /* READLINE */
+  N_("            xtrace       same as -x"),
+  N_("    -p  Turned on whenever the real and effective user ids do not match."),
+  N_("        Disables processing of the $ENV file and importing of shell"),
+  N_("        functions.  Turning this option off causes the effective uid and"),
+  N_("        gid to be set to the real uid and gid."),
+  N_("    -t  Exit after reading and executing one command."),
+  N_("    -u  Treat unset variables as an error when substituting."),
+  N_("    -v  Print shell input lines as they are read."),
+  N_("    -x  Print commands and their arguments as they are executed."),
+#if defined (BRACE_EXPANSION)
+  N_("    -B  the shell will perform brace expansion"),
+#endif /* BRACE_EXPANSION */
+  N_("    -C  If set, disallow existing regular files to be overwritten"),
+  N_("        by redirection of output."),
+  N_("    -E  If set, the ERR trap is inherited by shell functions."),
+#if defined (BANG_HISTORY)
+  N_("    -H  Enable ! style history substitution.  This flag is on"),
+  N_("        by default."),
+#endif /* BANG_HISTORY */
+  N_("    -P  If set, do not follow symbolic links when executing commands"),
+  N_("        such as cd which change the current directory."),
+  N_("    -T  If set, the DEBUG trap is inherited by shell functions."),
+  N_(""),
+  N_("Using + rather than - causes these flags to be turned off.  The"),
+  N_("flags can also be used upon invocation of the shell.  The current"),
+  N_("set of flags may be found in $-.  The remaining n ARGs are positional"),
+  N_("parameters and are assigned, in order, to $1, $2, .. $n.  If no"),
+  N_("ARGs are given, all shell variables are printed."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const unset_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("For each NAME, remove the corresponding variable or function.  Given"),
+  N_("the `-v', unset will only act on variables.  Given the `-f' flag,"),
+  N_("unset will only act on functions.  With neither flag, unset first"),
+  N_("tries to unset a variable, and if that fails, then tries to unset a"),
+  N_("function.  Some variables cannot be unset; also see readonly."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const export_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("NAMEs are marked for automatic export to the environment of"),
+  N_("subsequently executed commands.  If the -f option is given,"),
+  N_("the NAMEs refer to functions.  If no NAMEs are given, or if `-p'"),
+  N_("is given, a list of all names that are exported in this shell is"),
+  N_("printed.  An argument of `-n' says to remove the export property"),
+  N_("from subsequent NAMEs.  An argument of `--' disables further option"),
+  N_("processing."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const readonly_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("The given NAMEs are marked readonly and the values of these NAMEs may"),
+  N_("not be changed by subsequent assignment.  If the -f option is given,"),
+  N_("then functions corresponding to the NAMEs are so marked.  If no"),
+  N_("arguments are given, or if `-p' is given, a list of all readonly names"),
+  N_("is printed.  The `-a' option means to treat each NAME as"),
+  N_("an array variable.  An argument of `--' disables further option"),
+  N_("processing."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const shift_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("The positional parameters from $N+1 ... are renamed to $1 ...  If N is"),
+  N_("not given, it is assumed to be 1."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const source_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Read and execute commands from FILENAME and return.  The pathnames"),
+  N_("in $PATH are used to find the directory containing FILENAME.  If any"),
+  N_("ARGUMENTS are supplied, they become the positional parameters when"),
+  N_("FILENAME is executed."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const dot_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Read and execute commands from FILENAME and return.  The pathnames"),
+  N_("in $PATH are used to find the directory containing FILENAME.  If any"),
+  N_("ARGUMENTS are supplied, they become the positional parameters when"),
+  N_("FILENAME is executed."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#if defined (JOB_CONTROL)
+char * const suspend_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Suspend the execution of this shell until it receives a SIGCONT"),
+  N_("signal.  The `-f' if specified says not to complain about this"),
+  N_("being a login shell if it is; just suspend anyway."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* JOB_CONTROL */
+char * const test_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Exits with a status of 0 (true) or 1 (false) depending on"),
+  N_("the evaluation of EXPR.  Expressions may be unary or binary.  Unary"),
+  N_("expressions are often used to examine the status of a file.  There"),
+  N_("are string operators as well, and numeric comparison operators."),
+  N_(""),
+  N_("File operators:"),
+  N_(""),
+  N_("    -a FILE        True if file exists."),
+  N_("    -b FILE        True if file is block special."),
+  N_("    -c FILE        True if file is character special."),
+  N_("    -d FILE        True if file is a directory."),
+  N_("    -e FILE        True if file exists."),
+  N_("    -f FILE        True if file exists and is a regular file."),
+  N_("    -g FILE        True if file is set-group-id."),
+  N_("    -h FILE        True if file is a symbolic link."),
+  N_("    -L FILE        True if file is a symbolic link."),
+  N_("    -k FILE        True if file has its `sticky' bit set."),
+  N_("    -p FILE        True if file is a named pipe."),
+  N_("    -r FILE        True if file is readable by you."),
+  N_("    -s FILE        True if file exists and is not empty."),
+  N_("    -S FILE        True if file is a socket."),
+  N_("    -t FD          True if FD is opened on a terminal."),
+  N_("    -u FILE        True if the file is set-user-id."),
+  N_("    -w FILE        True if the file is writable by you."),
+  N_("    -x FILE        True if the file is executable by you."),
+  N_("    -O FILE        True if the file is effectively owned by you."),
+  N_("    -G FILE        True if the file is effectively owned by your group."),
+  N_("    -N FILE        True if the file has been modified since it was last read."),
+  N_(""),
+  N_("  FILE1 -nt FILE2  True if file1 is newer than file2 (according to"),
+  N_("                   modification date)."),
+  N_(""),
+  N_("  FILE1 -ot FILE2  True if file1 is older than file2."),
+  N_(""),
+  N_("  FILE1 -ef FILE2  True if file1 is a hard link to file2."),
+  N_(""),
+  N_("String operators:"),
+  N_(""),
+  N_("    -z STRING      True if string is empty."),
+  N_(""),
+  N_("    -n STRING"),
+  N_("    STRING         True if string is not empty."),
+  N_(""),
+  N_("    STRING1 = STRING2"),
+  N_("                   True if the strings are equal."),
+  N_("    STRING1 != STRING2"),
+  N_("                   True if the strings are not equal."),
+  N_("    STRING1 < STRING2"),
+  N_("                   True if STRING1 sorts before STRING2 lexicographically."),
+  N_("    STRING1 > STRING2"),
+  N_("                   True if STRING1 sorts after STRING2 lexicographically."),
+  N_(""),
+  N_("Other operators:"),
+  N_(""),
+  N_("    -o OPTION      True if the shell option OPTION is enabled."),
+  N_("    ! EXPR         True if expr is false."),
+  N_("    EXPR1 -a EXPR2 True if both expr1 AND expr2 are true."),
+  N_("    EXPR1 -o EXPR2 True if either expr1 OR expr2 is true."),
+  N_(""),
+  N_("    arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,"),
+  N_("                   -lt, -le, -gt, or -ge."),
+  N_(""),
+  N_("Arithmetic binary operators return true if ARG1 is equal, not-equal,"),
+  N_("less-than, less-than-or-equal, greater-than, or greater-than-or-equal"),
+  N_("than ARG2."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const test_bracket_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("This is a synonym for the \"test\" builtin, but the last"),
+  N_("argument must be a literal `]', to match the opening `['."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const times_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Print the accumulated user and system times for processes run from"),
+  N_("the shell."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const trap_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("The command ARG is to be read and executed when the shell receives"),
+  N_("signal(s) SIGNAL_SPEC.  If ARG is absent (and a single SIGNAL_SPEC"),
+  N_("is supplied) or `-', each specified signal is reset to its original"),
+  N_("value.  If ARG is the null string each SIGNAL_SPEC is ignored by the"),
+  N_("shell and by the commands it invokes.  If a SIGNAL_SPEC is EXIT (0)"),
+  N_("the command ARG is executed on exit from the shell.  If a SIGNAL_SPEC"),
+  N_("is DEBUG, ARG is executed after every simple command.  If the`-p' option"),
+  N_("is supplied then the trap commands associated with each SIGNAL_SPEC are"),
+  N_("displayed.  If no arguments are supplied or if only `-p' is given, trap"),
+  N_("prints the list of commands associated with each signal.  Each SIGNAL_SPEC"),
+  N_("is either a signal name in <signal.h> or a signal number.  Signal names"),
+  N_("are case insensitive and the SIG prefix is optional.  `trap -l' prints"),
+  N_("a list of signal names and their corresponding numbers.  Note that a"),
+  N_("signal can be sent to the shell with \"kill -signal $$\"."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const type_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("For each NAME, indicate how it would be interpreted if used as a"),
+  N_("command name."),
+  N_(""),
+  N_("If the -t option is used, `type' outputs a single word which is one of"),
+  N_("`alias', `keyword', `function', `builtin', `file' or `', if NAME is an"),
+  N_("alias, shell reserved word, shell function, shell builtin, disk file,"),
+  N_("or unfound, respectively."),
+  N_(""),
+  N_("If the -p flag is used, `type' either returns the name of the disk"),
+  N_("file that would be executed, or nothing if `type -t NAME' would not"),
+  N_("return `file'."),
+  N_(""),
+  N_("If the -a flag is used, `type' displays all of the places that contain"),
+  N_("an executable named `file'.  This includes aliases, builtins, and"),
+  N_("functions, if and only if the -p flag is not also used."),
+  N_(""),
+  N_("The -f flag suppresses shell function lookup."),
+  N_(""),
+  N_("The -P flag forces a PATH search for each NAME, even if it is an alias,"),
+  N_("builtin, or function, and returns the name of the disk file that would"),
+  N_("be executed."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#if !defined (_MINIX)
+char * const ulimit_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Ulimit provides control over the resources available to processes"),
+  N_("started by the shell, on systems that allow such control.  If an"),
+  N_("option is given, it is interpreted as follows:"),
+  N_(""),
+  N_("    -S	use the `soft' resource limit"),
+  N_("    -H	use the `hard' resource limit"),
+  N_("    -a	all current limits are reported"),
+  N_("    -c	the maximum size of core files created"),
+  N_("    -d	the maximum size of a process's data segment"),
+  N_("    -f	the maximum size of files created by the shell"),
+  N_("    -l	the maximum size a process may lock into memory"),
+  N_("    -m	the maximum resident set size"),
+  N_("    -n	the maximum number of open file descriptors"),
+  N_("    -p	the pipe buffer size"),
+  N_("    -s	the maximum stack size"),
+  N_("    -t	the maximum amount of cpu time in seconds"),
+  N_("    -u	the maximum number of user processes"),
+  N_("    -v	the size of virtual memory"),
+  N_(""),
+  N_("If LIMIT is given, it is the new value of the specified resource;"),
+  N_("the special LIMIT values `soft', `hard', and `unlimited' stand for"),
+  N_("the current soft limit, the current hard limit, and no limit, respectively."),
+  N_("Otherwise, the current value of the specified resource is printed."),
+  N_("If no option is given, then -f is assumed.  Values are in 1024-byte"),
+  N_("increments, except for -t, which is in seconds, -p, which is in"),
+  N_("increments of 512 bytes, and -u, which is an unscaled number of"),
+  N_("processes."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* !_MINIX */
+char * const umask_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("The user file-creation mask is set to MODE.  If MODE is omitted, or if"),
+  N_("`-S' is supplied, the current value of the mask is printed.  The `-S'"),
+  N_("option makes the output symbolic; otherwise an octal number is output."),
+  N_("If `-p' is supplied, and MODE is omitted, the output is in a form"),
+  N_("that may be used as input.  If MODE begins with a digit, it is"),
+  N_("interpreted as an octal number, otherwise it is a symbolic mode string"),
+  N_("like that accepted by chmod(1)."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#if defined (JOB_CONTROL)
+char * const wait_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Wait for the specified process and report its termination status.  If"),
+  N_("N is not given, all currently active child processes are waited for,"),
+  N_("and the return code is zero.  N may be a process ID or a job"),
+  N_("specification; if a job spec is given, all processes in the job's"),
+  N_("pipeline are waited for."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* JOB_CONTROL */
+#if !defined (JOB_CONTROL)
+char * const wait_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Wait for the specified process and report its termination status.  If"),
+  N_("N is not given, all currently active child processes are waited for,"),
+  N_("and the return code is zero.  N is a process ID; if it is not given,"),
+  N_("all child processes of the shell are waited for."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* !JOB_CONTROL */
+char * const for_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("The `for' loop executes a sequence of commands for each member in a"),
+  N_("list of items.  If `in WORDS ...;' is not present, then `in \"$@\"' is"),
+  N_("assumed.  For each element in WORDS, NAME is set to that element, and"),
+  N_("the COMMANDS are executed."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const arith_for_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Equivalent to"),
+  N_("	(( EXP1 ))"),
+  N_("	while (( EXP2 )); do"),
+  N_("		COMMANDS"),
+  N_("		(( EXP3 ))"),
+  N_("	done"),
+  N_("EXP1, EXP2, and EXP3 are arithmetic expressions.  If any expression is"),
+  N_("omitted, it behaves as if it evaluates to 1."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const select_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("The WORDS are expanded, generating a list of words.  The"),
+  N_("set of expanded words is printed on the standard error, each"),
+  N_("preceded by a number.  If `in WORDS' is not present, `in \"$@\"'"),
+  N_("is assumed.  The PS3 prompt is then displayed and a line read"),
+  N_("from the standard input.  If the line consists of the number"),
+  N_("corresponding to one of the displayed words, then NAME is set"),
+  N_("to that word.  If the line is empty, WORDS and the prompt are"),
+  N_("redisplayed.  If EOF is read, the command completes.  Any other"),
+  N_("value read causes NAME to be set to null.  The line read is saved"),
+  N_("in the variable REPLY.  COMMANDS are executed after each selection"),
+  N_("until a break command is executed."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const time_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Execute PIPELINE and print a summary of the real time, user CPU time,"),
+  N_("and system CPU time spent executing PIPELINE when it terminates."),
+  N_("The return status is the return status of PIPELINE.  The `-p' option"),
+  N_("prints the timing summary in a slightly different format.  This uses"),
+  N_("the value of the TIMEFORMAT variable as the output format."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const case_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Selectively execute COMMANDS based upon WORD matching PATTERN.  The"),
+  N_("`|' is used to separate multiple patterns."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const if_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("The if COMMANDS are executed.  If the exit status is zero, then the then"),
+  N_("COMMANDS are executed.  Otherwise, each of the elif COMMANDS are executed"),
+  N_("in turn, and if the exit status is zero, the corresponding then COMMANDS"),
+  N_("are executed and the if command completes.  Otherwise, the else COMMANDS"),
+  N_("are executed, if present.  The exit status is the exit status of the last"),
+  N_("command executed, or zero if no condition tested true."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const while_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Expand and execute COMMANDS as long as the final command in the"),
+  N_("`while' COMMANDS has an exit status of zero."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const until_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Expand and execute COMMANDS as long as the final command in the"),
+  N_("`until' COMMANDS has an exit status which is not zero."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const function_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Create a simple command invoked by NAME which runs COMMANDS."),
+  N_("Arguments on the command line along with NAME are passed to the"),
+  N_("function as $0 .. $n."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const grouping_braces_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Run a set of commands in a group.  This is one way to redirect an"),
+  N_("entire set of commands."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const fg_percent_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("This is similar to the `fg' command.  Resume a stopped or background"),
+  N_("job.  If you specifiy DIGITS, then that job is used.  If you specify"),
+  N_("WORD, then the job whose name begins with WORD is used.  Following the"),
+  N_("job specification with a `&' places the job in the background."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const arith_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("The EXPRESSION is evaluated according to the rules for arithmetic"),
+  N_("evaluation.  Equivalent to \"let EXPRESSION\"."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const conditional_doc[] = {
+#if defined (HELP_BUILTIN)
+  N_("Returns a status of 0 or 1 depending on the evaluation of the conditional"),
+  N_("expression EXPRESSION.  Expressions are compose
\ No newline at end of file
--- bash-3.2_orig/builtins/read.def	2008-04-05 08:42:57.000000000 +0000
+++ bash-3.2/builtins/read.def	2008-04-05 08:55:53.000000000 +0000
@@ -47,6 +47,27 @@
 the argument to -u.
 $END
 
+
+/* --William */
+$BUILTIN read -ADC
+$DOCNAME read_DOS
+$SHORT_DOC read [-...] [-ADC] [name ...]
+The following options are added:
+    -A  emulate Awk-style NF, NR variables, and $1 $2 ... parameters
+    -D  read DOS lines ending in \r\n (CRLF)
+    -C  read CSV (comma separated values) lines, while skipping over "...".
+        Fields are split on comma, while skipping over "...".  That is,
+        both record separator and field separator (ie. RS and FS in Awk)
+        can be embedded within double quotes.  Eg.
+            read -C -a array
+        is equivalent to
+            read -C
+            array=( "${REPLY|,}" )
+        All whitespaces are preserved, so you must apply ${var|.lrstrip}
+        and ${var|.csvdequote} manually to remove fluffs.
+$END
+
+
 #include <config.h>
 
 #include "bashtypes.h"
@@ -83,6 +104,10 @@
 #  include "input.h"
 #endif
 
+
+#include "subroutines.h"		/* --William */
+
+
 #if !defined(errno)
 extern int errno;
 #endif
@@ -145,6 +170,12 @@
   int rlind;
 #endif
 
+  int emulate_Awk = 0;		/* emulate Awk  --William */
+  int read_DOS_line = 0;	/* read DOS line  --William */
+
+  int read_CSV_line = 0;	/* read CSV line  --William */
+  int inside_quote = 0;		/* flag for "..."  --William */
+
   USE_VAR(size);
   USE_VAR(i);
   USE_VAR(pass_next);
@@ -182,7 +213,7 @@
   delim = '\n';		/* read until newline */
 
   reset_internal_getopt ();
-  while ((opt = internal_getopt (list, "ersa:d:n:p:t:u:")) != -1)
+  while ((opt = internal_getopt (list, "ersa:d:n:p:t:u:ADC")) != -1)	/* add ADC --William */
     {
       switch (opt)
 	{
@@ -246,6 +277,18 @@
 	case 'd':
 	  delim = *list_optarg;
 	  break;
+
+	case 'A':		/* emulate Awk  --William */
+	    emulate_Awk = 1;
+	    break;
+	case 'D':		/* read DOS line  --William */
+	    read_DOS_line = 1;
+	    break;
+	case 'C':		/* read CSV line  --William */
+	    read_CSV_line = 1;	
+	    inside_quote = 0;
+	    break;
+
 	default:
 	  builtin_usage ();
 	  return (EX_USAGE);
@@ -470,6 +513,17 @@
 	  continue;
 	}
 
+      /*************************************************************************
+       * If DELIM occurs outside of "...", then it is the end of CSV line.
+       * --William
+       */
+      if (read_CSV_line) {
+	  if ((unsigned char)c == delim && ! inside_quote)
+	      break;
+	  if (c == '"')
+	      inside_quote = (inside_quote? 0: 1);	/* toggle */
+      } else		/* original code */
+      /************************************************************************/
       if ((unsigned char)c == delim)
 	break;
 
@@ -488,6 +542,22 @@
     }
   input_string[i] = '\0';
 
+  /*****************************************************************************
+   * Read DOS line which ends in '\r\n'.  If we are reading by lines, ie.
+   *	delim == '\n'
+   * then remove the extra '\r' at the end of string.  So, 
+   *	read -D a b c
+   * is equivalent to
+   *	read
+   *	REPLY="${REPLY%$'\r'}"
+   *	read a b c <<< "$REPLY"
+   *
+   * --William
+   */
+  if (read_DOS_line && delim == '\n' && i > 0 && input_string[i-1] == '\r')
+      input_string[--i] = '\0';
+  /****************************************************************************/
+
 #if 1
   if (retval < 0)
     {
@@ -527,6 +597,38 @@
 
   retval = eof ? EXECUTION_FAILURE : EXECUTION_SUCCESS;
 
+  /*****************************************************************************
+   * Simple emulation of Awk:
+   *	NF	total number of IFS fields
+   *	NR	number of lines read so far
+   *	$1 $2 ...	fields assigned to positional parameters
+   *
+   * --William
+   */
+  if (emulate_Awk) {
+      intmax_t n;
+
+      /*************************************************************************
+       * For CSV format, do splitting like ${var|,}  --William
+       */
+      if (read_CSV_line)
+	  alist = string_minus_separator (input_string, "");
+      else		/* original code */
+      /************************************************************************/
+          alist = list_string (input_string, ifs_chars, 0);
+      n = list_length (alist);
+      bind_var_to_int ("NF", n);
+      remember_args (alist, 1);		/* new parameters, ie. 'set -- ...' */
+      dispose_words (alist);
+
+      t = get_string_value ("NR");
+      if (t && *t && legal_number (t, &n) && n >= 0)
+	  bind_var_to_int ("NR", n + 1);
+      else 
+	  bind_var_to_int ("NR", 1);
+  }
+  /****************************************************************************/
+
 #if defined (ARRAY_VARS)
   /* If -a was given, take the string read, break it into a list of words,
      an assign them to `arrayname' in turn. */
@@ -547,7 +649,15 @@
 	}
       array_flush (array_cell (var));
 
+      /*************************************************************************
+       * For CSV format, do splitting like ${var|,}  --William
+       */
+      if (read_CSV_line)
+	  alist = string_minus_separator (input_string, "");
+      else		/* original code */
+      /************************************************************************/
       alist = list_string (input_string, ifs_chars, 0);
+
       if (alist)
 	{
 	  if (saw_escape)
@@ -598,11 +708,17 @@
      read and assigning them to variables. */
   orig_input_string = input_string;
 
+  /*****************************************************************************
+   * For CSV format, keep the leading and trailing whitespaces.  --William
+   */
+  if (! read_CSV_line) {		/* original code */
   /* Remove IFS white space at the beginning of the input string.  If
      $IFS is null, no field splitting is performed. */
   for (t = input_string; ifs_chars && *ifs_chars && spctabnl(*t) && isifs(*t); t++)
     ;
   input_string = t;
+  }
+  /****************************************************************************/
 
   for (; list->next; list = list->next)
     {
@@ -622,10 +738,27 @@
 	 the remaining variables are set to the empty string. */
       if (*input_string)
 	{
+	  /*********************************************************************
+	   * For CSV format, split on comma.  --William
+	   */
+	  if (read_CSV_line) {
+	      e = next_comma_in_csv (input_string);
+	      if (e) {
+		  *e = '\0';
+		  t = savestring (input_string);
+		  input_string = e + 1;		/* next field */
+	      } else {
+		  t = savestring (input_string);
+		  *input_string = '\0';		/* end of loop */
+	      }
+	  } else {		/* original code */
 	  /* This call updates INPUT_STRING. */
 	  t = get_word_from_string (&input_string, ifs_chars, &e);
 	  if (t)
 	    *e = '\0';
+	  }
+	  /********************************************************************/
+
 	  /* Don't bother to remove the CTLESC unless we added one
 	     somewhere while reading the string. */
 	  if (t && saw_escape)
@@ -666,6 +799,10 @@
       return (EXECUTION_FAILURE);
     }
 
+/*****************************************************************************
+ * For CSV format, keep the leading and trailing whitespaces.  --William
+ */
+  if (! read_CSV_line) {    /* original code */
 #if 0
   /* This has to be done this way rather than using string_list
      and list_string because Posix.2 says that the last variable gets the
@@ -684,7 +821,7 @@
 	input_string = strip_trailing_ifs_whitespace (t1, ifs_chars, saw_escape);
     }
 #endif
-
+  }
   if (saw_escape)
     {
       t = dequote_string (input_string);
--- bash-3.2_orig/builtins/reserved.def	2008-04-05 08:42:57.000000000 +0000
+++ bash-3.2/builtins/reserved.def	2008-04-05 08:43:09.000000000 +0000
@@ -201,3 +201,314 @@
 		commands should be saved on the history list.
 #endif /* HISTORY */
 $END
+
+
+/*******************************************************************************
+ * My additions  --William
+ */
+
+$BUILTIN case then else
+$DOCNAME case_then_else
+$SHORT_DOC case WORD in [PATTERN [| PATTERN]...[) | ))] COMMANDS (;;|;&|;;&)]... esac [then COMMANDS; else COMMANDS; fi]
+If PATTERN list is terminated by ')', it is glob.  If it's terminated by
+'))', it is regex, and matching is done via 'match' builtin.
+    case WORD in
+        GLOB ) ... ;;
+        REGEX )) ... ;;
+    esac
+For all GLOB, REGEX, and WORD patterns, shell expansions (parameter
+expansion, command substitution, arithmetic expansion) are performed.
+However, for GLOB, word splitting and quote removal are not done.  Whereas,
+for REGEX and WORD, quotes are removed, and only word splitting is not
+done.
+
+If there is a match, SUBMATCH will contain prefix, matching string and any
+parenthesized subgroups in regex pattern, and suffix, just like 'match'
+builtin.
+
+If COMMANDS list is terminated by ';&',
+    case ... in
+        ...) ... ;&
+        ...) ... ;;
+    esac
+then the next subsequent commands list is executed until ';;' or ';;&' is
+encountered.  (from Ksh/Zsh)
+
+If COMMANDS list is terminated by ';;&',
+    case ... in
+        ...) ... ;;&
+        ...) ... ;;
+    esac
+then the next pattern case is tested, even if current pattern matches.
+
+If optional then-else-fi is specified,
+    case ... in         case ... in             case ... in             
+        ...                 ...                     ...                 
+    esac then           esac then               esac else               
+        COMMANDS            COMMANDS                COMMANDS            
+    else                fi                      fi
+        COMMANDS
+    fi
+then the then COMMANDS or else COMMANDS will be executed at the end of case
+statement, when there is a match or no match, respectively.  Here, 'esac
+then' and 'esac else' cannot be separated by ';' or newlines.
+$END
+
+
+$BUILTIN for then else
+$DOCNAME for_then_else
+$SHORT_DOC for NAME [in WORDS ... ;] do COMMANDS; done [then COMMANDS; else COMMANDS; fi]
+If NAME is comma separated list of variables,
+    for a,b,c,... [in ...]; do
+        ...
+    done
+then list items are sequentially assigned to the variables.  If there is
+shortage of item, then the last loop will run with '' (null) assigned to
+leftover variables.
+
+If optional then-else-fi is specified,
+    for ...; do         for ...; do             for ...; do             
+        ...                 ...                     ...                 
+    done then           done then               done else               
+        COMMANDS            COMMANDS                COMMANDS            
+    else                fi                      fi
+        COMMANDS
+    fi
+then the then COMMANDS will be executed if the for-loop exits normally,
+and else COMMANDS will be executed if 'break' is used.  Here, 'done then'
+and 'done else' cannot be separated by ';' or newlines.
+$END
+
+
+$BUILTIN while then else
+$DOCNAME while_then_else
+$SHORT_DOC while COMMANDS; do COMMANDS; done [then COMMANDS; else COMMANDS; fi]
+If optional then-else-fi is specified,
+    while ...; do       while ...; do           while ...; do             
+        ...                 ...                     ...                 
+    done then           done then               done else               
+        COMMANDS            COMMANDS                COMMANDS            
+    else                fi                      fi
+        COMMANDS
+    fi
+then the then COMMANDS will be executed if the while-loop exits normally,
+and else COMMANDS will be executed if 'break' is used.  Here, 'done then'
+and 'done else' cannot be separated by ';' or newlines.
+$END
+
+
+$BUILTIN until then else
+$DOCNAME until_then_else
+$SHORT_DOC until COMMANDS; do COMMANDS; done [then COMMANDS; else COMMANDS; fi]
+If optional then-else-fi is specified,
+    until ...; do       until ...; do           until ...; do             
+        ...                 ...                     ...                 
+    done then           done then               done else               
+        COMMANDS            COMMANDS                COMMANDS            
+    else                fi                      fi
+        COMMANDS
+    fi
+then the then COMMANDS will be executed if the until-loop exits normally,
+and else COMMANDS will be executed if 'break' is used.  Here, 'done then'
+and 'done else' cannot be separated by ';' or newlines.
+$END
+
+
+$BUILTIN {a..b} {a--b} {**} {##} {^var}
+$DOCNAME sequence_generator
+$SHORT_DOC {int..int} {string--string} {**} {##} {^array}
+For {a..b}, generate integer sequence from 'a' to 'b' inclusive, using
+either {a,a+1,...,b-1,b} or {a,a-1,...,b+1,b}.  If 'a' or 'b' has leading
+0, then zero pad the numbers.  The format size is the maximum size of 'a'
+or 'b'.  Eg.
+    {1..5}              --> {1,2,3,4,5}
+    {05..01}            --> {05,04,03,02,01}
+
+If 'a' or 'b' is a regular shell variable (not positional parameter or
+array element), then replace it with its value $a or $b.  If 'a' or 'b'
+starts with '!', then indirect substitution will be tried, similiar to
+ ${!a} or ${!b}.  If 'a' or 'b' is '#', then replace it with $#.  In any
+case, if the final 'a..b' is pure number, then generate the corresponding
+integer sequence.  Eg.
+    {x..y}              --> seq $x $y
+    {!x..!y}            --> seq ${!x} ${!y}
+    {1..#}              --> seq 1 $#
+
+If the expression is 'a--b', where 'a' and 'b' are single letters, then
+generate letter sequence from 'a' to 'b'.  Uppercase and lowercase can
+be mixed, and the output will consist of letters only.  Eg.
+    {a--c}              --> {a,b,c}
+    {Z--c}              --> {Z,a,b,c}
+
+For {**} or {##}, do brace expansion using positional parameters, ie.
+{$1,$2,...} or {1,2,...$#} respectively.  If there are no parameters, then
+they expand to nothing, that is, they are removed along with preamble and
+postamble.
+
+For {^var}, do brace expansion using array elements.  If 'var' is empty
+array, then remove the pattern.
+
+Otherwise, return the original string back to shell as is, like before.
+$END
+
+
+$BUILTIN ${var|command}
+$DOCNAME list_comprehension
+$SHORT_DOC ${var|command}
+Run `command var`.  If it returns something, then use it instead of the
+original content in parameter expansion.  If it doesn't return anything
+(ie. returns NULL), then skip.  This is shell version of Python list
+comprehension.  The following special cases are recognized:
+
+    ${var|?command}
+        Run 'command var'.  If it returns success (0), then copy the
+        content in parameter expansion.
+    ${var|[a:b]}
+        Return Python-style [a:b] range.  For string, extract string[a:b].
+        For array or positional parameters, extract list[a:b].  For arrays,
+        it's referenced by storage order, not by index.  If ':b' is
+        missing, then string[a] or list[a] will be returned.  If index are
+        outside the range, then it will be removed from expansion.  This is
+        different from returning '' (null) string.
+    ${var|/regex}
+    ${var|=glob}
+        Return string that matches 'regex' or 'glob' pattern, which are
+        handled like 'case' statement pattern.
+    ${var|~regex}
+    ${var|!glob}
+        Complement of '/' or '='.  Return string that does not match 'regex'
+        or 'glob' pattern, which are handled like 'case' statement pattern.
+    ${var|,sep}
+        Split string on 'sep', and return list items.  If it's in double
+        quotes, then "$@" behaviour is followed.  If the variable is list,
+        then join items into single string using 'sep' as separator.  One
+        is inverse of the other.  If 'sep' is null, then the string is
+        treated as CSV (comma separated values), and splitted on comma
+        occurring outside of "...".
+    ${var|-regex}
+        Split string on 'regex'.  That is, remove 'regex' from the string,
+        and return non-matching segments as list items.  If it's in double
+        quotes, then "$@" behaviour is followed.  If variable is list, then
+        apply splitting for each string in the list.
+    ${var|+regex}
+        Split string on non-'regex'.  That is, extract 'regex' from the
+        string, and return matching segments as list items.  If it's in
+        double quotes, then "$@" behaviour is followed.  If variable is
+        list, then apply splitting for each string in the list.
+    ${var|regex}
+        Both '-regex' and '+regex'.  That is, split string on 'regex', and
+        return both matching and non-matching segments.  Char '' is 177,
+        0261, or 0xb1.
+    ${var|.strip}
+        Strip leading/trailing whitespaces, and collapse multiple
+        whitespaces to one space.  Same as `echo $var`.
+    ${var|.lrstrip}
+    ${var|.lstrip}
+    ${var|.rstrip}
+        Strip leading, trailing, or both leading/trailing whitespaces.
+    ${var|.strip0}
+        Strip leading '0' and whitespaces.
+    ${var|.upper}
+    ${var|.lower}
+    ${var|.swapcase}
+        Convert to uppercase, lowercase, or toggle the case.
+    ${var|.capitalize}
+        Capitalize the first char, and the rest to lowercase.
+    ${var|.capwords}
+        Capitalize all whitespace-delimited words.
+    ${var|.title}
+        Capitalize all alphabet words.
+    ${var|.ascii}
+        Convert to 7-bit ASCII by clearing the high bit (mask 0x7f).
+    ${var|.rev}
+        Flip string, like rev(1).
+    ${var|.singlequote}
+    ${var|.doublequote}
+    ${var|.backslashquote}
+    ${var|.ansicquote}
+        Quote string using '...', "...", \, or $'...' mechanism.
+    ${var|.csvquote}
+        Quote string for CSV format.  Essentially, " is doubled (""), and
+        the entire string is put in "..." if it contains comma, CR, or LF.
+    ${var|.csvdequote}
+        Dequote string from CSV format.  Essentially, "" is reduced to
+        single ", and single " is removed.
+    ${var|.htmlquote}
+        Convert < > & " ' chars to HTML/XML entities &lt; &gt; &amp; &quot;
+        &apos;
+    ${var|.regexquote}
+        Escape non-alphanumeric (plus '_') with backslash (\).
+    ${var|.urldequote}
+        Convert %xx to ASCII char, and '+' to space.
+    ${var|.cent}
+    ${var|.dollar}
+        Needed to handle "implied decimal".  If there is a decimal, then
+        the amount is in dollar.cent format; otherwise, it's in cent.
+        Convert one format to another.  Return "0" or "0.00" on error.
+    ${var|.base36}
+        Convert oct/dec/hex to base36 number [0-9A-Z].
+    ${var|>n}
+    ${var|<n}
+        Rotate right or left n chars.  Opposite direction if n is negative.
+    ${var|*n}
+        Copy string or list 'n' times.
+    ${var|%n.m}
+        Print string using '%n.ms' format of sprintf(3).
+    ${var|@key}
+        Quick and cheap emulation of associative array.  Given array with
+        linear sequence of key/value pairs, ie.
+            var=(key value key value ...)
+        for each matching 'key' string, return the next item as 'value'.
+        If it's in double quotes, then "$@" behaviour is followed.  If the
+        array name is specified without subscript, then var[@] is assumed.
+        If key is omitted, then array index and value are serialized.  This
+        is equivalent to "zipping" ${!var[@]} and ${var[@]}.
+$END
+
+
+$BUILTIN try
+$SHORT_DOC try COMMANDS; done [in CASE-PATTERN-LIST;; esac [then COMMANDS; else COMMANDS; fi]]
+Within try-block COMMANDS, 'raise' builtin can be used to set string
+exception.  If an exception is raised, then execution will break out of try
+block, just like 'break' out of for/until/while loops.  You can use
+optional case-like statement to catch the exception.  If the exception is
+caught, then it will be reset and execution will continue on following the
+try-block.  If the exception is not caught, then execution will break
+out upward until it is caught or until there is no more try-block.
+
+So, try-block is while-loop running only once, and case-like statement is
+handled by the normal case statement.  Typical usage would go like
+    try
+        raise
+    done in 
+        '') echo error ;;
+        *)  echo okey ;;
+    esac
+Here, 'done in' cannot be separated by ';' or newlines.
+$END
+
+
+$BUILTIN <<+
+$DOCNAME here_document_using_firstline
+$SHORT_DOC <<+ word
+Normally, <<- will strip all leading tabs from input lines.  If the
+redirection operator is <<+,
+    <<+word
+            here-document
+    delimiter
+then strip all indentations (tabs and spaces) on the first input line, and
+remove the same indentation from the rest of lines.  Tab is taken as 8
+spaces.  So, the delimiter line must not have more indentation than the
+first line.  This will preserve the indentation of here-document relative
+to the first line.
+$END
+
+
+$BUILTIN <<<<
+$DOCNAME here_file
+$SHORT_DOC <<<< word
+Here-file.  Same as here-document (<<), except it will read the template
+from file WORD.
+$END
+
+
--- bash-3.2_orig/builtins/subroutines.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/builtins/subroutines.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,2315 @@
+/*******************************************************************************
+ * Subroutines needed by my patch to main core and builtins.  These files are
+ * identical and should be hard linked:
+ *	builtins/subroutines.[ch]
+ *	examples/loadables/william/subroutines.[ch]
+ */
+
+#include <config.h>
+
+#if defined (HAVE_UNISTD_H)
+#  ifdef _MINIX
+#    include <sys/types.h>
+#  endif
+#  include <unistd.h>
+#endif
+
+#include <stdio.h>		/* puts(), printf(), BUFSIZ, ... */
+#include <errno.h>		/* legal_number_with_base() */
+
+#include "shell.h"		/* includes lots of headers */
+#include "bashansi.h"		/* string.h, strings.h, stdlib.h */
+#include "common.h"		/* builtin_error(), ... */
+#include "chartypes.h"		/* ISSPACE(), TOUPPER(), TOLOWER(), ... */
+#include "filecntl.h"		/* open() */
+#include "posixstat.h"		/* open() */
+
+#include "subroutines.h"
+
+
+/*******************************************************************************
+ * Variables */
+
+
+SHELL_VAR *
+bind_variable_if_legal (name, value)
+    char *name, *value;
+{
+    if (! legal_identifier (name)) {
+	sh_invalidid (name);
+	return (SHELL_VAR *)NULL;
+    }
+
+    return (bind_variable (name, value));
+}
+
+
+/* Return pointer to the content of string variables, ie. positional parameter,
+ * ordinary shell variable, array element.
+ */
+char *
+get_pointer_to (name)
+    char *name;
+{
+    char *t, **ref;
+    intmax_t i;
+
+    if (name == 0 || *name == 0)
+        return (char *)NULL;
+
+    t = (char *)NULL;
+
+    /* positional parameter */
+    if (legal_number (name, &i) && i >= 0 && (ref = get_parameter_reference (i))) {
+        t = *ref;
+    }
+    /* shell/array variable */
+    else if (legal_identifier (name)) {
+        t = get_string_value (name);
+    }
+    /* array element */
+    else if (valid_array_reference (name)) {
+        t = get_array_value (name, 0 /* allow_all */, (int *)NULL /* rtype */);
+    }
+
+    return (t);
+}
+
+
+/* Copy STRING into string variable, ie. positional parameter, ordinary shell
+ * variable, array element.   If APPEND is true, then append to the end of
+ * string, instead of replacing.  Return 0 on success, or -1 on error.
+ */
+int
+put_string_in (string, name, o_append)
+    char *string, *name;
+    int o_append;
+{
+    SHELL_VAR *var;
+    char *t, **ref;
+    intmax_t i;
+
+    if (name == 0 || *name == 0)
+        return (-1);
+
+    if (string == 0)
+	string = "";
+
+    var = (SHELL_VAR *)NULL;
+    ref = (char **)NULL;
+
+    /* positional parameter */
+    if (legal_number (name, &i) && i >= 0 && (ref = get_parameter_reference (i))) {
+        if (o_append) {
+            t = string_add (savestring (*ref), string);
+            FREE (*ref);
+            *ref = t;
+        } else {
+            FREE (*ref);
+            *ref = savestring (string);
+        }
+    }
+    /* shell/array variable */
+    else if (legal_identifier (name)) {
+        if (o_append) {
+            t = get_string_value (name);
+            if (t == 0)
+                t = "";
+            t = string_add (savestring (t), string);
+            var = bind_variable (name, t);
+            FREE (t);
+        } else {
+            var = bind_variable (name, string);
+        }
+    }
+    /* array element */
+    else if (valid_array_reference (name)) {
+        if (o_append) {
+            t = get_array_value (name, 0 /* allow_all */, (int *)NULL /* rtype */);
+            if (t == 0)
+                t = "";
+            t = string_add (savestring (t), string);
+            var = assign_array_element (name, t);
+            FREE (t);
+        } else {
+            var = assign_array_element (name, string);
+        }
+    }
+
+    if (var && readonly_p (var) == 0 && noassign_p (var) == 0) {
+        stupidly_hack_special_variables (name);
+    }
+
+    return (var || ref)? 0: -1;
+}
+
+
+/*******************************************************************************
+ * Numbers */
+
+
+/* Return success (1) if string or integer is 
+ *	- not NULL,
+ *	- not empty -- not really needed because legal_number() fails.
+ *	- positive (>= 0),
+ *	- within manageable size.
+ *
+ * The successfully converted integer is returned in N, if it's not NULL.  If
+ * tests fails, then return 0, and don't modify N even if it's not NULL.
+ */
+int
+legal_positive_integer (arg, n)
+    char *arg;
+    int *n;
+{
+    intmax_t x;
+
+    if (arg && *arg && legal_number (arg, &x) && x >= 0 && x == (int)x) {
+	if (n)
+	    *n = (int)x;
+	return (1);	/* success */
+    }
+    return (0);
+}
+
+
+/* Same as legal_positive_integer(), but can be negative.
+ */
+int
+legal_integer (arg, n)
+    char *arg;
+    int *n;
+{
+    intmax_t x;
+
+    if (arg && *arg && legal_number (arg, &x) && x == (int)x) {
+	if (n)
+	    *n = (int)x;
+	return (1);	/* success */
+    }
+    return (0);
+}
+
+
+/* Modified version of legal_number(), with option for base other than 10.
+ */
+int
+legal_number_with_base (string, result, base)
+    char *string;
+    intmax_t *result;
+    int base;
+{
+    intmax_t value;
+    char *ep;
+
+    if (result)
+	*result = 0;
+
+    errno = 0;
+    value = strtoimax (string, &ep, base /* was 10 */);
+    if (errno)
+	return 0;	/* errno is set on overflow or underflow */
+
+    /* Skip any trailing whitespace, since strtoimax does not. */
+    while (whitespace (*ep))
+	ep++;
+
+    /* If *string is not '\0' but *ep is '\0' on return, the entire string
+       is valid. */
+    if (string && *string && *ep == '\0')
+    {
+	if (result)
+	    *result = value;
+	/* The SunOS4 implementation of strtol() will happily ignore
+	   overflow conditions, so this cannot do overflow correctly
+	   on those systems. */
+	return 1;
+    }
+
+    return (0);
+}
+
+
+/* Modified version of legal_integer(), with option for base other than 10.
+ */
+int
+legal_integer_with_base (arg, n, base)
+    char *arg;
+    int *n, base;
+{
+    intmax_t x;
+
+    if (arg && *arg && legal_number_with_base (arg, &x, base) && x == (int)x) {
+	if (n)
+	    *n = (int)x;
+	return (1);	/* success */
+    }
+    return (0);
+}
+
+
+/* Integer version of fmax() and fmin().  Using function instead of #define,
+ * in case 'a' and 'b' need to be evaluated only once.
+ */
+int
+imax (a, b)
+    int a, b;
+{
+    return ((a > b) ? a : b);
+}
+int
+imin (a, b)
+    int a, b;
+{
+    return ((a < b) ? a : b);
+}
+
+
+/* Adjust Python-style [a:b] range to sensible values:
+ *	0 <= a <= b <= size
+ */
+void
+adjust_python_range (a, b, size)
+    int *a, *b, size;
+{
+    if (*a < 0) *a += size;
+    if (*a < 0) *a = 0;
+    if (*a > size) *a = size;
+
+    if (b) {
+	if (*b < 0) *b += size;
+	if (*b < 0) *b = 0;
+	if (*b > size) *b = size;
+	if (*b < *a) *b = *a;
+    }
+}
+
+
+/* Extract 'a' and 'b' from Python-style 'a:b' range.  Here, 'a' and 'b' must be
+ * integers, not arithmetic expressions as in parse_colon_range().  If you need
+ * arithmetic expression, then do something like
+ *	$((...)):$((...))
+ * If the range is well-formed, then return 1; otherwise, return 0.  If A and B
+ * are not NULL, then place the converted numbers there.
+ */
+int
+valid_python_range (range, pa, pb, size)
+    char *range;
+    int *pa, *pb, size;
+{
+    char *t;
+    int a, b;
+
+    t = xstrchr (range, ':');
+    if (t == 0) {
+	builtin_error ("`%s': expected a:b range", range);
+	return (0);
+    }
+
+    *t = '\0';
+    a = 0;
+    if (*range && ! legal_integer (range, &a)) {
+	sh_invalidnum (range);
+	return (0);
+    }
+
+    *t++ = ':';
+    b = size;
+    if (*t && ! legal_integer (t, &b)) {
+	sh_invalidnum (t);
+	return (0);
+    }
+
+    adjust_python_range (&a, &b, size);
+    if (pa) *pa = a;
+    if (pb) *pb = b;
+    return (1);		/* is valid */
+}
+
+
+/* Convert to cent, rounding any fractional cent.  Exactly 0.5 is rounded to the
+ * nearest even integer, like rint(3) or nearbyint(3).  Returns string
+ * representation of integer.  If there is error, it returns "0".
+ */
+char *
+convert_to_cent (val)
+    char *val;
+{
+    char *out, *t;
+    intmax_t x, y;
+    int sign;
+
+    x = y = 0;
+
+    out = strip_leading_trailing (val, STRIP_LR);
+    if (*out == '-') {
+	sign = -1;
+	*out = '0';	/* suppress +/- */
+    } else if (*out == '+') {
+	sign = 1;
+	*out = '0';	/* suppress +/- */
+    } else {
+	sign = 1;
+    }
+
+    t = strchr (out, '.');
+    if (t) {		/* out[].t[] --> dollar.cent */
+	*t++ = '\0';
+	if (all_digits (t) && (*out == '\0' || legal_number (out, &x))) {
+	    /* Got dollar 'x'.  Now, get cent 'y'. */
+	    if (t[0]) {
+		y = 10 * TODIGIT (t[0]);
+		if (t[1]) {	
+		    y += TODIGIT (t[1]);
+		    if (t[2]) {		/* see if cent needs to be rounded up */
+			if (t[2] >= '6' && t[2] <= '9') {
+			    y++;
+			} else if (t[2] == '5') {
+			    if (strpbrk (t + 3, "123456789"))
+				y++;	/* if greater than 0.5 */
+			    else if (TODIGIT (t[1]) % 2)
+				y++;	/* if 0.5 exactly, round up to next even integer */
+			}
+		    }
+		}
+	    }
+	} else {
+	    builtin_error ("`%s': invalid dollar amount", val);
+	}
+    } else {		/* already in cent.  Check for valid range. */
+	if (*out == '\0' || legal_number (out, &y)) {
+	} else {
+	    builtin_error ("`%s': invalid dollar amount", val);
+	}
+    }
+    FREE (out);
+    x = 100 * x + y;
+    if (sign < 0)
+	x = -x;
+    return (itos (x));
+}
+
+
+/* Convert to dollar.cent (%.2f) format.
+ */
+char *
+convert_to_dollar (val)
+    char *val;
+{
+    char *out;
+    int size;
+    intmax_t x, y;
+
+    out = convert_to_cent (val);	/* convert to cent, first */
+    size = strlen (out);
+
+    if (legal_number (out, &x)) {
+	out = (char *)xrealloc (out, size + 5);		/* minimum of "0.00" */
+	if (x < 0) {
+	    y = -x % 100;
+	    x = -x / 100;
+	    snprintf (out, size + 5, "-%jd.%02jd", x, y);
+	} else {
+	    y = x % 100;
+	    x = x / 100;
+	    snprintf (out, size + 5, "%jd.%02jd", x, y);
+	}
+	out[size + 4] = '\0';	/* just in case */
+    } else {
+	*out = '\0';
+	builtin_error ("`%s': invalid dollar amount", val);
+    }
+    return (out);
+}
+
+
+/* Convert from IN base to OUT base format, where IN base is 0 or [2,36] and OUT
+ * base is [2,36].
+ */
+char *
+convert_to_base36 (val, inbase, outbase)
+    char *val;
+    int inbase, outbase;
+{
+    uintmax_t xx;
+    int i, size;
+    char c, *t, *out;
+    char hex_map[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
+
+    if (inbase < 0 || inbase == 1 || inbase > 36 || outbase < 2 || outbase > 36)
+	return (char *)NULL;
+
+    if (! legal_number_with_base (val, &xx, inbase)) {
+	sh_invalidnum (val);
+	return (char *)NULL;
+    }
+
+    /* Read the bits from right to left.  Then, flip the pattern. */
+    t = out = (char *)xmalloc (8 * sizeof(uintmax_t) + 1);
+    do {
+	*t++ = hex_map[xx % outbase];
+	xx /= outbase;
+    } while (xx > 0);
+    *t = '\0';
+
+    size = t - out;
+    for (i = 0; i < size / 2; i++) {
+	c = out[i];
+	out[i] = out[size - 1 - i];
+	out[size - 1 - i] = c;
+    }
+    return (out);
+}
+
+
+/*******************************************************************************
+ * String */
+
+
+int
+count_in_string (c, s)		/* Count number of char in string. */
+    char c, *s;
+{
+    int n;
+
+    n = 0;
+    for ( ; *s; s++)
+	if (*s == c) 
+	    n++;
+    return (n);
+}
+
+
+/* Return string
+ *	command 'arg'
+ * which can be used as command substitution.  ARG is single quoted for another
+ * pass through shell, just like sh_single_quote(), but more conservative in
+ * memory allocation.  If ARG, is NULL, then empty string '' is used instead.
+ *
+ * It returns resized 'command' which is concatenated with the new ARG,
+ * separated by a space.  So, pass only a copy as 'command'.
+ */
+char *
+build_eval_string (command, arg)
+    char *command, *arg;
+{
+    char *eval_string, *t; 
+    size_t size, n;
+
+    if (arg == 0)
+	arg = "";
+
+    /* Each single quote (') becomes 4 chars ('\'').  Plus, two quotes at the
+     * beginning and the end.  So,
+     *	    ab'cd
+     * becomes 
+     *	    'ab'\''cd'
+     */
+    n = strlen(arg) + 3 * count_in_string ('\'', arg) + 2;
+    size = strlen (command);
+    eval_string = (char *)xrealloc (command, size + 1 + n + 1);
+
+    t = eval_string + size;
+    *t++ = ' ';
+    *t++ = '\'';
+    for ( ; *arg; arg++) {
+	*t++ = *arg;
+	if (*arg == '\'') {
+	    *t++ = '\\';
+	    *t++ = '\'';
+	    *t++ = '\'';	/* begin new quote */
+	}
+    }
+    *t++ = '\'';
+    *t = '\0';
+    return (eval_string);
+}
+
+
+/* Same as build_eval_string() above, but using substring(arg,a,b).
+ */
+char *
+build_eval_substring (command, arg, a, b)
+    char *command, *arg;
+    int a, b;
+{
+    char c, *out, *t;
+
+    t = substring (arg, a, b);
+    out = build_eval_string (command, t);
+    FREE (t);
+    return (out);
+}
+
+
+/* Run 
+ *	`command 'arg'`
+ * as command substitution, and return the output string which can be NULL.
+ * ARG is single quoted for another pass through shell.
+ */
+char *
+replace_string (command, arg)
+    char *command, *arg;
+{
+    char *out, *t; 
+
+    t = build_eval_string (savestring (command), arg);
+    out = command_substitute (t, 0);
+    FREE (t);
+    return (out);
+}
+
+
+/* Same as replace_string() above, but using substring(arg,a,b).
+ */
+char *
+replace_substring (command, arg, a, b)
+    char *command, *arg;
+    int a, b;
+{
+    char *out, *t; 
+
+    t = build_eval_substring (savestring (command), arg, a, b);
+    out = command_substitute (t, 0);
+    FREE (t);
+    return (out);
+}
+
+
+char *
+rotate_string (val, n)		/* +n=left, -n=right */
+    char *val;
+    int n;
+{
+    int i, size;
+    char *out;
+
+    size = strlen (val);
+    out = (char *)xmalloc (size + 1);
+
+    if (n >= 0) {
+	for (i = 0; i < size; i++)
+	    out[i] = val[(i + n) % size];
+    } else {
+	n = abs (n);
+	for (i = 0; i < size; i++)
+	    out[(i + n) % size] = val[i];
+    }
+    out[size] = '\0';
+    return (out);
+}
+
+
+/* Find comma in CSV string.  Skip over double quotes ("...").  Two
+ * consecutive double quotes ("") are quoted double-quote, but, for the purpose
+ * of splitting, it doesn't matter.  If no comma is found, then return NULL.
+ */
+char *
+next_comma_in_csv (csv)
+    char *csv;
+{
+    char *t;
+    int inside;
+
+    inside = 0;
+
+    for (t = csv; *t; t++) {
+	switch (*t) {
+	case '"':
+	    inside = (inside? 0: 1);	/* toggle */
+	    break;
+	case ',':
+	    if (! inside)	/* outside of "...", so return */
+		return (t);
+	    break;
+	}
+    }
+    return (char *)NULL;
+}
+
+
+/* Prepend substring(head, a, b) to WORD_LIST.
+ */
+WORD_LIST *
+prepend_substring_to_list (head, a, b, list)
+    char *head;
+    int a, b;		/* a <= b */
+    WORD_LIST *list;
+{
+    char c;
+
+    if (a <= b) {	/* if a > b, do nothing */
+	c = head[b];
+	head[b] = '\0';
+	list = make_word_list (make_bare_word (head + a), list);
+	head[b] = c;
+    }
+    return (list);
+}
+
+
+/* Split string on SEP separator, and return WORD_LIST.  If SEP is empty, then
+ * treat the string as CSV string, and split on unquoted comma.  It returns
+ * NULL, if string is NULL or empty (ie. nothing to split).
+ */
+WORD_LIST *
+string_minus_separator (head, sep)
+    char *head, *sep;
+{
+    char *body;
+    WORD_LIST *list;
+    int n;
+
+    if (head == 0 || *head == '\0' || sep == 0)
+	return (WORD_LIST *)NULL;
+
+    list = (WORD_LIST *)NULL;
+
+    n = strlen (sep);
+    if (n > 0) {
+	while (*head && (body = strstr (head, sep))) {
+	    list = prepend_substring_to_list (head, 0, body - head, list);
+	    head = body + n;
+	}
+    } else {		/* CSV string */
+	while (*head && (body = next_comma_in_csv (head))) {
+	    list = prepend_substring_to_list (head, 0, body - head, list);
+	    head = body + 1;
+	}
+    }
+    list = make_word_list (make_bare_word (head), list);
+    list = REVERSE_LIST (list, WORD_LIST *);
+    return (list);
+}
+
+
+/* Split string on BEGIN and END separators, and return WORD_LIST.  If separator
+ * is NULL or empty, then no splitting is done.  It returns NULL, if string is
+ * NULL or empty (ie. nothing to split).
+ */
+WORD_LIST *
+string_plusminus_begin_end (head, flag, begin, end)
+    char *head, *begin, *end;
+    char flag;		/* '+' or '-' */
+{
+    char *body, *tail;
+    WORD_LIST *list;
+    size_t a, b;
+
+    list = (WORD_LIST *)NULL;
+
+    if (head == 0 || *head == '\0')
+	return (list);
+    if (begin == 0 || *begin == '\0' || end == 0 || *end == '\0') {
+	if (flag != '+')
+	    list = make_word_list (make_bare_word (head), list);
+	return (list);
+    }
+
+    a = strlen (begin);
+    b = strlen (end);
+    while (*head && (body = strstr (head, begin))) {		/* found beginning */
+	body += a;
+	if (*body == '\0' || (tail = strstr (body, end)) == 0)	/* end not found */
+	    break;
+
+	/* ...BEGIN<body>...<tail>END... */
+
+	switch (flag) {
+	case '-':
+	    list = prepend_substring_to_list (head, 0, body - head - a, list);
+	    break;
+	case '+':
+	    list = prepend_substring_to_list (body, 0, tail - body, list);
+	    break;
+	default:		/* append both segments */
+	    list = prepend_substring_to_list (head, 0, body - head - a, list);
+	    list = prepend_substring_to_list (body, 0, tail - body, list);
+	    break;
+	}
+	head = body = tail + b;
+    }
+    if (flag != '+')
+	list = make_word_list (make_bare_word (head), list);
+    list = REVERSE_LIST (list, WORD_LIST *);
+    return (list);
+}
+
+
+/* Read the entire content of file descriptor FD, and return string.  Copied
+ * from read_comsub().  Buffer size of 128 shows up a lot in other places, but
+ * it's too small; use BUFSIZ from <stdio.h>, instead.  Return NULL if file
+ * descriptor is illegal.  Also, returns NULL if there is nothing to read (maybe
+ * should return empty string?).
+ */
+char *
+slurp_fd_into_string (fd)
+    int fd;
+{
+    char *out, buf[BUFSIZ];
+    ssize_t n;
+    int i, size;
+
+    if (sh_validfd (fd) == 0) {		/* taken from 'read' builtin */
+	builtin_error ("%d: invalid file descriptor", fd);
+	return (char *)NULL;
+    }
+
+    out = (char *)NULL;
+    size = i = 0;
+
+    while ((n = zread (fd, buf, sizeof(buf))) > 0) {
+	RESIZE_MALLOCED_BUFFER (out, i, n, size, BUFSIZ);
+	memcpy (out + i, buf, n);	/* don't stop at \0 */
+	i += n;
+    }
+    if (i > 0) {        /* if there is unterminated string */
+        RESIZE_MALLOCED_BUFFER (out, i, 1, size, BUFSIZ);
+        out[i] = '\0';
+    }
+
+    return (out);
+}
+
+
+/* Read the entire content of file FILENAME, and return string.  Copied from
+ * cat_file().  Return NULL if there is error in filename or file descriptor.
+ */
+char *
+slurp_filename_into_string (filename)
+    char *filename;
+{
+    int fd;
+    char *out;
+    struct stat finfo;
+
+    if (filename == 0 || *filename == '\0')
+	return (char *)NULL;
+
+    fd = open (filename, O_RDONLY);
+    if (fd < 0) {
+	file_error (filename);
+	return (char *)NULL;
+    }
+    if (fstat (fd, &finfo) == 0 && S_ISDIR (finfo.st_mode)) {
+        builtin_error ("`%s': trying to read from directory", filename);
+	close (fd);
+        return (char *)NULL;
+    }
+    out = slurp_fd_into_string (fd);
+    close (fd);
+    return (out);
+}
+
+
+/* Write string into file descriptor.  Return number of chars written, or -1 on
+ * error.
+ */
+int
+dump_string_into_fd (s, fd)
+    char *s;
+    int fd;
+{
+    if (s == 0)
+        return (-1);
+
+    if (sh_validfd (fd) == 0) {		/* taken from 'read' builtin */
+	builtin_error ("%d: invalid file descriptor", fd);
+	return (-1);
+    }
+    return (zwrite (fd, s, strlen(s)));
+}
+
+
+/* Write string into filename.  Return number of chars written, or -1 on error.
+ */
+int
+dump_string_into_filename (s, filename, o_append)
+    char *s, *filename;
+    int o_append;	/* 1=append, 0=trunc */
+{
+    int fd, count;
+
+    if (s == 0 || filename == 0 || *filename == '\0')
+	return (-1);
+
+    fd = open (filename, O_CREAT|O_WRONLY|(o_append? O_APPEND: O_TRUNC), 0666);
+    if (fd < 0) {
+	file_error (filename);
+	return (-1);
+    }
+    count = dump_string_into_fd (s, fd);
+    close (fd);
+    return (count);
+}
+
+
+/* Quote string into CSV format.  Essentially, " is doubled (""), and the entire
+ * string is put in "..." if it contains comma, CR, or LF.
+ */
+char *
+csv_quote (val)
+    char *val;
+{
+    char *out, *t;
+    int n, found;
+
+    n = strlen (val) + count_in_string ('"', val) + 2;
+    t = out = (char *)xmalloc (n + 1);
+
+    found = (strpbrk(val, ",\r\n") != (char *)NULL);
+    if (found)
+	*t++ = '"';
+    for ( ; *val; val++) {
+	*t++ = *val;
+	if (*val == '"')
+	    *t++ = '"';
+    }
+    if (found)
+	*t++ = '"';
+    *t = '\0';
+    return (out);
+}
+
+
+/* Dequote string from CSV format.  Essentially, "" is reduced to single ", and
+ * single " is removed.
+ */
+char *
+csv_dequote (val)
+    char *val;
+{
+    char *out, *t;
+
+    t = out = (char *)xmalloc (strlen (val) + 1);
+
+    for ( ; *val; val++) {
+	if (*val != '"')
+	    *t++ = *val;
+	else if (val[1] == '"')
+	    *t++ = *val++;
+    }
+    *t = '\0';
+    return (out);
+}
+
+
+/* Convert %xx to ASCII char, and '+' to space.
+ */
+char *
+url_dequote (val)
+    char *val;
+{
+    char *out, *t;
+
+    t = out = (char *)xmalloc (strlen (val) + 1);
+
+    for ( ; *val; val++) {
+	if (*val == '%' && ISXDIGIT (val[1]) && ISXDIGIT (val[2])) {
+	    *t++ = (HEXVALUE (val[1]) << 4) + HEXVALUE (val[2]);
+	    val += 2;
+	} else if (*val == '+')
+	    *t++ = ' ';
+	else 
+	    *t++ = *val;
+    }
+    *t = '\0';
+    return (out);
+}
+
+
+/* Escape HTML/XML special chars:
+ *	<	>	&	"	'
+ *	&lt;	&gt;	&amp;	&quot;	&apos;
+ */
+char *
+html_quote (val)
+    char *val;
+{
+    char *out, *t;
+    int n;
+
+    n = 0;
+    for (t = val; *t; t++) {
+	switch (*t) {
+	case '<': n += 4; break;
+	case '>': n += 4; break;
+	case '&': n += 5; break;
+	case '"': n += 6; break;
+	case '\'': n += 6; break;
+	default:  n++; break;
+	}
+    }
+    t = out = (char *)xmalloc (n + 1);
+    for ( ; *val; val++) {
+	switch (*val) {
+	case '<':  strcpy (t, "&lt;");    t += 4;  break;
+	case '>':  strcpy (t, "&gt;");    t += 4;  break;
+	case '&':  strcpy (t, "&amp;");   t += 5;  break;
+	case '"':  strcpy (t, "&quot;");  t += 6;  break;
+	case '\'': strcpy (t, "&apos;");  t += 6;  break;
+	default:
+	    *t++ = *val;
+	    break;
+	}
+    }
+    *t = '\0';
+    return (out);
+}
+
+
+/* Escape non-alphanumeric (plus '_') with backslash (\).
+ */
+char *
+regex_quote (val)
+    char *val;
+{
+    char *out, *t;
+    int n;
+
+    n = 0;
+    for (t = val; *t; t++) {
+	if (! ISWORD (*t))
+	    n++;
+	n++;
+    }
+    t = out = (char *)xmalloc (n + 1);
+    for ( ; *val; val++) {
+	if (! ISWORD (*val))
+            *t++ = '\\';
+        *t++ = *val;
+    }
+    *t = '\0';
+    return (out);
+}
+
+
+/* Strip leading/trailing whitespaces, and collapse multiple whitespaces to
+ * one space.  Same as `echo $var`.
+ */
+char *
+strip_leading_trailing (val, flag)
+    char *val;
+    int flag;
+{
+    char *out, *t;
+    int i, j, size;
+
+    size = strlen (val);
+
+    switch (flag) {
+    case STRIP_ALL:
+	for (i = 0; i < size && ISSPACE (val[i]); i++)
+	    ;
+	for (j = size - 1; i <= j && ISSPACE (val[j]); j--)
+	    ;
+	out = t = substring (val, i, j + 1);
+	for ( ; i < j + 1; i++) {
+	    if (! ISSPACE (val[i]))
+		*t++ = val[i];
+	    else if (! ISSPACE (val[i+1]))
+		*t++ = ' ';
+	}
+	*t = '\0';
+	return (out);
+
+    case STRIP_LR:
+	for (i = 0; i < size && ISSPACE (val[i]); i++)
+	    ;
+	for (j = size - 1; i <= j && ISSPACE (val[j]); j--)
+	    ;
+	out = substring (val, i, j + 1);
+	return (out);
+
+    case STRIP_L:
+	for (i = 0; i < size && ISSPACE (val[i]); i++)
+	    ;
+	j = size - 1;
+	out = substring (val, i, j + 1);
+	return (out);
+
+    case STRIP_R:
+	i = 0;
+	for (j = size - 1; i <= j && ISSPACE (val[j]); j--)
+	    ;
+	out = substring (val, i, j + 1);
+	return (out);
+
+    case STRIP_L0:	/* leading '0' and whitespaces */
+	while (*val && (ISSPACE (*val) || *val == '0'))
+	    val++;
+	return (savestring (val));
+    }
+}
+
+
+/* Remove trailing \r and \n, in-place.  Returns the string which was passed.
+ */
+char *
+strip_CRLF (s)
+    char *s;
+{
+    int size, i;
+
+    if (s && *s) {
+	size = strlen (s);
+	for (i = size - 1; i >= 0; i--)
+	    if (s[i] == '\r' || s[i] == '\n')
+		s[i] = '\0';
+	    else
+		break;
+    }
+    return (s);
+}
+
+
+char *
+string_add (old, new)		/* old += new */
+    char *old, *new;
+{
+    size_t i, n;
+
+    if (new && *new) {		/* something to add */
+	i = (old)? strlen (old): 0;
+	n = strlen (new);
+	old = (char *)xrealloc (old, i + n + 1);
+	strcpy (old + i, new);
+    }
+    return (old);
+}
+
+
+char *
+string_nadd (old, new, len)	/* old += new, and 'new' is not 0-terminated */
+    char *old, *new;
+    size_t len;
+{
+    size_t i;
+
+    if (new && *new && len) {		/* something to add */
+	i = (old)? strlen (old): 0;
+	old = (char *)xrealloc (old, i + len + 1);
+	strncpy (old + i, new, len);
+	old[i + len] = '\0';
+    }
+    return (old);
+}
+
+
+/* Returns 3-item list for "string matching", ie.
+ *      string  -->  prefix PATTERN suffix
+ */
+WORD_LIST *
+string_match_list (head, pattern)
+    char *head, *pattern;
+{
+    char *body, *tail;
+    WORD_LIST *list;
+
+    if (head == 0 || pattern == 0)
+        return (WORD_LIST *)NULL;
+
+    list = (WORD_LIST *)NULL;
+
+    if (*head && *pattern && (body = strstr (head, pattern))) {
+        tail = body + strlen (pattern);
+	list = prepend_substring_to_list (head, 0, body - head, list);
+	list = make_word_list (make_bare_word (pattern), list);
+	list = make_word_list (make_bare_word (tail), list);
+    }
+    list = REVERSE_LIST (list, WORD_LIST *);
+    return (list);
+}
+
+
+/* Returns 5-item list for "string interval matching", ie.
+ *      string  -->  prefix BEGIN middle END suffix
+ */
+WORD_LIST *
+string_interval_match_list (head, begin, end)
+    char *head, *begin, *end;
+{
+    char *body, *tail;
+    int a, b;
+    WORD_LIST *list;
+
+    if (head == 0 || begin == 0 || end == 0)
+        return (WORD_LIST *)NULL;
+
+    list = (WORD_LIST *)NULL;
+    a = strlen (begin);
+    b = strlen (end);
+
+    if (*head && *begin && (body = strstr (head, begin))) {	/* found beginning */
+	body += a;
+	if (*body && *end && (tail = strstr (body, end))) {	/* found end */
+	    /* ...BEGIN<body>...<tail>END... */
+	    list = prepend_substring_to_list (head, 0, body - head - a, list);
+	    list = make_word_list (make_bare_word (begin), list);
+	    list = prepend_substring_to_list (body, 0, tail - body, list);
+	    list = make_word_list (make_bare_word (end), list);
+	    list = make_word_list (make_bare_word (tail + b), list);
+	}
+    }
+    list = REVERSE_LIST (list, WORD_LIST *);
+    return (list);
+}
+
+
+/*******************************************************************************
+ * Positional parameters */
+
+
+/* Return pointer (ie. reference to, not a copy) to a positional parameter.
+ * Modified from get_dollar_var_value() which returns a copy.
+ */
+char **
+get_parameter_reference (i)
+    intmax_t i;
+{
+    char **out;
+    WORD_LIST *p;
+
+    if (i < 10) {
+        out = dollar_vars[i] ? &(dollar_vars[i]) : (char **)NULL;
+    } else {      /* We want something like ${11} */
+        i -= 10;
+        for (p = rest_of_args; p && i--; p = p->next)
+            ;
+        out = p ? &(p->word->word) : (char **)NULL;
+    }
+    return (out);
+}
+
+
+/* Assign list as positional parameters, flushing existing items.  Same as
+ * remember_args(list,1) without fluffs.
+ */
+void
+parameters_set_list (list)
+    WORD_LIST *list;		/* can be NULL, in which case just flush */
+{
+    int i;
+
+    for (i = 1; i < 10; i++) {
+	FREE (dollar_vars[i]);
+	dollar_vars[i] = (char *)NULL;
+	if (list) {
+	    dollar_vars[i] = savestring (list->word->word);
+	    list = list->next;
+	}
+    }
+    dispose_words (rest_of_args);
+    rest_of_args = copy_word_list (list);
+}
+
+
+/* Assign string vector as positional parameters, flushing existing items.
+ */
+void
+parameters_set_argv (v, alloc)
+    char **v;		/* can be NULL or empty, in which case just flush */
+    int alloc;
+{
+    int i, j, size;
+    WORD_DESC *w;
+    WORD_LIST *p;
+
+    j = 0;
+    for (i = 1; i < 10; i++) {		/* $1..$9 */
+	FREE (dollar_vars[i]);
+	dollar_vars[i] = (char *)NULL;
+	if (v && v[j]) {
+	    dollar_vars[i] = (alloc)? savestring (v[j]): v[j];
+	    j++;
+	}
+    }
+    dispose_words (rest_of_args);	/* $10, $11, ... */
+    rest_of_args = strvec_to_word_list (v, alloc, j);
+}
+
+
+/* Assign list to positional parameters, without flushing other items.  Can't
+ * use remember_args(), because it destroys existing content greater than $9.
+ * 'destructive=0' only works for $1..$9.
+ */
+void
+parameters_overwrite_list (list)
+    WORD_LIST *list;
+{
+    int i;
+    WORD_LIST *p, *a;
+
+    for (p = list, i = 1; i < 10 && p; i++, p = p->next) {
+	FREE (dollar_vars[i]);
+	dollar_vars[i] = savestring (p->word->word);
+    }
+    if (p) {		/* we got leftover for 'rest_of_args' */
+	list = copy_word_list (p);
+	if (rest_of_args) {
+	    a = rest_of_args;
+	    p = list;
+	    for ( ; a->next && p->next; a = a->next, p = p->next)
+		;
+	    if (a->next) {	/* old list is longer */
+		p->next = a->next;
+		a->next = (WORD_LIST *)NULL;
+	    }
+	    dispose_words (rest_of_args);
+	}
+	rest_of_args = list;
+    }
+}
+
+
+void
+parameters_append (arg)		/* append string to the end */
+    char *arg;
+{
+    int i;
+    WORD_LIST *p;
+
+    if (arg == 0)	/* required, because savestring() can't take NULL */
+	return;
+
+    for (i = 1; i < 10 && dollar_vars[i]; i++)
+	;
+    if (i < 10) {		/* one of $1..$9 */
+	dollar_vars[i] = savestring (arg);
+    } else {
+	p = make_word_list (make_bare_word (arg), (WORD_LIST *)NULL);
+	rest_of_args = (WORD_LIST *)list_append (rest_of_args, p);
+    }
+}
+
+
+void
+parameters_append_list (list)	/* append list to the end */
+    WORD_LIST *list;
+{
+    int i;
+    WORD_LIST *p;
+
+    for (i = 1; i < 10 && dollar_vars[i]; i++)
+	;
+    for (p = list; i < 10 && p; i++, p = p->next)	/* one of $1..$9 */
+	dollar_vars[i] = savestring (p->word->word);
+    if (p)
+	rest_of_args = (WORD_LIST *)list_append (rest_of_args, copy_word_list (p));
+}
+
+
+void
+parameters_push (arg)		/* push string to the front */
+    char *arg;
+{
+    int i;
+
+    if (arg == 0)	/* required, because savestring() can't take NULL */
+	return;
+
+    if (dollar_vars[9]) {
+	rest_of_args = make_word_list (make_bare_word (""), rest_of_args);
+	FREE (rest_of_args->word->word);
+	rest_of_args->word->word = dollar_vars[9];
+    }
+    for (i = 9; i > 1; i--)
+	dollar_vars[i] = dollar_vars[i - 1];
+    dollar_vars[1] = savestring (arg);
+}
+
+
+void
+parameters_push_list (list)	/* push list to the front */
+    WORD_LIST *list;
+{
+    WORD_LIST *p;
+
+    list = REVERSE_LIST (list, WORD_LIST *);
+    for (p = list; p; p = p->next)
+	parameters_push (p->word->word);
+    REVERSE_LIST (list, WORD_LIST *);
+}
+
+
+/*******************************************************************************
+ * List */
+
+
+/* Convert WORD_LIST to argv-style string vector (NULL terminated).  Same as
+ * strvec_from_word_list(), without fluffs.  Return NULL if list is empty,
+ * instead of returning an empty vector.  If PSIZE is non-zero, then size of
+ * list is returned.
+ */
+char **
+argv_from_list (list, alloc)
+     WORD_LIST *list;
+     int alloc;
+{
+    char **v, *t;
+    int i, size;
+
+    if (list == 0)
+	return (char **)NULL;
+
+    size = list_length (list);
+    v = strvec_create (size + 1);
+
+    for (i = 0; list; list = list->next, i++) {
+	t = list->word->word;
+	v[i] = (alloc)? savestring (t): t;
+    }
+    v[i] = (char *)NULL;
+    return (v);
+}
+
+
+/* Returns argv-style string vector containing positional parameter, without
+ * making copies of strings (if alloc=0).  Always returns valid pointer; if
+ * there is no parameter, then argv[0]=NULL.  If PSIZE is non-zero, then $# is
+ * returned.
+ */
+char **
+argv_from_parameters (alloc)
+    int alloc;
+{
+    char **v, *t;
+    int i, size;
+    WORD_LIST *p;
+
+    size = number_of_args ();
+    v = strvec_create (size + 1);
+
+    for (i = 0; i < 9 && i < size; i++) {
+	t = dollar_vars[i+1];
+	v[i] = (alloc)? savestring (t): t;
+    }
+    for (p = rest_of_args; p && i < size; i++, p = p->next) {
+	t = p->word->word;
+	v[i] = (alloc)? savestring (t): t;
+    }
+    v[i] = (char *)NULL;
+    return (v);
+}
+
+
+/* Remove one of $1..$9, then shift the higher ones down.  Taken from
+ * shift_builtin(), minus fluffs.
+ */
+void
+remove_dollar_var (i)
+    int i;
+{
+    WORD_LIST *p;
+
+    if (i < 1 || i > 9 || dollar_vars[i] == 0) 
+	return;
+
+    FREE (dollar_vars[i]);
+
+    for ( ; i < 9; i++)
+	dollar_vars[i] = dollar_vars[i + 1];
+
+    if (rest_of_args) {
+	p = rest_of_args;
+	dollar_vars[9] = savestring (p->word->word);
+	rest_of_args = p->next;
+	p->next = (WORD_LIST *)NULL;
+	dispose_words (p);
+    } else
+	dollar_vars[9] = (char *)NULL;
+}
+
+
+/* Remove the current list item.  If previous item is NULL, then it's the head
+ * of list, and return the new head.  If previous item is non-zero, then return
+ * the previous item.
+ */
+WORD_LIST *
+remove_list_item (oldp, p)
+    WORD_LIST *oldp, *p;
+{
+    WORD_LIST *newp;
+
+    if (oldp == 0 && p) {	/* 'p' is the head of list. */
+	newp = p->next;
+	p->next = (WORD_LIST *)NULL;
+	dispose_words (p);
+	return (newp);
+    } else if (oldp && p) {	/* 'p' is in the middle */
+	oldp->next = p->next;
+	p->next = (WORD_LIST *)NULL;
+	dispose_words (p);
+	return (oldp);
+    } else {
+	internal_error ("list item is already NULL");
+	return (oldp);
+    }
+}
+
+
+/* Read from file descriptor FD, where each string segment are terminated by \0
+ * (or SEP char).  Return WORD_LIST.  Similar to slurp_fd_into_string().
+ * If \0 or SEP char is found, then FOUNDSEP flag will be set to 1.  This is
+ * needed to determine if we're reading a string or list of string.
+ */
+WORD_LIST *
+slurp_fd_into_list (fd, sep, foundsep)
+    int fd, *foundsep;
+    char sep;
+{
+    char *out, buf[BUFSIZ];
+    ssize_t n;
+    int i, size, j, ichecked;
+    WORD_LIST *list;
+
+    if (sh_validfd (fd) == 0) {		/* taken from 'read' builtin */
+	builtin_error ("%d: invalid file descriptor", fd);
+	return (WORD_LIST *)NULL;
+    }
+
+    list = (WORD_LIST *)NULL;
+    ichecked = 0;
+    if (foundsep)
+        *foundsep = 0;
+
+    out = (char *)NULL;
+    size = i = 0;
+
+    while ((n = zread (fd, buf, sizeof(buf))) > 0) {
+	RESIZE_MALLOCED_BUFFER (out, i, n, size, BUFSIZ);
+	memcpy (out + i, buf, n);	/* don't stop at \0 */
+	i += n;
+
+        /* Search for \0.  If found, then copy the string into LIST, and shift
+         * the remaining input (next string) to the begining of OUT.
+         */
+        while (ichecked < i) {
+            while (ichecked < i && out[ichecked] != '\0' && out[ichecked] != sep) 
+                ichecked++;
+            if (ichecked < i && (out[ichecked] == '\0' || out[ichecked] == sep)) {
+                if (foundsep)
+                    *foundsep = 1;
+                list = prepend_substring_to_list (out, 0, ichecked, list);
+		ichecked++;	/* char after \0 */
+		memmove (out, out + ichecked, i - ichecked);
+                i -= ichecked;
+                ichecked = 0;
+            }
+        }
+    }
+    if (i > 0) {        /* if there is unterminated string */
+	list = prepend_substring_to_list (out, 0, i, list);
+    }
+
+    FREE (out);
+    list = REVERSE_LIST (list, WORD_LIST *);
+    return (list);
+}
+
+
+/* Read from file FILENAME, where each string segment are terminated by \0 (or
+ * SEP char).  Return WORD_LIST.  Similar to slurp_filename_into_string().
+ */
+WORD_LIST *
+slurp_filename_into_list (filename, sep, foundsep)
+    char *filename, sep;
+    int *foundsep;
+{
+    int fd;
+    struct stat finfo;
+    WORD_LIST *list;
+
+    if (filename == 0 || *filename == '\0')
+	return (WORD_LIST *)NULL;
+
+    fd = open (filename, O_RDONLY);
+    if (fd < 0) {
+	file_error (filename);
+	return (WORD_LIST *)NULL;
+    }
+    if (fstat (fd, &finfo) == 0 && S_ISDIR (finfo.st_mode)) {
+        builtin_error ("`%s': trying to read from directory", filename);
+	close (fd);
+        return (WORD_LIST *)NULL;
+    }
+    list = slurp_fd_into_list (fd, sep, foundsep);
+    close (fd);
+    return (list);
+}
+
+
+/* Write LIST into file descriptor.  Return the number of items successfully
+ * written, or -1 on error.
+ */
+int
+dump_list_into_fd (list, sep, fd)
+    WORD_LIST *list;
+    char sep;
+    int fd;
+{
+    char *s;
+    size_t size;
+    int count;
+
+    if (sh_validfd (fd) == 0) {		/* taken from 'read' builtin */
+	builtin_error ("%d: invalid file descriptor", fd);
+	return (-1);
+    }
+
+    count = 0;
+    for ( ; list; list = list->next) {
+	s = list->word->word;
+	size = strlen (s);
+	if (zwrite (fd, s, size) != size) {
+	    builtin_error ("failed to write a full string.");
+            return (-1);
+        }
+	if (zwrite (fd, &sep, 1) != 1) {
+	    builtin_error ("failed to write a terminator.");
+            return (-1);
+        }
+        count++;
+    }
+
+    return (count);
+}
+
+
+/* Write LIST into filename.  Return the number of items successfully written,
+ * or -1 on error.
+ */
+int
+dump_list_into_filename (list, sep, filename, o_append)
+    WORD_LIST *list;
+    char sep, *filename;
+    int o_append;	/* 1=append, 0=trunc */
+{
+    int fd, count;
+
+    if (filename == 0 || *filename == '\0')
+	return (-1);
+
+    fd = open (filename, O_CREAT|O_WRONLY|(o_append? O_APPEND: O_TRUNC), 0666);
+    if (fd < 0) {
+	file_error (filename);
+	return (-1);
+    }
+    count = dump_list_into_fd (list, sep, fd);
+    close (fd);
+    return (count);
+}
+
+
+/*******************************************************************************
+ * Array */
+
+
+#if defined (ARRAY_VARS)
+
+/* Convert array A to argv array of string (NULL terminated).  Same as
+ * array_to_argv(), but with option of not making copy of strings.
+ */
+char **
+argv_from_array (a, alloc)
+    ARRAY *a;
+    int alloc;
+{
+    char **v, *t;
+    int	i;
+    ARRAY_ELEMENT *ae;
+
+    if (a == 0 || array_empty (a))	 /* do nothing */
+	return (char **)NULL;
+
+    v = strvec_create (array_num_elements (a) + 1);
+    i = 0;
+    for (ae = element_forw (a->head); ae != a->head; ae = element_forw (ae)) {
+	t = element_value (ae);
+	v[i++] = (alloc)? savestring (t): t;
+    }
+    v[i] = (char *)NULL;
+    return (v);
+}
+
+
+/* Similar to name_to_arrayvar(), without error messages.
+ */
+SHELL_VAR *
+get_arrayvar (name, check_readonly)
+    char *name;
+    int check_readonly;
+{
+    SHELL_VAR *var;
+
+    if (! legal_identifier (name))
+	return (SHELL_VAR *)NULL;
+
+    var = find_variable (name);
+
+    if (var == 0 || invisible_p (var))
+	/* local variable can exist, but be invisible */
+	return (SHELL_VAR *)NULL;
+    else if (check_readonly && (readonly_p (var) || noassign_p (var)))
+	return (SHELL_VAR *)NULL;
+    else if (array_p (var) == 0 || array_cell (var) == 0)
+	return (SHELL_VAR *)NULL;
+
+    return (var);
+}
+
+
+/* Return array shell VAR corresponding to array string NAME.  Normally, it
+ * only checks for existence.  But, if CHECK_READONLY is set, then it checks if
+ * the array is readonly, in preparation for assignment.
+ *
+ * Modified from find_or_make_array_variable().  
+ */
+SHELL_VAR *
+name_to_arrayvar (name, check_readonly)
+    char *name;
+    int check_readonly;
+{
+    SHELL_VAR *var;
+
+    if (! legal_identifier (name)) {
+	sh_invalidid (name);
+	return (SHELL_VAR *)NULL;
+    }
+
+    var = find_variable (name);
+
+    if (var == 0 || invisible_p (var)) {
+	/* local variable can exist, but be invisible */
+	sh_notfound (name);
+	return (SHELL_VAR *)NULL;
+    }
+    else if (check_readonly && (readonly_p (var) || noassign_p (var))) {
+	sh_readonly (name);
+	return (SHELL_VAR *)NULL;
+    }
+    else if (array_p (var) == 0 || array_cell (var) == 0) {
+	builtin_error ("variable `%s' is not array", name);
+	return (SHELL_VAR *)NULL;
+    }
+
+    return (var);
+}
+
+
+/* Return array shell VAR corresponding to array string NAME.  Create new array
+ * variable, or convert existing variable to array.  If FLUSH is set, then flush
+ * it.  The returning array will be ready for "writing".
+ */
+SHELL_VAR *
+force_name_to_arrayvar (name, flush)
+    char *name;
+    int flush;		/* delete existing elements for clean start */
+{
+    SHELL_VAR *var;
+
+    if (! legal_identifier (name)) {
+	sh_invalidid (name);
+	return (SHELL_VAR *)NULL;
+    }
+
+    var = find_or_make_array_variable (name, 1 /* check for readonly */);
+    if (var && flush)
+	array_flush (array_cell (var));
+    return (var);
+}
+
+
+/* Copied from bind_array_variable().  Actually, array_insert() does the
+ * inserting "before" the head, which is effectively appending it because ARRAY
+ * is circular linked list.  If input string is NULL, use empty string ''
+ * instead.  Array element can have NULL as value, but it's not sensible.
+ */
+void
+arrayvar_insert (var, i, arg)
+    SHELL_VAR *var;
+    arrayind_t i;
+    char *arg;
+{
+    char *value;
+
+    if (arg == 0)
+	arg = "";
+
+    value = make_variable_value (var, arg);
+    if (var->assign_func)
+	(*var->assign_func) (var, value, i);
+    else
+	array_insert (array_cell (var), i, value);
+    FREE (value);
+}
+
+
+/* Like arrayvar_insert(), but using
+ *	substring (arg, a, b)
+ * without memory allocation and without checking [a,b] range.  This is usually
+ * okey, because [a,b] are generated in the same context and proximity as the
+ * string pointer.  WARNING
+ */
+void
+arrayvar_subinsert (var, i, arg, a, b)
+    SHELL_VAR *var;
+    arrayind_t i;
+    char *arg;
+    int a, b;
+{
+    char *t;
+
+    t = substring (arg, a, b);
+    arrayvar_insert (var, i, t);
+    FREE (t);
+}
+
+
+void
+arrayvar_append (var, arg)	/* append to the end */
+    SHELL_VAR *var;
+    char *arg;
+{
+    arrayind_t N;
+
+    N = array_max_index (array_cell (var));	/* -1 if empty */
+    arrayvar_insert (var, N+1, arg);
+}
+
+
+void
+arrayvar_subappend (var, arg, a, b)	/* append substring(arg,a,b) */
+    SHELL_VAR *var;
+    char *arg;
+    int a, b;
+{
+    arrayind_t N;
+
+    N = array_max_index (array_cell (var));	/* -1 if empty */
+    arrayvar_subinsert (var, N+1, arg, a, b);
+}
+
+
+/* Parse 'array[subscript]' expression, and return array name in NAME and the
+ * evaluated subscript in INDEX.  If both the name and the subscript are valid
+ * expression, then return success (1).  Otherwise, return error (0).  Whether
+ * the array name or index actually exists, is another matter.
+ *
+ * Copied from assign_array_element() which calls 
+ *	array_variable_name()	-- for array name
+ *	array_expand_index()	-- for array index
+ * It is designed to be used like
+ *	valid_array_reference()
+ * for testing array[subscript] expression, but with more info parsed out to the
+ * caller.
+ */
+int
+parse_array_subscript (string, name, index)
+    char *string, **name;
+    arrayind_t *index;
+{
+    char *sub;
+    int subend, flag;
+    arrayind_t i;
+    
+    sub = xstrchr (string, '[');
+    if (sub == 0) return (0);
+
+    *sub = '\0';
+    flag = legal_identifier (string);
+    *sub = '[';
+    if (flag == 0) return (0);
+    
+    subend = skipsubscript (sub, 0);	/* sub[0]='[', sub[subend]=']' */
+    if (sub[subend] != ']' || subend == 1 ||			/* [] */
+	    (ALL_ELEMENT_SUB (sub[1]) && sub[2] == ']'))	/* [@] [*] */
+	return (0);
+
+    i = array_expand_index (sub + 1, subend);
+    if (i < 0) return (0);
+
+    if (name)
+	*name = substring (string, 0, sub - string);
+    if (index)
+	*index = i;
+    return (1);
+}
+
+
+/* Cut out and return array element AE in array A.
+ */
+ARRAY_ELEMENT *
+cut_array_element (ae, a)
+    ARRAY_ELEMENT *ae;
+    ARRAY *a;
+{
+    if (a == 0 || array_empty (a))
+	return (ARRAY_ELEMENT *)NULL;
+
+    ae->next->prev = ae->prev;
+    ae->prev->next = ae->next;
+    a->num_elements--;
+    if (element_index (ae) == a->max_index)
+	a->max_index = element_index (ae->prev);
+
+    return (ae);
+}
+
+
+/* Cut out and remove array element AE in array A.
+ */
+void
+remove_array_element (ae, a)
+    ARRAY_ELEMENT *ae;
+    ARRAY *a;
+{
+    array_dispose_element (cut_array_element (ae, a));
+}
+
+
+/* Remove empty (null) elements.
+ */
+void
+array_prune (a)
+    ARRAY *a;
+{
+    int i;
+    ARRAY_ELEMENT *ae, *old;
+
+    for (ae = element_forw (a->head); ae != a->head; ae = element_forw (ae)) {
+	if (element_value (ae) && *(element_value (ae)) == '\0') {
+	    old = ae->prev;
+	    remove_array_element (ae, a);
+	    ae = old;
+	}
+    }
+}
+
+
+/* Set the index of array to i, i+1, i+2, ...
+ */
+void 
+re_index_array (a, i)
+    ARRAY *a;
+    arrayind_t i;
+{
+    ARRAY_ELEMENT *ae;
+
+    if (a == 0 || array_empty (a))	/* nothing to index */
+	return;
+
+    for (ae = element_forw (a->head); ae != a->head; ae = element_forw (ae))
+	element_index (ae) = i++;
+    a->max_index = i - 1;
+}
+
+
+/* Remove N elements from the front of array, then re-index.  So, pop'ing 0
+ * element will only adjust the indexes.
+ */
+void
+arrayvar_pop (var, n)
+    SHELL_VAR *var;
+    int n;
+{
+    ARRAY *a;
+
+    a = array_cell (var);
+
+    while (n-- > 0 && ! array_empty (a))
+	remove_array_element (element_forw (a->head), a);
+    re_index_array (a, 0);
+}
+
+
+/* Remove N elements from the end of array, then re-index.  So, triming 0
+ * element will only adjust the indexes.
+ */
+void
+arrayvar_trim (var, n)
+    SHELL_VAR *var;
+    int n;
+{
+    ARRAY *a;
+
+    a = array_cell (var);
+
+    while (n-- > 0 && ! array_empty (a))
+	remove_array_element (element_back (a->head), a);
+    re_index_array (a, 0);
+}
+
+
+/* Push string to the front of array, and re-index.
+ */
+void
+arrayvar_push (var, arg)
+    SHELL_VAR *var;
+    char *arg;
+{
+    if (arg == 0)
+	return;
+
+    re_index_array (array_cell (var), 1);	/* i=1,2,3,... */
+    arrayvar_insert (var, 0, arg);		/* i=0 */
+}
+
+
+/* Push list to the front of array, and re-index.  It's more efficient than
+ * pushing one by one, because indexes are adjusted only once.
+ */
+void
+arrayvar_push_list (var, list)
+    SHELL_VAR *var;
+    WORD_LIST *list;
+{
+    arrayind_t i;
+    ARRAY *a;
+
+    a = array_cell (var);
+    re_index_array (a, list_length (list));	/* i=n,n+1,... */
+    for (i = 0; list; list = list->next, i++)	/* i=0,1,...,n-1 */
+	arrayvar_insert (var, i, list->word->word);
+}
+
+
+/* Append list to the end of array.
+ */
+void
+arrayvar_append_list (var, list)
+    SHELL_VAR *var;
+    WORD_LIST *list;
+{
+    for (; list; list = list->next)
+	arrayvar_append (var, list->word->word);
+}
+
+
+/* Assign list into array, flushing existing array elements.
+ */
+void
+arrayvar_set_list (var, list)
+    SHELL_VAR *var;
+    WORD_LIST *list;
+{
+    ARRAY *a;
+
+    a = array_cell (var);
+    array_flush (a);
+    array_assign_list (a, list);
+}
+
+
+/* Serialize array (alternating index and value) and return WORD_LIST.
+ */
+WORD_LIST *
+serialize_arrayvar (var)
+    SHELL_VAR *var;
+{
+    ARRAY *a;
+    ARRAY_ELEMENT *ae;
+    char *t;
+    WORD_LIST *list;
+
+    list = (WORD_LIST *)NULL;
+    a = array_cell (var);
+
+    for (ae = element_forw (a->head); ae != a->head; ae = element_forw (ae)) {
+        t = itos (element_index (ae));
+        list = make_word_list (make_bare_word (t), list);
+        FREE (t);
+        t = element_value (ae);         /* not a copy */
+        list = make_word_list (make_bare_word (t), list);
+    }
+
+    list = REVERSE_LIST (list, WORD_LIST *);
+    return (list);
+}
+
+
+/* Populate array (alternating index and value) from WORD_LIST.  Returns the
+ * number of array elements populated, which should be 1/2 of list length.
+ * Return -1 on error.
+ */
+int
+deserialize_arrayvar (var, list)
+    SHELL_VAR *var;
+    WORD_LIST *list;
+{
+    int count;
+    intmax_t i;
+
+    count = 0;
+
+    for ( ; list; list = list->next) {
+        if (! legal_number (list->word->word, &i)) {
+            builtin_error ("`%s': invalid array index", list->word->word);
+            return (-1);
+        }
+        list = list->next;
+        if (list == 0) {
+            builtin_error ("odd number of list items");
+            return (-1);
+        }
+        arrayvar_insert (var, i, list->word->word);
+	count++;
+    }
+
+    return (count);
+}
+
+#endif	/* ARRAY_VARS */
+
+
+/*******************************************************************************
+ * Regex */
+
+
+#if defined (HAVE_POSIX_REGEXP)
+
+/* Both sys/types.h and regex.h (in that order) are specified in manpage.  But,
+ * sys/types.h is already included by sequence of
+ *	shell.h -> general.h -> bashtypes.h -> sys/types.h
+ *
+ * #include <sys/types.h>
+ */
+#include <regex.h>
+
+extern int glob_ignore_case;
+
+
+/* Split string on 'regex', and return list items.  If FLAG is '-', then remove
+ * 'regex' from the string and return non-matching segments.  If FLAG is '+',
+ * then extract 'regex' and return matching segments.  It returns NULL, if
+ * string is NULL or empty (ie. nothing to split).
+ */
+WORD_LIST *
+string_plusminus_regex (val, flag, regex)
+    char *val, *regex;
+    char flag;		/* '+' or '-' */
+{
+    regex_t preg;		/* size_t preg.re_nsub; */
+    regmatch_t *pmatch;
+    int cflags, eflags;
+    regoff_t a, b;
+
+    char *head, *body, *tail;
+    WORD_LIST *list;
+
+    if (val == 0 || *val == '\0' || regex == 0)
+	return (WORD_LIST *)NULL;
+
+    cflags = REG_EXTENDED;
+    if (glob_ignore_case) cflags |= REG_ICASE;
+
+    if (regcomp (&preg, regex, cflags)) {
+	builtin_error ("`%s': invalid regex", regex);
+	regfree (&preg);
+	return (WORD_LIST *)NULL;
+    }
+    pmatch = (regmatch_t *)xmalloc (1 * sizeof (regmatch_t));
+    eflags = 0;
+
+    list = (WORD_LIST *)NULL;
+    head = body = tail = val;
+
+    while (*body && regexec (&preg, body, 1, pmatch, eflags) == 0) {
+	body += pmatch[0].rm_so;
+	tail += pmatch[0].rm_eo;
+	if (body == tail) {	/* skip empty matches */
+	    body++;
+	    tail++;
+	} else {
+	    switch (flag) {
+	    case '-':
+		list = prepend_substring_to_list (head, 0, body - head, list);
+		break;
+	    case '+':
+		list = prepend_substring_to_list (body, 0, tail - body, list);
+		break;
+	    default:		/* append both segments */
+		list = prepend_substring_to_list (head, 0, body - head, list);
+		list = prepend_substring_to_list (body, 0, tail - body, list);
+		break;
+	    }
+	    head = body = tail;
+	}
+	eflags = REG_NOTBOL;
+    }
+    if (flag != '+')
+	list = make_word_list (make_bare_word (head), list);
+    list = REVERSE_LIST (list, WORD_LIST *);
+
+    FREE (pmatch);
+    regfree (&preg);
+    return (list);
+}
+
+
+/* Returns 3+ item list for "regex matching", ie.
+ *      string  -->  prefix SUBMATCH[0] SUBMATCH[1] ... SUBMATCH[n] suffix
+ * where SUBMATCH[0] is the entire regex string, and SUBMATCH[1..n] is
+ * parenthesized subgroups in regex pattern.
+ */
+WORD_LIST *
+regex_match_list (head, regex)
+    char *head, *regex;
+{
+    regex_t preg;		/* size_t preg.re_nsub; */
+    regmatch_t *pmatch;
+    int cflags, eflags;
+    regoff_t a, b;
+
+    WORD_LIST *list;
+    int i;
+
+    cflags = REG_EXTENDED;
+    if (glob_ignore_case) cflags |= REG_ICASE;
+
+    if (regcomp (&preg, regex, cflags)) {
+	builtin_error ("`%s': invalid regex", regex);
+	regfree (&preg);
+	return (WORD_LIST *)NULL;
+    }
+    pmatch = (regmatch_t *)xmalloc ((preg.re_nsub + 1) * sizeof (regmatch_t));
+    eflags = 0;
+
+    list = (WORD_LIST *)NULL;
+
+    if (regexec (&preg, head, preg.re_nsub + 1, pmatch, eflags) == 0) {
+	a = pmatch[0].rm_so;
+	list = prepend_substring_to_list (head, 0, a, list);
+	for (i = 0; i <= preg.re_nsub; i++) {
+	    a = pmatch[i].rm_so;
+	    b = pmatch[i].rm_eo;
+	    list = prepend_substring_to_list (head, a, b, list);
+	}
+	b = pmatch[0].rm_eo;
+	list = make_word_list (make_bare_word (head + b), list);
+    }
+
+    FREE (pmatch);
+    regfree (&preg);
+    list = REVERSE_LIST (list, WORD_LIST *);
+    return (list);
+}
+
+
+/* Returns 5-item list for "regex interval matching", ie.
+ *      string  -->  prefix BEGIN middle END suffix
+ */
+WORD_LIST *
+regex_interval_match_list (head, begin, end)
+    char *head, *begin, *end;
+{
+    regex_t preg, preg2;		/* size_t preg.re_nsub; */
+    regmatch_t *pmatch;
+    int cflags, eflags;
+    regoff_t a, b, a2, b2;
+
+    char *head2;
+    WORD_LIST *list;
+
+    cflags = REG_EXTENDED;
+    if (glob_ignore_case) cflags |= REG_ICASE;
+    cflags &= ~REG_NOSUB;	/* sub-index is needed to find the end pattern */
+
+    if (regcomp (&preg, begin, cflags)) {
+	builtin_error ("`%s': invalid regex", begin);
+	regfree (&preg);
+	return (WORD_LIST *)NULL;
+    }
+    if (regcomp (&preg2, end, cflags)) {
+	builtin_error ("`%s': invalid regex", end);
+	regfree (&preg);
+	regfree (&preg2);
+	return (WORD_LIST *)NULL;
+    }
+    pmatch = (regmatch_t *)xmalloc (1 * sizeof (regmatch_t));
+    eflags = 0;
+
+    list = (WORD_LIST *)NULL;
+
+    if (regexec (&preg, head, 1, pmatch, eflags) == 0) {
+	a = pmatch[0].rm_so;
+	b = pmatch[0].rm_eo;
+	head2 = head + b;
+	if (regexec (&preg2, head2, 1, pmatch, eflags) == 0) {
+	    a2 = pmatch[0].rm_so;
+	    b2 = pmatch[0].rm_eo;
+	    list = prepend_substring_to_list (head, 0, a, list);
+	    list = prepend_substring_to_list (head, a, b, list);
+	    list = prepend_substring_to_list (head2, 0, a2, list);
+	    list = prepend_substring_to_list (head2, a2, b2, list);
+	    list = make_word_list (make_bare_word (head2 + b2), list);
+	}
+    }
+    FREE (pmatch);
+    regfree (&preg);
+    regfree (&preg2);
+
+    list = REVERSE_LIST (list, WORD_LIST *);
+    return (list);
+}
+
+#endif	/* HAVE_POSIX_REGEXP */
+
+
+/*******************************************************************************
+ * Match */
+
+
+/* Returns
+ *      EXECUTION_SUCCESS (0)	-- pattern found
+ *      EXECUTION_FAILURE (1)	-- pattern not found
+ * 
+ * If SUBMATCH is specified, then it will contain
+ *	- prefix before regex match
+ *	- entire matching string (REGEX)
+ *	- parenthesized groups in regex pattern (group[1], group[2], ...)
+ *	- suffix after regex match
+ * ie.
+ *	submatch=( prefix REGEX group[1] group[2] ... group[n] suffix )
+ */
+/* Returns
+ *      EXECUTION_SUCCESS (0)	-- pattern found
+ *      EXECUTION_FAILURE (1)	-- pattern not found
+ *
+ * If SUBMATCH is specified, then 3 segments are returned.
+ *      submatch=( prefix PATTERN suffix )
+ */
+int
+match_engine (flag, string, pattern, submatch)
+    int flag;
+    char *string, *pattern, *submatch;
+{
+    SHELL_VAR *var;
+    WORD_LIST *list;
+
+    switch (flag) {
+#if defined (HAVE_POSIX_REGEXP)
+    case REGEX_MATCH:
+	list = regex_match_list (string, pattern);
+	break;
+#endif
+    case STRING_MATCH:
+    default:
+	list = string_match_list (string, pattern);
+	break;
+    }
+
+    if (submatch) {
+#if defined (ARRAY_VARS)
+	var = force_name_to_arrayvar (submatch, 1);
+	if (var == 0)
+	    return (EXECUTION_FAILURE);
+	array_assign_list (array_cell (var), list);
+#else
+	bind_variable_if_legal (submatch, (list)? (list->next)->word->word: "");
+#endif
+    }
+
+    dispose_words (list);
+    return (list)? EXECUTION_SUCCESS: EXECUTION_FAILURE;
+}
--- bash-3.2_orig/builtins/subroutines.h	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/builtins/subroutines.h	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,126 @@
+/* Stuffs from "subroutines.c".  These files are identical and should be hard
+ * linked:
+ *	builtins/subroutines.[ch]
+ *	examples/loadables/william/subroutines.[ch]
+ */
+
+/* Variables */
+
+extern SHELL_VAR *bind_variable_if_legal	__P((char *, char *));
+extern char *get_pointer_to             __P((char *));
+extern int put_string_in                __P((char *, char *, int));
+
+/* Numbers */
+
+extern int legal_positive_integer	__P((char *, int *));
+extern int legal_integer		__P((char *, int *));
+extern int legal_number_with_base	__P((char *, intmax_t *, int));
+extern int legal_integer_with_base	__P((char *, int *, int));
+extern int imin				__P((int, int));
+extern int imax				__P((int, int));
+extern void adjust_python_range		__P((int *, int *, int));
+extern int valid_python_range		__P((char *, int *, int *, int));
+extern char *convert_to_cent		__P((char *));
+extern char *convert_to_dollar		__P((char *));
+extern char *convert_to_base36		__P((char *, int, int));
+
+/* String */
+
+extern int count_in_string		__P((char, char *));
+extern char *build_eval_string		__P((char *, char *));
+extern char *build_eval_substring	__P((char *, char *, int, int));
+extern char *replace_string		__P((char *, char *));
+extern char *replace_substring		__P((char *, char *, int, int));
+extern char *rotate_string		__P((char *, int));
+extern char *next_comma_in_csv		__P((char *));
+extern WORD_LIST *prepend_substring_to_list	__P((char *, int, int, WORD_LIST *));
+extern WORD_LIST *string_minus_separator	__P((char *, char *));
+extern WORD_LIST *string_plusminus_begin_end	__P((char *, int, char *, char *));
+extern char *slurp_fd_into_string	__P((int));
+extern char *slurp_filename_into_string	__P((char *));
+extern int dump_string_into_fd		__P((char *, int));
+extern int dump_string_into_filename	__P((char *, char *, int));
+extern char *csv_quote			__P((char *));
+extern char *csv_dequote		__P((char *));
+extern char *url_dequote		__P((char *));
+extern char *html_quote			__P((char *));
+extern char *regex_quote		__P((char *));
+
+#define STRIP_ALL	0	/* leading, inside, trailing */
+#define STRIP_LR	1	/* leading, trailing */
+#define STRIP_L		2	/* leading */
+#define STRIP_R		3	/* trailing */
+#define STRIP_L0	4	/* leading 0s */
+extern char *strip_leading_trailing	__P((char *, int));
+extern char *strip_CRLF			__P((char *));
+
+extern char *string_add			__P((char *, char *));
+extern char *string_nadd		__P((char *, char *, size_t));
+extern WORD_LIST *string_match_list	__P((char *, char *));
+extern WORD_LIST *string_interval_match_list	__P((char *, char *, char *));
+
+/* Positional parameter */
+
+extern char **get_parameter_reference   __P((intmax_t));
+extern void parameters_set_list		__P((WORD_LIST *));
+extern void parameters_set_argv		__P((char **, int));
+extern void parameters_overwrite_list	__P((WORD_LIST *));
+extern void parameters_append		__P((char *));
+extern void parameters_append_list	__P((WORD_LIST *));
+extern void parameters_push		__P((char *));
+extern void parameters_push_list	__P((WORD_LIST *));
+
+/* List */
+
+extern char **argv_from_list		__P((WORD_LIST *, int));
+extern char **argv_from_parameters	__P((int));
+extern void remove_dollar_var		__P((int));
+extern WORD_LIST *remove_list_item	__P((WORD_LIST *, WORD_LIST *));
+extern WORD_LIST *slurp_fd_into_list		__P((int, char, int *));
+extern WORD_LIST *slurp_filename_into_list	__P((char *, char, int *));
+extern int dump_list_into_fd			__P((WORD_LIST *, char, int));
+extern int dump_list_into_filename		__P((WORD_LIST *, char, char *, int));
+
+/* Array */
+
+#if defined (ARRAY_VARS)
+extern char **argv_from_array		__P((ARRAY *, int));
+extern SHELL_VAR *get_arrayvar			__P((char *, int));
+extern SHELL_VAR *name_to_arrayvar		__P((char *, int));
+extern SHELL_VAR *force_name_to_arrayvar	__P((char *, int));
+extern void arrayvar_insert		__P((SHELL_VAR *, arrayind_t, char *));
+extern void arrayvar_subinsert		__P((SHELL_VAR *, arrayind_t, char *, int, int));
+extern void arrayvar_append		__P((SHELL_VAR *, char *));
+extern void arrayvar_subappend		__P((SHELL_VAR *, char *, int, int));
+extern int parse_array_subscript	__P((char *, char **, arrayind_t *));
+extern ARRAY_ELEMENT *cut_array_element __P((ARRAY_ELEMENT *, ARRAY *));
+extern void remove_array_element	__P((ARRAY_ELEMENT *, ARRAY *));
+extern void array_prune			__P((ARRAY *));
+extern void re_index_array		__P((ARRAY *, arrayind_t));
+extern void arrayvar_pop		__P((SHELL_VAR *, int));
+extern void arrayvar_trim		__P((SHELL_VAR *, int));
+extern void arrayvar_push		__P((SHELL_VAR *, char *));
+extern void arrayvar_push_list		__P((SHELL_VAR *, WORD_LIST *));
+extern void arrayvar_append_list	__P((SHELL_VAR *, WORD_LIST *));
+extern void arrayvar_set_list		__P((SHELL_VAR *, WORD_LIST *));
+extern WORD_LIST *serialize_arrayvar	__P((SHELL_VAR *));
+extern int deserialize_arrayvar		__P((SHELL_VAR *, WORD_LIST *));
+#endif
+
+/* Regex */
+
+#if defined (HAVE_POSIX_REGEXP)
+extern WORD_LIST *string_plusminus_regex	__P((char *, char, char *));
+extern WORD_LIST *regex_match_list		__P((char *, char *));
+extern WORD_LIST *regex_interval_match_list	__P((char *, char *, char *));
+#endif
+
+/* Match */
+
+#define REGEX_MATCH	0x1
+#define STRING_MATCH	0x2
+extern int match_engine		__P((int, char *, char *, char *));
+
+#define regex_match(s, pat, submatch)	match_engine (REGEX_MATCH, (s), (pat), (submatch))
+#define string_match(s, pat, submatch)	match_engine (STRING_MATCH, (s), (pat), (submatch))
+
--- bash-3.2_orig/command.h	2008-04-05 08:42:57.000000000 +0000
+++ bash-3.2/command.h	2008-04-05 08:54:44.000000000 +0000
@@ -28,7 +28,9 @@
 enum r_instruction {
   r_output_direction, r_input_direction, r_inputa_direction,
   r_appending_to, r_reading_until, r_reading_string,
+  r_reading_herefile,		/* <<<<  --William */
   r_duplicating_input, r_duplicating_output, r_deblank_reading_until,
+  r_deblank_reading_until_using_firstline,		/* <<+  --William */
   r_close_this, r_err_and_out, r_input_output, r_output_force,
   r_duplicating_input_word, r_duplicating_output_word,
   r_move_input, r_move_output, r_move_input_word, r_move_output_word
@@ -63,6 +65,7 @@
 
 /* Command Types: */
 enum command_type { cm_for, cm_case, cm_while, cm_if, cm_simple, cm_select,
+		    cm_try,		/* --William */
 		    cm_connection, cm_function_def, cm_until, cm_group,
 		    cm_arith, cm_cond, cm_arith_for, cm_subshell };
 
@@ -167,6 +170,7 @@
     struct for_com *For;
     struct case_com *Case;
     struct while_com *While;
+    struct try_com *Try;		/* --William */
     struct if_com *If;
     struct connection *Connection;
     struct simple_com *Simple;
@@ -204,6 +208,8 @@
   WORD_LIST *patterns;		/* Linked list of patterns to test. */
   COMMAND *action;		/* Thing to execute if a pattern matches. */
   int flags;
+  int glob_or_regex;    /* 0=glob, 1=regex  --William */
+  int goto_next;    /* 0=;; (original) 1=;&  2=;;&  --William */
 } PATTERN_LIST;
 
 /* The CASE command. */
@@ -212,6 +218,11 @@
   int line;			/* line number the `case' keyword appears on */
   WORD_DESC *word;		/* The thing to test. */
   PATTERN_LIST *clauses;	/* The clauses to test against, or NULL. */
+
+  COMMAND *true_case;		/* Commands to run, when there is a match  --William */
+  COMMAND *false_case;		/* Commands to run, when there is no match  --William */
+  int total_match;		/* total number of match  --William */
+
 } CASE_COM;
 
 /* FOR command. */
@@ -223,6 +234,10 @@
   COMMAND *action;	/* The action to execute.
 			   During execution, NAME is bound to successive
 			   members of MAP_LIST. */
+
+  COMMAND *then_action;		/* Commands to run, when loop exits normally  --William */
+  COMMAND *else_action;		/* Commands to run, when break is used  --William */
+
 } FOR_COM;
 
 #if defined (ARITH_FOR_COMMAND)
@@ -262,8 +277,24 @@
   int flags;			/* See description of CMD flags. */
   COMMAND *test;		/* Thing to test. */
   COMMAND *action;		/* Thing to do while test is non-zero. */
+
+  COMMAND *then_action;		/* Commands to run, when loop exits normally  --William */
+  COMMAND *else_action;		/* Commands to run, when break is used  --William */
+
 } WHILE_COM;
 
+
+/*******************************************************************************
+ * TRY command.  --William
+ */
+typedef struct try_com {
+  int flags;			/* See description of CMD flags. */
+  COMMAND *action;		/* try-block */
+  PATTERN_LIST *clauses;	/* The clauses to test against, or NULL. */
+} TRY_COM;
+/******************************************************************************/
+
+
 #if defined (DPAREN_ARITHMETIC)
 /* The arithmetic evaluation command, ((...)).  Just a set of flags and
    a WORD_LIST, of which the first element is the only one used, for the
--- bash-3.2_orig/config.h.in	2008-04-05 08:42:57.000000000 +0000
+++ bash-3.2/config.h.in	2008-04-05 08:43:09.000000000 +0000
@@ -162,6 +162,18 @@
 
 #include "config-top.h"
 
+
+/* --William */
+#undef	HAVE_POSTGRESQL
+#undef	HAVE_MYSQL
+#undef	HAVE_SQLITE
+#undef	HAVE_GDBM
+#undef	HAVE_EXPAT
+#undef	HAVE_LIBWEBSERVER
+#undef	HAVE_GTK2
+#undef	HAVE_GLIB2
+
+
 /* Beginning of autoconf additions. */
 
 /* Characteristics of the C compiler */
--- bash-3.2_orig/configure.in	2008-04-05 08:42:57.000000000 +0000
+++ bash-3.2/configure.in	2008-04-05 08:53:50.000000000 +0000
@@ -25,7 +25,7 @@
 AC_REVISION([for Bash 3.2, version 3.190])dnl
 
 define(bashvers, 3.2)
-define(relstatus, release)
+define(relstatus, bashdiff-1.44)  dnl was 'release'  --William
 
 AC_INIT([bash], bashvers-relstatus, [bug-bash@gnu.org])
 
@@ -202,6 +202,16 @@
 	opt_extended_glob=no opt_cond_command=no opt_arith_for_command=no
 	opt_net_redirs=no opt_progcomp=no opt_separate_help=no
 	opt_multibyte=yes opt_cond_regexp=no
+
+	# --William
+	opt_postgresql=no
+	opt_mysql=no
+	opt_sqlite=no
+	opt_gdbm=no
+	opt_expat=no 
+	opt_libwebserver=no
+	opt_gtk2=no
+	opt_glib2=no
 fi
 
 AC_ARG_ENABLE(alias, AC_HELP_STRING([--enable-alias], [enable shell aliases]), opt_alias=$enableval)
@@ -234,6 +244,67 @@
 AC_ARG_ENABLE(usg-echo-default, AC_HELP_STRING([--enable-usg-echo-default], [a synonym for --enable-xpg-echo-default]), opt_xpg_echo=$enableval)
 AC_ARG_ENABLE(xpg-echo-default, AC_HELP_STRING([--enable-xpg-echo-default], [make the echo builtin expand escape sequences by default]), opt_xpg_echo=$enableval)
 
+dnl /**************************************************************************/
+dnl The following require libraries or packages which may or may not be present.
+dnl Default is to include them if they are found.
+dnl --William
+
+opt_postgresql=yes
+
+dnl --disable-postgresql
+AC_ARG_ENABLE(postgresql, AC_HELP_STRING([--disable-postgresql], [(BashDiff) exclude PostgreSQL interface]), opt_postgresql=$enableval)
+
+opt_mysql=no
+dnl
+dnl MySQL interface is removed, due to name clash in MySQL-4.1.14
+dnl (my_list.h) for list functions.  MySQL-4.0.15a was okey.
+dnl --William
+dnl
+dnl --disable-mysql
+dnl AC_ARG_ENABLE(mysql, AC_HELP_STRING([--disable-mysql], [(BashDiff) exclude MySQL interface]), opt_mysql=$enableval)
+
+opt_sqlite=yes
+
+dnl --disable-sqlite
+AC_ARG_ENABLE(sqlite, AC_HELP_STRING([--disable-sqlite], [(BashDiff) exclude SQLite interface]), opt_sqlite=$enableval)
+
+opt_gdbm=yes
+
+dnl --disable-gdbm
+AC_ARG_ENABLE(gdbm, AC_HELP_STRING([--disable-gdbm], [(BashDiff) exclude GDBM interface]), opt_gdbm=$enableval)
+
+opt_expat=yes
+
+dnl --disable-expat
+AC_ARG_ENABLE(expat, AC_HELP_STRING([--disable-expat], [(BashDiff) exclude Expat (XML parser) interface]), opt_expat=$enableval)
+
+opt_libwebserver=yes
+
+dnl --disable-libwebserver
+AC_ARG_ENABLE(libwebserver, AC_HELP_STRING([--disable-libwebserver], [(BashDiff) exclude Libwebserver (embedded web server) interface]), opt_libwebserver=$enableval)
+
+opt_gtk2=yes
+
+dnl --disable-gtk2
+AC_ARG_ENABLE(gtk2, AC_HELP_STRING([--disable-gtk2], [(BashDiff) exclude GTK+2 interface]), opt_gtk2=$enableval)
+if test "$opt_gtk2" = yes; then
+  AM_PATH_GTK_2_0
+fi
+AC_SUBST([GTK2_CFLAGS])
+AC_SUBST([GTK2_LIBS])
+
+opt_glib2=yes
+
+dnl --disable-glib2
+AC_ARG_ENABLE(glib2, AC_HELP_STRING([--disable-glib2], [(BashDiff) exclude Glib2 interface]), opt_glib2=$enableval)
+if test "$opt_glib2" = yes; then
+  AM_PATH_GLIB_2_0
+fi
+AC_SUBST([GLIB2_CFLAGS])
+AC_SUBST([GLIB2_LIBS])
+
+dnl /**************************************************************************/
+
 dnl options that alter how bash is compiled and linked
 AC_ARG_ENABLE(mem-scramble, AC_HELP_STRING([--enable-mem-scramble], [scramble memory on calls to malloc and free]), opt_memscramble=$enableval)
 AC_ARG_ENABLE(profiling, AC_HELP_STRING([--enable-profiling], [allow profiling with gprof]), opt_profiling=$enableval)
@@ -648,6 +713,116 @@
 #endif
 ]])
 
+
+dnl /**************************************************************************/
+
+dnl Check for libpq-fe.h (PostgreSQL).  If it's not picked up automatically,
+dnl then try something like
+dnl	(cd /usr/local/include; ln -s ../pgsql/include pgsql)
+dnl	(cd /usr/local/lib;	ln -s ../pgsql/lib pgsql)
+dnl --William
+dnl
+if test $opt_postgresql = yes; then
+    AC_CHECK_HEADER(pgsql/libpq-fe.h)
+    if test "$ac_cv_header_pgsql_libpq_fe_h" = yes; then
+	AC_DEFINE(HAVE_POSTGRESQL)
+	POSTGRESQL_LIB=-lpq
+	if test -d /usr/local/lib/pgsql; then
+	    POSTGRESQL_LDFLAGS=-L/usr/local/lib/pgsql
+	fi
+	AC_SUBST(POSTGRESQL_LIB)
+	AC_SUBST(POSTGRESQL_LDFLAGS)
+    fi
+fi
+
+dnl Check for mysql.h (MySQL).  If it's not picked up automatically, then
+dnl try something like
+dnl	(cd /usr/local/include; ln -s ../mysql/include mysql)
+dnl	(cd /usr/local/lib;	ln -s ../mysql/lib mysql)
+dnl --William
+dnl
+if test $opt_mysql = yes; then
+    AC_CHECK_HEADER(mysql/mysql.h)
+    if test "$ac_cv_header_mysql_mysql_h" = yes; then
+	AC_DEFINE(HAVE_MYSQL)
+	MYSQL_LIB=-lmysqlclient
+	if test -d /usr/local/lib/mysql; then
+	    MYSQL_LDFLAGS=-L/usr/local/lib/mysql
+	fi
+	AC_SUBST(MYSQL_LIB)
+	AC_SUBST(MYSQL_LDFLAGS)
+    fi
+fi
+
+dnl Check for sqlite.h (SQLite).
+dnl --William
+dnl
+if test $opt_sqlite = yes; then
+    AC_CHECK_HEADER(sqlite.h)
+    if test "$ac_cv_header_sqlite_h" = yes; then
+	AC_DEFINE(HAVE_SQLITE)
+	SQLITE_LIB=-lsqlite
+	AC_SUBST(SQLITE_LIB)
+    fi
+fi
+
+dnl Check for gdbm.h (GDBM) from glibc.
+dnl --William
+dnl
+if test $opt_gdbm = yes; then
+    AC_CHECK_HEADER(gdbm.h)
+    if test "$ac_cv_header_gdbm_h" = yes; then
+	AC_DEFINE(HAVE_GDBM)
+	GDBM_LIB=-lgdbm
+	AC_SUBST(GDBM_LIB)
+    fi
+fi
+
+dnl Check for expat.h (Expat).
+dnl --William
+dnl
+if test $opt_expat = yes; then
+    AC_CHECK_HEADER(expat.h)
+    if test "$ac_cv_header_expat_h" = yes; then
+	AC_DEFINE(HAVE_EXPAT)
+	EXPAT_LIB=-lexpat
+	AC_SUBST(EXPAT_LIB)
+    fi
+fi
+
+dnl Check for web_server.h (Libwebserver).
+dnl --William
+dnl
+if test $opt_libwebserver = yes; then
+    AC_CHECK_HEADER(web_server.h)
+    if test "$ac_cv_header_web_server_h" = yes; then
+	AC_DEFINE(HAVE_LIBWEBSERVER)
+	LIBWEBSERVER_LIB=-lwebserver
+	AC_SUBST(LIBWEBSERVER_LIB)
+    fi
+fi
+
+dnl Check for GTK+ 2.0 (Slackware-10.1).  The following macro is copied
+dnl straight from 'man pkg-config'.
+dnl --William
+dnl
+if test $opt_gtk2 = yes; then
+    PKG_CHECK_MODULES(GTK2, gtk+-2.0 >= 2.6.0, [
+	AC_DEFINE(HAVE_GTK2)
+    ])
+fi
+
+dnl Check for Glib-2.0.  The following macro is copied straight from
+dnl 'man pkg-config'.
+dnl --William
+dnl
+if test $opt_glib2 = yes; then
+    PKG_CHECK_MODULES(GLIB2, glib-2.0 >= 2.6.0, [ AC_DEFINE(HAVE_GLIB2) ])
+fi
+
+dnl /**************************************************************************/
+
+
 dnl special checks for libc functions
 AC_FUNC_ALLOCA
 AC_FUNC_GETPGRP
@@ -1065,6 +1240,9 @@
 	done
 	test -d examples/loadables || mkdir examples/loadables	# loadable builtins
 	test -d examples/loadables/perl || mkdir examples/loadables/perl
+
+	# --William
+	test -d examples/loadables/william || mkdir examples/loadables/william
 	;;
 esac
 
@@ -1105,7 +1283,10 @@
 	  lib/malloc/Makefile lib/sh/Makefile lib/termcap/Makefile \
 	  lib/tilde/Makefile doc/Makefile support/Makefile po/Makefile.in \
 	  examples/loadables/Makefile examples/loadables/perl/Makefile \
+	  examples/loadables/william/Makefile \
 	  pathnames.h],
+# --William
+
 [
 # Makefile uses this timestamp file to record whether config.h is up to date.
 echo timestamp > stamp-h
--- bash-3.2_orig/copy_cmd.c	2008-04-05 08:42:57.000000000 +0000
+++ bash-3.2/copy_cmd.c	2008-04-05 08:43:09.000000000 +0000
@@ -85,6 +85,10 @@
   new_clause = (PATTERN_LIST *)xmalloc (sizeof (PATTERN_LIST));
   new_clause->patterns = copy_word_list (clause->patterns);
   new_clause->action = copy_command (clause->action);
+
+  new_clause->glob_or_regex = clause->glob_or_regex;	/* --William */
+  new_clause->goto_next = clause->goto_next;		/* --William */
+
   return (new_clause);
 }
 
@@ -116,9 +120,11 @@
     {
     case r_reading_until:
     case r_deblank_reading_until:
+    case r_deblank_reading_until_using_firstline:	/* <<+  --William */
       new_redirect->here_doc_eof = savestring (redirect->here_doc_eof);
       /*FALLTHROUGH*/
     case r_reading_string:
+    case r_reading_herefile:		/* <<<<  --William */
     case r_appending_to:
     case r_output_direction:
     case r_input_direction:
@@ -169,6 +175,10 @@
   new_for->name = copy_word (com->name);
   new_for->map_list = copy_word_list (com->map_list);
   new_for->action = copy_command (com->action);
+
+  new_for->then_action = copy_command (com->then_action);	/* --William */
+  new_for->else_action = copy_command (com->else_action);	/* --William */
+
   return (new_for);
 }
 
@@ -224,6 +234,11 @@
   new_case->line = com->line;
   new_case->word = copy_word (com->word);
   new_case->clauses = copy_case_clauses (com->clauses);
+
+  new_case->true_case = copy_command (com->true_case);		/* --William */
+  new_case->false_case = copy_command (com->false_case);	/* --William */
+  new_case->total_match = com->total_match;			/* --William */
+
   return (new_case);
 }
 
@@ -237,9 +252,29 @@
   new_while->flags = com->flags;
   new_while->test = copy_command (com->test);
   new_while->action = copy_command (com->action);
+
+  new_while->then_action = copy_command (com->then_action);	/* --William */
+  new_while->else_action = copy_command (com->else_action);	/* --William */
+
   return (new_while);
 }
 
+
+/* --William */
+static TRY_COM *
+copy_try_command (com)
+    TRY_COM *com;
+{
+    TRY_COM *new_try;
+
+    new_try = (TRY_COM *) xmalloc (sizeof (TRY_COM));
+    new_try->flags = com->flags;
+    new_try->action = copy_command (com->action);
+    new_try->clauses = copy_case_clauses (com->clauses);
+    return (new_try);
+}
+
+
 static IF_COM *
 copy_if_command (com)
      IF_COM *com;
@@ -382,6 +417,10 @@
 	new_command->value.While = copy_while_command (command->value.While);
 	break;
 
+      case cm_try:		/* --William */
+	new_command->value.Try = copy_try_command (command->value.Try);
+	break;
+
       case cm_if:
 	new_command->value.If = copy_if_command (command->value.If);
 	break;
--- bash-3.2_orig/dispose_cmd.c	2008-04-05 08:42:57.000000000 +0000
+++ bash-3.2/dispose_cmd.c	2008-04-05 08:43:09.000000000 +0000
@@ -59,6 +59,31 @@
 	dispose_word (c->name);
 	dispose_words (c->map_list);
 	dispose_command (c->action);
+
+	if (command->type == cm_for) {		/* --William */
+	    dispose_command (c->then_action);
+	    dispose_command (c->else_action);
+	}
+
+	free (c);
+	break;
+      }
+
+    case cm_try:		/* --William */
+    {
+	register TRY_COM *c;
+	PATTERN_LIST *t, *p;
+
+	c = command->value.Try;
+	dispose_command (c->action);
+	for (p = c->clauses; p; )
+	  {
+	    dispose_words (p->patterns);
+	    dispose_command (p->action);
+	    t = p;
+	    p = p->next;
+	    free (t);
+	  }
 	free (c);
 	break;
       }
@@ -100,6 +125,9 @@
 	c = command->value.Case;
 	dispose_word (c->word);
 
+	dispose_command (c->true_case);		/* --William */
+	dispose_command (c->false_case);	/* --William */
+
 	for (p = c->clauses; p; )
 	  {
 	    dispose_words (p->patterns);
@@ -120,6 +148,10 @@
 	c = command->value.While;
 	dispose_command (c->test);
 	dispose_command (c->action);
+
+	dispose_command (c->then_action);	/* --William */
+	dispose_command (c->else_action);	/* --William */
+
 	free (c);
 	break;
       }
@@ -305,9 +337,11 @@
 	{
 	case r_reading_until:
 	case r_deblank_reading_until:
+	case r_deblank_reading_until_using_firstline:	/* <<+  --William */
 	  free (t->here_doc_eof);
 	/*FALLTHROUGH*/
 	case r_reading_string:
+	case r_reading_herefile:		/* <<<<  --William */
 	case r_output_direction:
 	case r_input_direction:
 	case r_inputa_direction:
--- bash-3.2_orig/examples/loadables/william/Makefile.in	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/Makefile.in	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,206 @@
+#
+# Simple makefile for the sample loadable builtins
+#
+# Copyright (C) 1996 Free Software Foundation, Inc.     
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+
+# Include some boilerplate Gnu makefile definitions.
+prefix = @prefix@
+
+exec_prefix = @exec_prefix@
+bindir = @bindir@
+libdir = @libdir@
+infodir = @infodir@
+includedir = @includedir@
+
+topdir = @top_srcdir@
+BUILD_DIR = @BUILD_DIR@
+srcdir = @srcdir@
+VPATH = .:@srcdir@
+
+@SET_MAKE@
+CC = @CC@
+RM = rm -f
+
+SHELL = @MAKE_SHELL@
+
+host_os = @host_os@
+host_cpu = @host_cpu@
+host_vendor = @host_vendor@
+
+CFLAGS = @CFLAGS@
+LOCAL_CFLAGS = @LOCAL_CFLAGS@  $(GTK2_CFLAGS) $(GLIB2_CFLAGS)
+DEFS = @DEFS@
+LOCAL_DEFS = @LOCAL_DEFS@
+
+CCFLAGS = $(DEFS) $(LOCAL_DEFS) $(LOCAL_CFLAGS) $(CFLAGS)
+
+#
+# These values are generated for configure by ${topdir}/support/shobj-conf.
+# If your system is not supported by that script, but includes facilities for
+# dynamic loading of shared objects, please update the script and send the
+# changes to bash-maintainers@gnu.org.
+#
+SHOBJ_CC = @SHOBJ_CC@
+SHOBJ_CFLAGS = @SHOBJ_CFLAGS@
+SHOBJ_LD = @SHOBJ_LD@
+SHOBJ_LDFLAGS = @SHOBJ_LDFLAGS@
+SHOBJ_XLDFLAGS = @SHOBJ_XLDFLAGS@
+SHOBJ_LIBS = @SHOBJ_LIBS@
+SHOBJ_STATUS = @SHOBJ_STATUS@
+
+INC = -I. -I.. -I$(topdir) -I$(topdir)/lib -I$(topdir)/builtins \
+      -I$(topdir)/include -I$(BUILD_DIR) -I$(BUILD_DIR)/lib \
+      -I$(BUILD_DIR)/builtins
+
+.c.o:
+	$(SHOBJ_CC) $(SHOBJ_CFLAGS) $(CCFLAGS) $(INC) -c -o $@ $<
+
+ALLPROG = william.so
+
+all:	$(SHOBJ_STATUS)
+
+supported:	$(ALLPROG)
+
+unsupported:
+	@echo "Your system (${host_os}) is not supported by the"
+	@echo "${topdir}/support/shobj-conf script."
+	@echo "If your operating system provides facilities for dynamic"
+	@echo "loading of shared objects using the dlopen(3) interface,"
+	@echo "please update the script and re-run configure.
+	@echo "Please send the changes you made to bash-maintainers@gnu.org"
+	@echo "for inclusion in future bash releases."
+
+everything: supported
+
+clean:
+	$(RM) $(ALLPROG) *.o libbuiltins.a builtins.c builtext.h
+
+distclean: clean
+	$(RM) Makefile
+
+
+################################################################################
+# My stuffs ...
+#
+GDBM_LIB = @GDBM_LIB@
+EXPAT_LIB = @EXPAT_LIB@
+SQLITE_LIB = @SQLITE_LIB@
+POSTGRESQL_LIB = @POSTGRESQL_LIB@
+MYSQL_LIB = @MYSQL_LIB@
+LIBWEBSERVER_LIB = @LIBWEBSERVER_LIB@
+
+POSTGRESQL_LDFLAGS = @POSTGRESQL_LDFLAGS@
+MYSQL_LDFLAGS = @MYSQL_LDFLAGS@
+
+GTK2_LIBS = @GTK2_LIBS@
+GTK2_CFLAGS = @GTK2_CFLAGS@
+
+GLIB2_LIBS = @GLIB2_LIBS@
+GLIB2_CFLAGS = @GLIB2_CFLAGS@
+
+ALL_LIBS = $(GDBM_LIB) $(EXPAT_LIB) $(SQLITE_LIB) $(POSTGRESQL_LIB) $(MYSQL_LIB) $(LIBWEBSERVER_LIB) $(GTK2_LIBS) $(GLIB2_LIBS) -lm -lcrypt
+ALL_LDFLAGS = $(POSTGRESQL_LDFLAGS) $(MYSQL_LDFLAGS)
+
+ALL_OBJS = \
+    arraymap.o \
+    arrayunzip.o \
+    arrayzip.o \
+    basp.o \
+    binary.o \
+    cardswipe.o \
+    creditcard.o \
+    crypt.o \
+    expat.o \
+    fixedstring.o \
+    gdbm.o \
+    gtk.o \
+    herefile.o \
+    isnumber.o \
+    maskcard.o \
+    match.o \
+    multi.o \
+    mysql.o \
+    postgresql.o \
+    protobase.o \
+    rpn.o \
+    sqlite.o \
+    sscanf.o \
+    stack.o \
+    string.o \
+    strinterval.o \
+    subroutines.o \
+    tonumber.o \
+    tostring.o \
+    vcat.o \
+    vfile.o \
+    vplot.o \
+    vset.o \
+    webserver.o
+
+
+william.so: $(ALL_OBJS)
+	$(SHOBJ_LD) $(SHOBJ_LDFLAGS) $(SHOBJ_XLDFLAGS) $(ALL_LDFLAGS) -o $@ $(ALL_OBJS) $(ALL_LIBS) $(SHOBJ_LIBS)
+
+$(ALL_OBJS): subroutines.h loadables.h
+
+
+# Support an alternate destination root directory for package building
+DESTDIR =
+
+INSTALL = @INSTALL@
+
+install install-strip:
+	test -d $(DESTDIR)$(libdir) || mkdir -p $(DESTDIR)$(libdir)
+	$(INSTALL) -s -m 0755 william.so $(DESTDIR)$(libdir)
+
+
+################################################################################
+# Replacement of ../../../builtins/libbuiltins.a.  All builtins in this
+# directory are re-compiled for static link, and rolled into libbuiltins.a
+# together with the standard builtins.  You would do something like
+#
+# 	./configure
+# 	make			--> bash
+# 	make bash+william	--> bash + william.so
+#
+# To get the loadables back,
+#
+# 	cd examples/loadables/william
+# 	    make clean
+# 	    make		--> william.so
+#
+
+builtins.c: $(topdir)/builtins/builtins.c builtins.c.in
+	sed '/0x0,[^0]*0x0,[^0]*0,[^0]*0x0,[^0]*0x0/,$$ d' $<  > $@
+	cat builtins.c.in  >> $@
+	sed -n '/0x0,[^0]*0x0,[^0]*0,[^0]*0x0,[^0]*0x0/,$$ p' $<  >> $@
+
+builtext.h: $(topdir)/builtins/builtext.h builtext.h.in
+	cat $< builtext.h.in  > $@
+
+AR = @AR@
+ARFLAGS = @ARFLAGS@
+RANLIB = @RANLIB@
+
+libbuiltins.a: builtins.c builtext.h
+	$(RM) *.o
+	cp $(topdir)/builtins/*.o .
+	$(RM) builtins.o
+	$(CC) -c $(CCFLAGS) $(INC) *.c
+	$(RM) $@
+	$(AR) $(ARFLAGS) $@ *.o
+	-$(RANLIB) $@
--- bash-3.2_orig/examples/loadables/william/arraymap.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/arraymap.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,80 @@
+/*******************************************************************************
+ * Like Python's map().
+ */
+
+#include "loadables.h"
+
+
+#if defined (ARRAY_VARS)
+
+int
+arraymap_builtin (list)
+     WORD_LIST *list;
+{
+    char *command, *out, *t;
+    arrayind_t i, n;
+    SHELL_VAR *v;
+    WORD_LIST *p;
+    int ret;
+
+    if (no_options (list))
+	return (EX_BADUSAGE);
+    list = loptend;		/* skip over possible `--' */
+
+    if (list_length (list) < 2) {
+	builtin_usage ();
+	return (EX_BADUSAGE);
+    }
+
+    /* 2 or more arguments: arraymap command name... */
+
+    command = list->word->word; list = list->next;
+
+    n = -1;
+    for (p = list; p; p = p->next) {
+	v = name_to_arrayvar (p->word->word, 0);
+	if (v == 0)
+	    return (EXECUTION_FAILURE);
+	if (array_max_index (array_cell (v)) > n)
+	    n = array_max_index (array_cell (v));
+    }
+
+    /* command "${name[0]}" "${name[0]}" ...
+     * ...
+     * command "${name[n]}" "${name[n]}" ...
+     */
+    ret = EXECUTION_SUCCESS;
+    for (i = 0; i <= n; i++) {
+	out = savestring (command);
+	for (p = list; p; p = p->next) {
+	    v = find_variable (p->word->word);	/* already checked for errors */
+	    t = array_reference (array_cell (v), i);
+	    out = build_eval_string (out, t);		/* can be NULL */
+	}
+	    /* 'out' is freed */
+	ret = parse_and_execute (out, "arraymap", SEVAL_NOHIST | SEVAL_NONINT);
+    }
+    return (ret);
+}
+
+
+char *arraymap_doc[] = {
+    "Run COMMAND with command-line arguments taken from array elements in",
+    "parallel.  COMMAND should take as many positional parameters as there are",
+    "arrays.  This is equivalent to",
+    "    command \"${name[0]}\" \"${name[0]}\" ...",
+    "    command \"${name[1]}\" \"${name[1]}\" ...",
+    "    ...",
+    "    command \"${name[N]}\" \"${name[N]}\" ...",
+    "where N is the maximum of all indexes.  Array elements are referenced by",
+    "index, not by the order of storage.  So, there can be empty parameters.",
+    "This is shell version of Python map() function.",
+    (char *)NULL
+};
+struct builtin arraymap_struct = {
+    "arraymap", arraymap_builtin, BUILTIN_ENABLED, arraymap_doc,
+    "arraymap command name...",
+    (char *)NULL
+};
+
+#endif	/* ARRAY_VARS */
--- bash-3.2_orig/examples/loadables/william/arrayunzip.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/arrayunzip.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,65 @@
+/*******************************************************************************
+ * Inverse of 'arrayzip'.
+ */
+
+#include "loadables.h"
+
+
+#if defined (ARRAY_VARS)
+
+int
+arrayunzip_builtin (list)
+     WORD_LIST *list;
+{
+    char *t;
+    SHELL_VAR *v;
+    WORD_LIST *p, *input, *mv;
+
+    if (no_options (list))
+	return (EX_BADUSAGE);
+    list = loptend;		/* skip over possible `--' */
+
+    if (list == 0) {	        /* 0 argument */
+	builtin_usage ();
+	return (EX_BADUSAGE);
+    }
+
+    /* 1 or more arguments:  arrayunzip name...  */
+
+    for (mv = list; mv; mv = mv->next) {	/* check the names */
+	if (force_name_to_arrayvar (mv->word->word, 1) == 0)
+	    return (EXECUTION_FAILURE);
+    }
+
+    input = slurp_fd_into_list (0, '\0', (int *)NULL);
+
+    for (p = input, mv = list; p; p = p->next, mv = mv->next) {
+        if (mv == 0)
+            mv = list;
+        v = find_variable (mv->word->word); 	/* already checked for errors */
+        arrayvar_append (v, p->word->word);
+    }
+    for ( ; mv; mv = mv->next) {		/* assign leftovers */
+	v = find_variable (mv->word->word);
+	arrayvar_append (v, "");
+    }
+
+    dispose_words (input);
+    return (EXECUTION_SUCCESS);
+}
+
+
+char *arrayunzip_doc[] = {
+    "Inverse of 'arrayzip'.  Append \\0-terminated items from stdin into array",
+    "variables, similar to 'vset', wrapping around the variable list if",
+    "necessary.  Array variables are flushed first.  If items are short, then",
+    "'' (null) is appended to the leftover variables.",
+    (char *)NULL
+};
+struct builtin arrayunzip_struct = {
+    "arrayunzip", arrayunzip_builtin, BUILTIN_ENABLED, arrayunzip_doc,
+    "arrayunzip name... < file",
+    (char *)NULL
+};
+
+#endif	/* ARRAY_VARS */
--- bash-3.2_orig/examples/loadables/william/arrayzip.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/arrayzip.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,67 @@
+/*******************************************************************************
+ * Like Python's zip(), but squashed into linear sequence.
+ */
+
+#include "loadables.h"
+
+
+#if defined (ARRAY_VARS)
+
+int
+arrayzip_builtin (list)
+     WORD_LIST *list;
+{
+    char *t;
+    arrayind_t i, n;
+    SHELL_VAR *v;
+    WORD_LIST *mv;
+
+    if (no_options (list))
+	return (EX_BADUSAGE);
+    list = loptend;		/* skip over possible `--' */
+
+    if (list == 0) {		/* 0 argument */
+	builtin_usage ();
+	return (EX_BADUSAGE);
+    }
+
+    /* 1 or more arguments: arrayzip name... */
+
+    n = -1;		/* get max index of all arrays */
+    for (mv = list; mv; mv = mv->next) {
+	v = name_to_arrayvar (mv->word->word, 0);
+	if (v == 0)
+	    return (EXECUTION_FAILURE);
+	if (array_max_index (array_cell (v)) > n)
+	    n = array_max_index (array_cell (v));
+    }
+
+    for (i = 0; i <= n; i++) {
+	for (mv = list; mv; mv = mv->next) {
+	    v = find_variable (mv->word->word);	/* already checked for errors */
+	    t = array_reference (array_cell (v), i);
+	    if (t)
+		fputs (t, stdout);
+	    putchar ('\0');
+	}
+    }
+
+    fflush (stdout);
+    return (EXECUTION_SUCCESS);
+}
+
+
+char *arrayzip_doc[] = {
+    "Print array elements to stdout, going across the arrays in parallel.  Array",
+    "elements are referenced by index, not by the order of storage; so, there",
+    "can be empty parameters.  Each element is terminated by \\0, similar to",
+    "'vcat'.  This is shell version of Python zip() function.",
+    (char *)NULL
+};
+struct builtin arrayzip_struct = {
+    "arrayzip", arrayzip_builtin, BUILTIN_ENABLED, arrayzip_doc,
+    "arrayzip name... > file",
+    (char *)NULL
+};
+
+#endif	/* ARRAY_VARS */
--- bash-3.2_orig/examples/loadables/william/basp.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/basp.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,147 @@
+/*******************************************************************************
+ * BASP (Bash Server Pages).  Extract shell script within '<%...%>', and run it
+ * at the top level.  Print the surrounding text unchanged.  This is shell
+ * version of PHP, JSP, ASP, etc.
+ *	basp < file
+ *	basp file...
+ */
+
+#include "loadables.h"
+
+
+static int serve_out_string	__P((char *, char *, char *));
+
+
+/* Process embedded shell script, delimited by BEGIN and END string.  Non-script
+ * is printed to stdout.  Returns 1 immediately when embedded shell script
+ * fails.  Otherwise, return 0.
+ */
+static int
+serve_out_string (head, begin, end)
+    char *head, *begin, *end;
+{
+    char *body, *tail, c, *out;
+    size_t a, b, n;
+
+    if (head == 0 || *head == '\0')
+	return (0);
+    if (begin == 0 || *begin == '\0' || end == 0 || *end == '\0') {
+	fputs (head, stdout);
+	return (0);
+    }
+
+    a = strlen (begin);
+    b = strlen (end);
+    while (*head && (body = strstr(head, begin))) {		/* found beginning */
+	body += a;
+	if (*body == '\0' || (tail = strstr(body, end)) == 0)	/* end not found */
+	    break;
+
+	/* ...BEGIN<body>...<tail>END... */
+
+	n = body - head - a;
+	if (n > 0) {
+	    c = head[n];
+	    head[n] = '\0';
+	    fputs (head, stdout);
+	    head[n] = c;
+	}
+	n = tail - body;
+	if (n > 0) {
+	    if (*body == '=') {		/* 'echo -n ' + ... */
+		out = (char *)xmalloc (8 + (n-1) + 1);
+		strcpy (out, "echo -n ");
+		strncat (out, body + 1, n - 1);
+	    } else
+		out = substring (body, 0, n);
+	    /* 'out' is freed. */
+	    if (parse_and_execute (out, "basp", SEVAL_NOHIST | SEVAL_NONINT) != EXECUTION_SUCCESS)
+		return (1);
+	}
+	head = body = tail + b;
+    }
+    if (*head)
+	fputs (head, stdout);
+    return (0);
+}
+
+
+int
+basp_builtin (list)
+    WORD_LIST *list;
+{
+    char *begin, *end, *s;
+    int opt, retcount, fd;
+
+    begin = "<%";
+    end = "%>";
+
+    reset_internal_getopt ();
+    while ((opt = internal_getopt (list, "p:q:")) != -1) {
+	switch (opt) {
+	case 'p':
+	    begin = list_optarg;
+	    break;
+	case 'q':
+	    end = list_optarg;
+	    break;
+	default:
+	    builtin_usage ();
+	    return (EX_BADUSAGE);
+	}
+    }
+    list = loptend;		/* skip over possible `--' */
+
+    retcount = 0;
+
+    if (list == 0) {		/* read from stdin (fd=0) */
+	s = slurp_fd_into_string (0);
+	if (s == 0)
+	    retcount++;
+	else
+	    retcount += serve_out_string (s, begin, end);
+	FREE (s);
+    } else {
+	for ( ; list && retcount == 0; list = list->next) {
+	    s = slurp_filename_into_string (list->word->word);
+	    if (s == 0)
+		retcount++;
+	    else
+		retcount += serve_out_string (s, begin, end);
+	    FREE (s);
+	}
+    }
+    fflush (stdout);
+    return (retcount);
+}
+
+
+char *basp_doc[] = {
+    "Extract shell script within '<%...%>' delimiters (non-greedy, non-nesting),",
+    "and run it at the top level.  The input is read from FILE or stdin; and,",
+    "the output is sent to stdout, along with the surrounding text.  If shell",
+    "script returns error, then exit immediately with failure (1).  If shell",
+    "script is enclosed in '<%=...%>', then it is shorthand for '<%echo -n",
+    "...%>'.  If -pq options are given, then BEGIN and END are used as",
+    "delimiters, instead of '<%' and '%>'.",
+    "",
+    "Because it's running at top level, shell script segments share data and",
+    "environment with each other and with main shell session.  If you want to",
+    "isolate the main session, then run it in subshell.  This builtin is the",
+    "engine of BASP (Bash Server Pages) which allows you to embed shell scripts",
+    "in any text file.",
+    "",
+    "Eg.  If 'file' has the following content,",
+    "    <html> <% printf \"<x>%s</x> \" 1 2 3 %> </html>",
+    "then",
+    "    basp file",
+    "    basp < file",
+    "will print",
+    "    <html> <x>1</x> <x>2</x> <x>3</x>  </html>",
+    (char *) NULL
+};
+struct builtin basp_struct = {
+    "basp", basp_builtin, BUILTIN_ENABLED, basp_doc,
+    "basp [-p begin -q end] [file... | < file]",
+    (char *)NULL
+};
--- bash-3.2_orig/examples/loadables/william/binary.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/binary.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,94 @@
+/*******************************************************************************
+ * Convert from number from base[2,36] to base[2,36].  Default is to convert
+ * hex/dec/oct to binary.  Eg.
+ *	binary 15		--> 1111
+ */
+
+#include "loadables.h"
+
+
+int
+binary_builtin (list)
+    WORD_LIST *list;
+{
+    int opt, width, inbase, outbase, retval;
+    int i, size;
+    char *t;
+    WORD_LIST *headlist;
+
+    width = 0;
+    inbase = 0;		/* oct (0...), dec, or hex (0x...) */
+    outbase = 2;	/* binary */
+
+    reset_internal_getopt ();
+    while ((opt = internal_getopt (list, "i#w#o#")) != -1) {
+	switch (opt) {
+	case 'i':
+	    if (! legal_positive_integer (list_optarg, &inbase) || inbase == 1 || inbase > 36) {
+		builtin_error ("`%d': input base must be 0 or [2,36]", inbase);
+		return (EXECUTION_FAILURE);
+	    }
+	    break;
+	case 'o':
+	    if (! legal_positive_integer (list_optarg, &outbase) || outbase < 2 || outbase > 36) {
+		builtin_error ("`%d': output base must be [2,36]", outbase);
+		return (EXECUTION_FAILURE);
+	    }
+	    break;
+	case 'w':
+	    if (! legal_integer (list_optarg, &width)) {
+		sh_invalidnum (list_optarg);
+		return (EXECUTION_FAILURE);
+	    }
+	    break;
+	default:
+	    builtin_usage ();
+	    return (EX_BADUSAGE);
+	}
+    }
+    list = loptend;		/* skip over possible `--' */
+
+    headlist = (WORD_LIST *)NULL;
+    retval = EXECUTION_SUCCESS;
+
+    if (list == 0) {		/* 0 argument */
+	t = slurp_fd_into_string (0);	/* stdin */
+	if (t == 0)
+	    return (EXECUTION_FAILURE);
+	list = headlist = list_string (t, ifs_value, 0);
+	FREE (t);
+    }
+
+    for ( ; list; list = list->next) {
+	t = convert_to_base36 (list->word->word, inbase, outbase);
+	if (t) {
+	    size = strlen (t);
+	    for (i = 0; i < width - size; i++)
+		putchar ('0');		/* 0-pad on the left */
+	    puts (t);     /* one number per line */
+	} else
+	    retval = EXECUTION_FAILURE;
+	FREE (t);
+    }
+
+    dispose_words (headlist);
+    return (retval);
+}
+
+
+char *binary_doc[] = {
+    "By default, converts number (dec, oct, hex) to binary number.  But, any",
+    "base, from 2 to 36, can be specified for input (-i) and output (-o) number.",
+    "Since this is wrapper for strtoimax(), the input base 0 has the usual",
+    "meaning, ie. Octal if it starts with '0', Hex if it starts with '0x', or",
+    "Decimal otherwise.  If '-w' is specified, then output is zero-padded up to",
+    "'width'.  If command line arguments are missing, then the numbers are read",
+    "from stdin.",
+    "    binary -w8 20       --> 00010100",
+    (char *)NULL
+};
+struct builtin binary_struct = {
+    "binary", binary_builtin, BUILTIN_ENABLED, binary_doc,
+    "binary [-w width] [-io base] [number... | < file]",
+    (char *)NULL
+};
--- bash-3.2_orig/examples/loadables/william/builtext.h.in	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/builtext.h.in	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,154 @@
+#if defined (ARRAY_VARS)
+extern int arraymap_builtin __P((WORD_LIST *));
+extern char *arraymap_doc[];
+
+extern int arrayzip_builtin __P((WORD_LIST *));
+extern char *arrayzip_doc[];
+
+extern int arrayunzip_builtin __P((WORD_LIST *));
+extern char *arrayunzip_doc[];
+#endif
+
+extern int basp_builtin __P((WORD_LIST *));
+extern char *basp_doc[];
+
+#if defined (HAVE_EXPAT)
+extern int expat_builtin __P((WORD_LIST *));
+extern char *expat_doc[];
+#endif
+
+#if defined (HAVE_GDBM)
+extern int gdbm_builtin __P((WORD_LIST *));
+extern char *gdbm_doc[];
+#endif
+
+#if defined (HAVE_POSIX_REGEXP)
+extern int match_builtin __P((WORD_LIST *));
+extern char *match_doc[];
+#endif
+
+#if defined (HAVE_MYSQL)
+extern int Msql_builtin __P((WORD_LIST *));
+extern char *Msql_doc[];
+#endif
+
+#if defined (HAVE_POSTGRESQL)
+extern int Psql_builtin __P((WORD_LIST *));
+extern char *Psql_doc[];
+#endif
+
+#if defined (HAVE_SQLITE)
+extern int Lsql_builtin __P((WORD_LIST *));
+extern char *Lsql_doc[];
+#endif
+
+extern int sscanf_builtin __P((WORD_LIST *));
+extern char *sscanf_doc[];
+
+extern int pp_stack_builtin __P((WORD_LIST *));
+extern char *pp_append_doc[];
+extern char *pp_collapse_doc[];
+extern char *pp_prune_doc[];
+extern char *pp_flip_doc[];
+extern char *pp_overwrite_doc[];
+extern char *pp_pop_doc[];
+extern char *pp_push_doc[];
+extern char *pp_read_doc[];
+extern char *pp_rotateleft_doc[];
+extern char *pp_rotateright_doc[];
+extern char *pp_set_doc[];
+extern char *pp_sort_doc[];
+extern char *pp_swap_doc[];
+extern char *pp_transpose_doc[];
+extern char *pp_trim_doc[];
+extern char *pp_uniq_doc[];
+
+extern int strcat_builtin __P((WORD_LIST *));
+extern char *strcat_doc[];
+
+extern int strcpy_builtin __P((WORD_LIST *));
+extern char *strcpy_doc[];
+
+extern int strlen_builtin __P((WORD_LIST *));
+extern char *strlen_doc[];
+
+extern int strcmp_builtin __P((WORD_LIST *));
+extern char *strcmp_doc[];
+
+extern int strstr_builtin __P((WORD_LIST *));
+extern char *strstr_doc[];
+
+extern int strspn_builtin __P((WORD_LIST *));
+extern char *strspn_doc[];
+
+extern int strcspn_builtin __P((WORD_LIST *));
+extern char *strcspn_doc[];
+
+extern int vplot_builtin __P((WORD_LIST *));
+extern char *vplot_doc[];
+
+extern int binary_builtin __P((WORD_LIST *));
+extern char *binary_doc[];
+
+extern int tonumber_builtin __P((WORD_LIST *));
+extern char *tonumber_doc[];
+
+extern int tostring_builtin __P((WORD_LIST *));
+extern char *tostring_doc[];
+
+extern int isnumber_builtin __P((WORD_LIST *));
+extern char *isnumber_doc[];
+
+#if defined (HAVE_LIBWEBSERVER)
+extern int webserver_builtin __P((WORD_LIST *));
+extern char *webserver_doc[];
+
+extern int ClientInfo_builtin __P((WORD_LIST *));
+extern char *ClientInfo_doc[];
+#endif
+
+extern int herefile_builtin __P((WORD_LIST *));
+extern char *herefile_doc[];
+
+#if defined (HAVE_GTK2) && defined (HAVE_EXPAT)
+extern int gtk_builtin __P((WORD_LIST *));
+extern char *gtk_doc[];
+#endif
+
+extern int rpn_builtin __P((WORD_LIST *));
+extern char *rpn_doc[];
+
+extern int strinterval_builtin __P((WORD_LIST *));
+extern char *strinterval_doc[];
+
+extern int crypt_builtin __P((WORD_LIST *));
+extern char *crypt_doc[];
+
+extern int maskcard_builtin __P((WORD_LIST *));
+extern char *maskcard_doc[];
+
+extern int creditcard_builtin __P((WORD_LIST *));
+extern char *creditcard_doc[];
+
+extern int vcat_builtin __P((WORD_LIST *));
+extern char *vcat_doc[];
+
+extern int vset_builtin __P((WORD_LIST *));
+extern char *vset_doc[];
+
+extern int vfile_builtin __P((WORD_LIST *));
+extern char *vfile_doc[];
+
+#if defined (ARRAY_VARS)
+extern int protobase_builtin __P((WORD_LIST *));
+extern char *protobase_doc[];
+
+extern int multi_builtin __P((WORD_LIST *));
+extern char *multi_doc[];
+
+extern int fixedstring_builtin __P((WORD_LIST *));
+extern char *fixedstring_doc[];
+
+extern int cardswipe_builtin __P((WORD_LIST *));
+extern char *cardswipe_doc[];
+#endif
--- bash-3.2_orig/examples/loadables/william/builtins.c.in	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/builtins.c.in	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,295 @@
+#if defined (ARRAY_VARS)
+{
+    "arraymap", arraymap_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, arraymap_doc,
+    "arraymap command name...",
+    (char *)NULL
+},
+{
+    "arrayzip", arrayzip_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, arrayzip_doc,
+    "arrayzip name... > file",
+    (char *)NULL
+},
+{
+    "arrayunzip", arrayunzip_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, arrayunzip_doc,
+    "arrayunzip name... < file",
+    (char *)NULL
+},
+#endif
+{
+    "basp", basp_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, basp_doc,
+    "basp [-p begin -q end] [file... | < file]",
+    (char *)NULL
+},
+#if defined (HAVE_EXPAT)
+{
+    "expat", expat_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, expat_doc,
+    "expat [-sedicnm command] [file... | < file]",
+    (char *)NULL
+},
+#endif
+#if defined (HAVE_GDBM)
+{
+    "gdbm", gdbm_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, gdbm_doc,
+    "gdbm [-euikvr] [-KVW array] file [key | key value ...]",
+    (char *)NULL
+},
+#endif
+#if defined (HAVE_POSIX_REGEXP)
+{
+    "match", match_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, match_doc,
+    "match [-s] string regex [submatch]",
+    (char *)NULL
+},
+#endif
+#if defined (HAVE_MYSQL)
+{
+    "Msql", Msql_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, Msql_doc,
+    "Msql [-a array] [-h host -p port -d dbname -u user -P password ] SQL...",
+    (char *)NULL
+},
+#endif
+#if defined (HAVE_POSTGRESQL)
+{
+    "Psql", Psql_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, Psql_doc,
+    "Psql [-a array] [-h host -p port -d dbname -u user -P password ] SQL...",
+    (char *)NULL
+},
+#endif
+#if defined (HAVE_SQLITE)
+{
+    "Lsql", Lsql_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, Lsql_doc,
+    "Lsql [-a array] -d file SQL...",
+    (char *)NULL
+},
+#endif
+{
+    "sscanf", sscanf_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, sscanf_doc,
+    "sscanf input format var1 [... var9]",
+    (char *)NULL
+},
+{
+    "pp_append", pp_stack_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, pp_append_doc,
+    "pp_append [-a array] arg...",
+    (char *)NULL
+},
+{
+    "pp_collapse", pp_stack_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, pp_collapse_doc,
+    "pp_collapse [-a array]",
+    (char *)NULL
+},
+{
+    "pp_prune", pp_stack_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, pp_prune_doc,
+    "pp_prune [-a array]",
+    (char *)NULL
+},
+{
+    "pp_flip", pp_stack_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, pp_flip_doc,
+    "pp_flip [-a array]",
+    (char *)NULL
+},
+{
+    "pp_overwrite", pp_stack_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, pp_overwrite_doc,
+    "pp_overwrite [-a array] arg...",
+    (char *)NULL
+},
+{
+    "pp_pop", pp_stack_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, pp_pop_doc,
+    "pp_pop [-a array] [n]",
+    (char *)NULL
+},
+{
+    "pp_push", pp_stack_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, pp_push_doc,
+    "pp_push [-a array] arg...",
+    (char *)NULL
+},
+{
+    "pp_read", pp_stack_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, pp_read_doc,
+    "pp_read [-a array] name...",
+    (char *)NULL
+},
+{
+    "pp_rotateleft", pp_stack_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, pp_rotateleft_doc,
+    "pp_rotateleft [-a array] [n]",
+    (char *)NULL
+},
+{
+    "pp_rotateright", pp_stack_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, pp_rotateright_doc,
+    "pp_rotateright [-a array] [n]",
+    (char *)NULL
+},
+{
+    "pp_set", pp_stack_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, pp_set_doc,
+    "pp_set [-a array] arg...",
+    (char *)NULL
+},
+{
+    "pp_sort", pp_stack_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, pp_sort_doc,
+    "pp_sort [-a array]",
+    (char *)NULL
+},
+{
+    "pp_swap", pp_stack_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, pp_swap_doc,
+    "pp_swap [-a array]",
+    (char *)NULL
+},
+{
+    "pp_transpose", pp_stack_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, pp_transpose_doc,
+    "pp_transpose [-a array] n",
+    (char *)NULL
+},
+{
+    "pp_trim", pp_stack_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, pp_trim_doc,
+    "pp_trim [-a array] [n]",
+    (char *)NULL
+},
+{
+    "pp_uniq", pp_stack_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, pp_uniq_doc,
+    "pp_uniq [-a array] [-Ddui]",
+    (char *)NULL
+},
+{
+    "strcat", strcat_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, strcat_doc,
+    "strcat var [string [a:b] | < file]",
+    (char *)NULL
+},
+{
+    "strcpy", strcpy_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, strcpy_doc,
+    "strcpy var [string [a:b] | < file]",
+    (char *)NULL
+},
+{
+    "strlen", strlen_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, strlen_doc,
+    "strlen string...",
+    (char *)NULL
+},
+{
+    "strcmp", strcmp_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, strcmp_doc,
+    "strcmp [-i] string1 string2 [a:b]",
+    (char *)NULL
+},
+{
+    "strstr", strstr_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, strstr_doc,
+    "strstr string substring",
+    (char *)NULL
+},
+{
+    "strspn", strspn_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, strspn_doc,
+    "strspn string accept",
+    (char *)NULL
+},
+{
+    "strcspn", strcspn_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, strcspn_doc,
+    "strcspn string reject",
+    (char *)NULL
+},
+{
+    "vplot", vplot_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, vplot_doc,
+    "vplot [-0hv] [-x columns -y lines -X xtitle -Y ytitle] [xy | x y | x1 y1 x2 y2... | < file]",
+    (char *)NULL
+},
+{
+    "binary", binary_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, binary_doc,
+    "binary [-w width] [-io base] [number... | < file]",
+    (char *)NULL
+},
+{
+    "tonumber", tonumber_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, tonumber_doc,
+    "tonumber [string... | < file]",
+    (char *)NULL
+},
+{
+    "tostring", tostring_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, tostring_doc,
+    "tostring [number... | < file]",
+    (char *)NULL
+},
+{
+    "isnumber", isnumber_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, isnumber_doc,
+    "isnumber { alnum | alpha | ascii | blank | cntrl | digit | graph | lower | print | punct | space | upper | xdigit | letter | word } number...",
+    (char *)NULL
+},
+#if defined (HAVE_LIBWEBSERVER)
+{
+    "webserver", webserver_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, webserver_doc,
+    "webserver [-p port -[cl] logfile -L] glob command ...",
+    (char *)NULL
+},
+{
+    "ClientInfo", ClientInfo_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, ClientInfo_doc,
+    "ClientInfo [-ea] {{inetname|request|alias_request|method|user|pass} value | {Header|Query|Post|Cookie} key value | Conf topic key value}",
+    (char *)NULL
+},
+#endif
+{
+    "herefile", herefile_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, herefile_doc,
+    "herefile [file... | < file]",
+    (char *)NULL
+},
+#if defined (HAVE_GTK2) && defined (HAVE_EXPAT)
+{
+    "gtk", gtk_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, gtk_doc,
+    "gtk [file... | < file]",
+    (char *)NULL
+},
+#endif
+{
+    "rpn", rpn_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, rpn_doc,
+    "rpn [-feg precision] [-n maxcount] token...",
+    (char *)NULL
+},
+{
+    "strinterval", strinterval_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, strinterval_doc,
+    "strinterval [-r] string begin end [submatch]",
+    (char *)NULL
+},
+{
+    "crypt", crypt_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, crypt_doc,
+    "crypt key salt",
+    (char *)NULL
+},
+{
+    "maskcard", maskcard_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, maskcard_doc,
+    "maskcard [-b firstn] [-e lastn] number mask",
+    (char *)NULL
+},
+{
+    "creditcard", creditcard_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, creditcard_doc,
+    "creditcard [-c] number [weight]",
+    (char *)NULL
+},
+{
+    "vcat", vcat_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, vcat_doc,
+    "vcat [-0A] [name] > file",
+    (char *)NULL
+},
+{
+    "vset", vset_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, vset_doc,
+    "vset [-0A] [name] < file",
+    (char *)NULL
+},
+{
+    "vfile", vfile_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, vfile_doc,
+    "vfile -[rw] [-d dir] [-0A] name...",
+    (char *)NULL
+},
+#if defined (ARRAY_VARS)
+{
+    "protobase", protobase_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, protobase_doc,
+    "protobase {-r name < file | -w name > file}",
+    (char *)NULL
+},
+{
+    "multi", multi_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, multi_doc,
+    "multi {-r msg ANS RCP RCT < file | -w length data > file}",
+    (char *)NULL
+},
+{
+    "fixedstring", fixedstring_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, fixedstring_doc,
+    "fixedstring {-r length data < file | -w[LCR] [-0] length data > file}",
+    (char *)NULL
+},
+{
+    "cardswipe", cardswipe_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, cardswipe_doc,
+    "cardswipe -[12] array [-c] {-r < file | -w > file}",
+    (char *)NULL
+},
+#endif
--- bash-3.2_orig/examples/loadables/william/cardswipe.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/cardswipe.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,226 @@
+/*******************************************************************************
+ * Read/write magnetic card swipe from stdin or string, and extract track1 and
+ * track2 data.  Return shell arrays containing track segments.
+ * 
+ * Track 1:	%B<PAN>^<surname>/<firstname>^...?
+ *	- 'B' = American Banking Association
+ *	- upto 78 chars total
+ *	- char set is 0x20-0x7F
+ *	- upto 19 digits for primary account number <PAN>
+ *	- upto 26 chars for <surname>/<firstname>
+ *
+ * Track 2:	;<PAN>=...?
+ *	- upto 39 chars total
+ *	- char set is [0-9:;<=>?] or 0x30-0x3F
+ *	- upto 19 digits for primary account number <PAN>
+ *	
+ * Track 1 and 2:
+ *	%B...^...?;...=...?
+ */
+
+#include "loadables.h"
+
+#define failed(msg)	do { builtin_error (msg); retval = EXECUTION_FAILURE; } while (0)
+
+static int readtrack	__P((SHELL_VAR *, SHELL_VAR *, int));
+static int writetrack	__P((SHELL_VAR *, SHELL_VAR *, int));
+
+
+#if defined (ARRAY_VARS)
+
+static int
+readtrack (var1, var2, check_flag)
+    SHELL_VAR *var1, *var2;
+    int check_flag;
+{
+    char *swipe, *t;
+    int retval;
+    WORD_LIST *p1, *p2, *track1, *track2;
+
+    swipe = slurp_fd_into_string (0);
+    p1 = p2 = track1 = track2 = (WORD_LIST *)NULL;
+
+    retval = EXECUTION_SUCCESS;
+
+    /* Track1 must be consumed first, because ';', which starts track2, can
+     * occur in track1 data.
+     */
+    p1 = string_interval_match_list (swipe, "%B", "?");
+    if (var1) {
+        if (p1) {
+            t = (p1->next->next)->word->word;
+            track1 = string_minus_separator (t, "^");
+            if (track1)
+                array_assign_list (array_cell (var1), track1);
+            else if (check_flag)
+                failed ("track1 is empty");
+        } else if (check_flag)
+            failed ("track1 not found");
+    }
+
+    if (p1 == 0)
+	p2 = string_interval_match_list (swipe, ";", "?");
+    else {
+	/* Track2 should come after track1.  If not, then look for track2 before
+	 * track1. */
+	p2 = string_interval_match_list ((p1->next->next->next->next)->word->word, ";", "?");
+	if (p2 == 0)
+	    p2 = string_interval_match_list (p1->word->word, ";", "?");
+    }
+    if (var2) {
+        if (p2) {
+            t = (p2->next->next)->word->word;
+            track2 = string_minus_separator (t, "=");
+            if (track2)
+                array_assign_list (array_cell (var2), track2);
+            else if (check_flag)
+                failed ("track2 is empty");
+        } else if (check_flag)
+            failed ("track2 not found");
+    }
+
+    FREE (swipe);
+    dispose_words (p1);
+    dispose_words (p2);
+    dispose_words (track1);
+    dispose_words (track2);
+    return (retval);
+}
+
+
+static int
+writetrack (var1, var2, check_flag)
+    SHELL_VAR *var1, *var2;
+    int check_flag;
+{
+    char *t, *tt;
+    int retval;
+    WORD_LIST *track1, *track2;
+
+    track1 = track2 = (WORD_LIST *)NULL;
+
+    retval = EXECUTION_SUCCESS;
+
+    if (var1) {
+	track1 = array_to_word_list (array_cell (var1));
+	t = string_list_internal (track1, "^");
+	if (t)
+	    printf ("%%B%s?", t);
+	else if (! check_flag)
+	    printf ("%%B%s?", "");	/* print empty track1 */
+
+	FREE (t);
+    }
+
+    if (var2) {
+	track2 = array_to_word_list (array_cell (var2));
+	t = string_list_internal (track2, "=");
+	if (t)
+	    printf (";%s?", t);
+	else if (! check_flag)
+	    printf (";%s?", "");	/* print empty track2 */
+	FREE (t);
+    }
+
+    dispose_words (track1);
+    dispose_words (track2);
+    fflush (stdout);
+    return (retval);
+}
+
+
+int
+cardswipe_builtin (list)
+    WORD_LIST *list;
+{
+    SHELL_VAR *var1, *var2;
+    char *name1, *name2;
+    int opt, retval, check_flag, rw_flag;
+    WORD_LIST *p;
+
+    var1 = var2 = (SHELL_VAR *)NULL;
+    name1 = name2 = (char *)NULL;
+    check_flag = rw_flag = 0;
+
+    reset_internal_getopt ();
+    while ((opt = internal_getopt (list, "1:2:crw")) != -1) {
+	switch (opt) {
+	case '1':
+	    name1 = list_optarg;
+	    break;
+	case '2':
+	    name2 = list_optarg;
+	    break;
+	case 'c':	/* check for format errors */
+	    check_flag = 1;
+	    break;
+	case 'r':
+	case 'w':
+	    rw_flag = opt;	/* -[rw] is mandatory */
+	    break;
+	default:
+	    builtin_usage ();
+	    return (EX_BADUSAGE);
+	}
+    }
+    list = loptend;		/* skip over possible `--' */
+
+    if (name1 == 0 && name2 == 0 || list) {	/* must specify track */
+	builtin_usage ();
+	return (EX_BADUSAGE);
+    }
+
+    switch (rw_flag) {
+    case 'r':
+	if (name1) {
+	    var1 = force_name_to_arrayvar (name1, 1);
+	    if (var1 == 0)
+		return (EXECUTION_FAILURE);
+	}
+	if (name2) {
+	    var2 = force_name_to_arrayvar (name2, 1);
+	    if (var2 == 0)
+		return (EXECUTION_FAILURE);
+	}
+	return (readtrack (var1, var2, check_flag));
+    case 'w':
+	if (name1) {
+	    var1 = name_to_arrayvar (name1, 0);
+	    if (var1 == 0)
+		return (EXECUTION_FAILURE);
+	}
+	if (name2) {
+	    var2 = name_to_arrayvar (name2, 0);
+	    if (var2 == 0)
+		return (EXECUTION_FAILURE);
+	}
+	return (writetrack (var1, var2, check_flag));
+    default:
+	builtin_usage ();
+	return (EX_BADUSAGE);
+    }
+}
+
+char *cardswipe_doc[] = {
+    "Read (-r) magnetic card swipe from stdin, and extract track1 and track2",
+    "data.  Eg.",
+    "    track 1:        %B...^...?",
+    "    track 2:         ;...=...?",
+    "Track segments are returned in shell array variable, specified by -[12]",
+    "options for track1 or track2, respectively.  Track1 is always consumed",
+    "first.  Track2 can occur after or before track1, and is searched in that",
+    "order.  With -c option, returns error if track is empty or not found.",
+    "",
+    "Inverse of \"read\".  Build card swipe string from track segments, and write",
+    "(-w) to stdout.  Similiar to",
+    "    echo -n \"%B${track1[*]|,^}?;${track2[*]|,=}?\"",
+    "With -c option, track will be printed only if it's non-empty.",
+    (char *)NULL
+};
+struct builtin cardswipe_struct = {
+    "cardswipe", cardswipe_builtin, BUILTIN_ENABLED, cardswipe_doc,
+    "cardswipe -[12] array [-c] {-r < file | -w > file}",
+    (char *)NULL
+};
+
+#endif	/* ARRAY_VARS */
--- bash-3.2_orig/examples/loadables/william/creditcard.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/creditcard.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,123 @@
+/*******************************************************************************
+ * Credit card validation.  It's only for catching typing error.
+ */
+
+#include "loadables.h"
+
+
+/* Return check digit [0,9].
+ *
+ * Each digit is multiplied by alternating factor of 1 and 2, starting with 1
+ * from the end.  Eg.
+ *	even length number: 2 1 2 1 ... 2 1
+ *	old length number:  1 2 1 2 ... 2 1
+ * Then, all digits are summed, including doubled digit that is now greater than
+ * 10, eg.
+ *	4 x 2 = 8   --> 8
+ *	6 x 2 = 12  --> 1 + 2 = 3
+ */
+int
+check_sum_digit (cc_number, weight)
+    char *cc_number;	/* cannot be NULL */
+    char *weight;	/* can be NULL */
+{
+    int size, i, sum, n;
+
+    sum = 0;
+    size = strlen (cc_number);
+
+    for (i = 0; i < size; i++) {
+	n = TODIGIT(cc_number[i]);
+	if (weight) {
+	    n *= TODIGIT(weight[i]);
+	} else {
+	    if (i % 2 == size % 2)
+		n *= 2;
+	}
+	sum += n/10 + n%10;
+    }
+
+    return ((10 - sum % 10) % 10);	/* [0,9] */
+}
+
+
+int
+creditcard_builtin (list)
+    WORD_LIST *list;
+{
+    char *cc_number, *weight;
+    int opt, checkdigit_flag, n;
+
+    checkdigit_flag = 0;
+
+    reset_internal_getopt ();
+    while ((opt = internal_getopt (list, "c")) != -1) {
+	switch (opt) {
+	case 'c': 
+	    checkdigit_flag = 1;
+	    break;
+	default:
+	    builtin_usage ();
+	    return (EX_BADUSAGE);
+	}
+    }
+    list = loptend;		/* skip over possible `--' */
+
+    switch (list_length (list)) {
+    case 1:
+        cc_number = list->word->word;	list = list->next;
+        weight = (char *)NULL;
+
+	if (! pure_digits (cc_number)) {
+	    builtin_error ("`%s': invalid credit card number", cc_number);
+	    return (EX_BADUSAGE);
+	}
+        break;
+
+    case 2:
+        cc_number = list->word->word;	list = list->next;
+        weight = list->word->word;	list = list->next;
+
+	if (! pure_digits (cc_number)) {
+	    builtin_error ("`%s': invalid credit card number", cc_number);
+	    return (EX_BADUSAGE);
+	}
+	if (! pure_digits (weight)) {
+	    builtin_error ("`%s': invalid credit card weight", weight);
+	    return (EX_BADUSAGE);
+	}
+	if (strlen (weight) != strlen (cc_number)) {
+	    builtin_error ("credit card number and weight do not match");
+	    return (EX_BADUSAGE);
+	}
+        break;
+
+    default:
+        builtin_usage ();
+        return (EX_BADUSAGE);
+    }
+
+    n = check_sum_digit (cc_number, weight);
+    if (checkdigit_flag) {
+	printf ("%d\n", n);
+	return (n >= 0)? EXECUTION_SUCCESS: EXECUTION_FAILURE;
+    } else {
+	return (n == 0)? EXECUTION_SUCCESS: EXECUTION_FAILURE;
+    }
+}
+
+
+char *creditcard_doc[] = {
+    "Check credit card number for possible typing error, using Modulus 10",
+    "method.  If WEIGHT is not given, the usual Luhn Algorithm is used with",
+    "weight 2121...21 (even) or 1212...21 (odd).  Returns success (0) or failure",
+    "(1).  With -c option, check digit is printed on stdout.",
+    "    creditcard 4524000000015205",
+    "    creditcard -c 10065004263 37137137137       --> 6",
+    (char *)NULL
+};
+struct builtin creditcard_struct = {
+    "creditcard", creditcard_builtin, BUILTIN_ENABLED, creditcard_doc,
+    "creditcard [-c] number [weight]",
+    (char *)NULL
+};
--- bash-3.2_orig/examples/loadables/william/crypt.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/crypt.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,48 @@
+/*******************************************************************************
+ * crypt(3) wrapper.  Requires -lcrypt for linking.
+ */
+
+#define _XOPEN_SOURCE		/* crypt(3) */
+/* #include <unistd.h> */
+
+#include "loadables.h"
+
+
+int
+crypt_builtin (list)
+    WORD_LIST *list;
+{
+    char *key, *salt, *out;
+
+    if (no_options (list))
+	return (EX_BADUSAGE);
+    list = loptend;		/* skip over possible `--' */
+
+    if (list_length (list) != 2) {	/* must be 2 arguments */
+	builtin_usage ();
+	return (EX_BADUSAGE);
+    }
+
+    key = list->word->word;  list = list->next;
+    salt = list->word->word;  list = list->next;
+
+    out = crypt (key, salt);
+    if (out) {
+	puts (out);
+	return (EXECUTION_SUCCESS);
+    } else {
+	return (EXECUTION_FAILURE);
+    }
+}
+
+
+char *crypt_doc[] = {
+    "Shell wrapper for crypt(3), which is used for password encryption.",
+    "Encrypted output is printed to stdout.",
+    (char *)NULL
+};
+struct builtin crypt_struct = {
+    "crypt", crypt_builtin, BUILTIN_ENABLED, crypt_doc,
+    "crypt key salt",
+    (char *)NULL
+};
--- bash-3.2_orig/examples/loadables/william/expat.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/expat.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,372 @@
+/*******************************************************************************
+ * Interface to Expat-1.95.8.
+ */
+
+#include "loadables.h"
+
+
+#if defined (HAVE_EXPAT)
+
+#include <expat.h>
+
+/* For pre-1.95.7 version which doesn't have XMLCALL.  Copied from Expat
+ * documentation.
+ */
+#ifndef XMLCALL
+#if defined(_MSC_EXTENSIONS) && !defined(__BEOS__) && !defined(__CYGWIN__)
+#define XMLCALL __cdecl
+#elif defined(__GNUC__)
+#define XMLCALL __attribute__((cdecl))
+#else
+#define XMLCALL
+#endif
+#endif
+
+
+/* Names of shell command to be called from callback functions.
+ */
+static struct {
+    char *start;	/* start element */
+    char *end;		/* end element */
+    char *data;		/* end element */
+    char *instruction;	/* processing instruction */
+    char *comment;	/* comment */
+    char *ns_start;	/* namespace start */
+    char *ns_end;	/* namespace end */
+} callbacknames;
+
+
+static void XMLCALL
+start_handler (userData, tag, att)	/* command tag att[0]=att[1] ... */
+    void *userData;	/* not used */
+    XML_Char *tag, **att;
+{
+    char *t, *command;
+    SHELL_VAR *var;
+    WORD_LIST *list, *p;
+    int n;
+
+    list = make_word_list (make_bare_word (tag), (WORD_LIST *)NULL);
+    for ( ; att[0] && att[1]; att += 2) {
+	t = (char *)xmalloc (strlen (att[0]) + strlen (att[1]) + 2);
+	sprintf (t, "%s=%s", att[0], att[1]);
+	list = make_word_list (make_bare_word (t), list);
+	FREE (t);
+    }
+    list = REVERSE_LIST (list, WORD_LIST *);
+
+#if defined (ARRAY_VARS)
+    var = name_to_arrayvar ("XML_ELEMENT_STACK", 1 /* check_readonly */);
+    if (var) {
+	arrayvar_push_list (var, list);
+	t = itos (list_length (list));
+	arrayvar_push (var, t);
+	FREE (t);
+    }
+
+    var = name_to_arrayvar ("XML_TAG_STACK", 1 /* check_readonly */);
+    if (var)
+	arrayvar_push (var, tag);
+
+    t = get_string_value ("XML_ELEMENT_DEPTH");	/* not a copy */
+    if (legal_positive_integer (t, &n))
+	bind_var_to_int ("XML_ELEMENT_DEPTH", n + 1);
+#endif
+
+    command = callbacknames.start;
+    if (command) {
+	t = savestring (command);
+	for (p = list; p; p = p->next)
+	    t = build_eval_string (t, p->word->word);
+	    /* 't' is freed */
+	parse_and_execute (t, "XML start handler", SEVAL_NOHIST | SEVAL_NONINT);
+    }
+    dispose_words (list);
+}
+
+
+static void XMLCALL
+end_handler (userData, tag)
+    void *userData;	/* not used */
+    XML_Char *tag;
+{
+    char *t, *command;
+    SHELL_VAR *var;
+    int n;
+
+    command = callbacknames.end;
+    if (command) {
+	t = savestring (command);
+	t = build_eval_string (t, tag);
+	    /* 't' is freed */
+	parse_and_execute (t, "XML end handler", SEVAL_NOHIST | SEVAL_NONINT);
+    }
+
+#if defined (ARRAY_VARS)
+    var = name_to_arrayvar ("XML_ELEMENT_STACK", 1 /* check_readonly */);
+    if (var) {
+	t = array_reference (array_cell (var), 0);	/* not a copy */
+	if (legal_positive_integer (t, &n))
+	    arrayvar_pop (var, n + 1);
+    }
+
+    var = name_to_arrayvar ("XML_TAG_STACK", 1 /* check_readonly */);
+    if (var)
+	arrayvar_pop (var, 1);
+
+    t = get_string_value ("XML_ELEMENT_DEPTH");	/* not a copy */
+    if (legal_positive_integer (t, &n))
+	bind_var_to_int ("XML_ELEMENT_DEPTH", n - 1);
+#endif
+}
+
+
+static void XMLCALL
+data_handler (userData, data, len)
+    void *userData;	/* not used */
+    XML_Char *data;	/* 'data' is not 0-terminated */
+    int len;
+{
+    char *t, *d, *command;
+
+    command = callbacknames.data;
+    if (command) {
+	t = savestring (command);
+	t = build_eval_substring (t, data, 0, len);
+	    /* 't' is freed */
+	parse_and_execute (t, "XML data handler", SEVAL_NOHIST | SEVAL_NONINT);
+    }
+}
+
+
+static void XMLCALL
+instruction_handler (userData, target, data)
+    void *userData;	/* not used */
+    XML_Char *target, *data;
+{
+    char *t, *command;
+
+    command = callbacknames.instruction;
+    if (command) {
+	t = savestring (command);
+	t = build_eval_string (t, target);
+	t = build_eval_string (t, data);
+	    /* 't' is freed */
+	parse_and_execute (t, "XML instruction handler", SEVAL_NOHIST | SEVAL_NONINT);
+    }
+}
+
+
+static void XMLCALL
+comment_handler (userData, text)
+    void *userData;	/* not used */
+    XML_Char *text;
+{
+    char *t, *command;
+
+    command = callbacknames.comment;
+    if (command) {
+	t = savestring (command);
+	t = build_eval_string (t, text);
+	    /* 't' is freed */
+	parse_and_execute (t, "XML comment handler", SEVAL_NOHIST | SEVAL_NONINT);
+    }
+}
+
+
+static void XMLCALL
+ns_start_handler (userData, prefix, uri)
+    void *userData;	/* not used */
+    XML_Char *prefix, *uri;
+{
+    char *t, *command;
+
+    command = callbacknames.ns_start;
+    if (command) {
+	t = savestring (command);
+	t = build_eval_string (t, prefix);
+	t = build_eval_string (t, uri);
+	    /* 't' is freed */
+	parse_and_execute (t, "XML namespace start handler", SEVAL_NOHIST | SEVAL_NONINT);
+    }
+}
+
+
+static void XMLCALL
+ns_end_handler (userData, prefix)
+    void *userData;	/* not used */
+    XML_Char *prefix;
+{
+    char *t, *command;
+
+    command = callbacknames.ns_end;
+    if (command) {
+	t = savestring (command);
+	t = build_eval_string (t, prefix);
+	    /* 't' is freed */
+	parse_and_execute (t, "XML namespace end handler", SEVAL_NOHIST | SEVAL_NONINT);
+    }
+}
+
+
+int
+expat_builtin (list)
+     WORD_LIST *list;
+{
+    int out, opt;
+    char *s;
+    XML_Parser p;
+    SHELL_VAR *var;
+
+    /* Always register start/end of element, so that XML_ELEMENT_DEPTH,
+     * XML_ELEMENT_STACK, and XML_TAG_STACK can be updated.
+     */
+    p = XML_ParserCreate (NULL);
+    XML_SetStartElementHandler (p, start_handler);
+    XML_SetEndElementHandler (p, end_handler);
+
+    memset(&callbacknames, 0, sizeof(callbacknames));	/* zero it */
+
+    reset_internal_getopt ();
+    while ((opt = internal_getopt (list, "s:e:d:i:c:n:m:")) != -1) {
+	switch (opt) {
+	case 's':
+	    callbacknames.start = list_optarg;
+	    break;
+	case 'e':
+	    callbacknames.end = list_optarg;
+	    break;
+	case 'd':
+	    callbacknames.data = list_optarg;
+	    XML_SetCharacterDataHandler (p, data_handler);
+	    break;
+	case 'i':
+	    callbacknames.instruction = list_optarg;
+	    XML_SetProcessingInstructionHandler (p, instruction_handler);
+	    break;
+	case 'c':
+	    callbacknames.comment = list_optarg;
+	    XML_SetCommentHandler (p, comment_handler);
+	    break;
+	case 'n':
+	    callbacknames.ns_start = list_optarg;
+	    XML_SetStartNamespaceDeclHandler (p, ns_start_handler);
+	    break;
+	case 'm':
+	    callbacknames.ns_end = list_optarg;
+	    XML_SetEndNamespaceDeclHandler (p, ns_end_handler);
+	    break;
+	default:
+	    builtin_usage ();
+	    XML_ParserFree (p);
+	    return (EX_BADUSAGE);
+	}
+#if 0		/* may be too strict */
+	if (! legal_identifier (list_optarg)) {
+	    sh_invalidid (list_optarg);
+	    return (EX_BADUSAGE);
+	}
+#endif
+    }
+    list = loptend;		/* skip over possible `--' */
+
+#if defined (ARRAY_VARS)
+    unbind_variable ("XML_ELEMENT_STACK");
+    make_new_array_variable ("XML_ELEMENT_STACK");
+
+    unbind_variable ("XML_TAG_STACK");
+    make_new_array_variable ("XML_TAG_STACK");
+
+    var = bind_var_to_int ("XML_ELEMENT_DEPTH", 0);
+    VSETATTR (var, att_integer);        /* not really necessary */
+#endif
+
+    out = EXECUTION_SUCCESS;
+
+    if (list == 0) {	        /* read from stdin (fd=0) */
+	s = slurp_fd_into_string (0);
+	if (s == 0)
+	    out = EXECUTION_FAILURE;
+	else if (XML_Parse (p, s, strlen (s), 0 /* isFinal */) == XML_STATUS_ERROR) {
+	    builtin_error ("Parse error at line %d: %s",
+		    XML_GetCurrentLineNumber (p),
+		    XML_ErrorString (XML_GetErrorCode (p)));
+	    out = EXECUTION_FAILURE;
+	}
+	FREE (s);
+    } else {
+	for ( ; list && out == EXECUTION_SUCCESS; list = list->next) {
+	    s = slurp_filename_into_string (list->word->word);
+	    if (s == 0)
+		out = EXECUTION_FAILURE;
+	    else if (XML_Parse (p, s, strlen (s), 0 /* isFinal */) == XML_STATUS_ERROR) {
+		builtin_error ("Parse error at line %d: %s",
+			XML_GetCurrentLineNumber (p),
+			XML_ErrorString (XML_GetErrorCode (p)));
+		out = EXECUTION_FAILURE;
+	    }
+	    FREE (s);
+	}
+    }
+    if (out == EXECUTION_SUCCESS)	/* tell Expat to finish parsing */
+	XML_Parse (p, "", 0, 1 /* isFinal */);
+    
+    XML_ParserFree (p);
+    return (out);
+}
+
+
+char *expat_doc[] = {
+    "Interface to Expat-1.95.8 (www.libexpat.org) library.  Arguments are feed",
+    "to Expat XML parser sequentially.  It returns 1 immediately on any error.",
+    "If all arguments are processed without error, then returns success (0).",
+    "The entire arguments as whole must be a single complete XML document,",
+    "because Expat can handle only one XML document per parser process.",
+    "",
+    "Parser will invoke callback commands or handlers that you specified, with",
+    "all required parameters on command-line.  For the moment, the following",
+    "options are recognized:",
+    "    -s      start element       --> command tag att=value ...",
+    "    -e      end element         --> command tag",
+    "    -d      character data      --> command data",
+    "    -i      processing instruction      --> command target data",
+    "    -c      comment             --> command text",
+    "    -n      namespace start     --> command prefix uri",
+    "    -m      namespace end       --> command prefix",
+    "",
+    "For -s option, the attribute name and value strings are concatenated with",
+    "'=', so that 'declare' can be used to set shell variable with the same name",
+    "as attribute, ie.",
+    "    declare \"$2\"        --> set the first attribute name",
+    "    declare \"${@:2}\"    --> set all attribute names",
+    "",
+    "For convenience, the name and attributes of start XML elements are saved in",
+    "array variable XML_ELEMENT_STACK as stack,",
+    "    XML_ELEMENT_STACK[0]    --> number of positional parameters (ie. $#)",
+    "    XML_ELEMENT_STACK[1]    --> tag",
+    "    XML_ELEMENT_STACK[2]    --> first attribute 'key=value'",
+    "    ...",
+    "Also, array variable XML_TAG_STACK contains just the tag names, and shell",
+    "variable XML_ELEMENT_DEPTH contains the depth of current element.  They",
+    "will be removed and decreased, respectively, at the end of XML element.",
+    "Essentially, it's equivalent to doing manually",
+    "    pp_push -a XML_ELEMENT_STACK  $# \"$@\"",
+    "    pp_push -a XML_TAG_STACK \"$1\"",
+    "    ((XML_ELEMENT_DEPTH++))",
+    "at the start of element, and ",
+    "    pp_pop -a XML_ELEMENT_STACK  $((XML_ELEMENT_STACK[0] + 1))",
+    "    pp_pop -a XML_TAG_STACK",
+    "    ((XML_ELEMENT_DEPTH--))",
+    "at the end of element.",
+    "",
+    "The callbacks will run at the top-level, so if you need to protect your",
+    "shell environment, run 'expat' command in subshell.",
+    (char *)NULL
+};
+struct builtin expat_struct = {
+    "expat", expat_builtin, BUILTIN_ENABLED, expat_doc,
+    "expat [-sedicnm command] [file... | < file]",
+    (char *)NULL
+};
+
+#endif	/* HAVE_EXPAT */
--- bash-3.2_orig/examples/loadables/william/fixedstring.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/fixedstring.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,196 @@
+/*******************************************************************************
+ * Cut string according to fixed-width.
+ */
+
+#include "loadables.h"
+
+
+#if defined (ARRAY_VARS)
+
+/* LIST contains 2 arrays, field LENGTH and field DATA.  Cut fixed-width strings
+ * according LENGTH array from stdin, and store them in DATA array.  
+ */
+static int
+read_fixedstring (list)
+    WORD_LIST *list;
+{
+    int n;
+    char *arg, *buf;
+    SHELL_VAR *v1, *v2;
+    ARRAY *a1, *a2;
+    ARRAY_ELEMENT *ae1, *ae2;
+
+    v1 = name_to_arrayvar (list->word->word, 0);
+    v2 = force_name_to_arrayvar ((list->next)->word->word, 1);
+    if (v1 == 0 || v2 == 0)
+	return (EXECUTION_FAILURE);
+
+    a1 = array_cell (v1);
+    a2 = array_cell (v2);
+    for (ae1 = element_forw (a1->head); ae1 != a1->head; ae1 = element_forw (ae1)) {
+	arg = element_value (ae1);
+	if (! legal_integer (arg, &n)) {
+	    builtin_error ("`%s': invalid field width", arg);
+	    return (EXECUTION_FAILURE);
+	}
+	buf = (char *)xmalloc (n + 1);
+	if (zread (0, buf, n) != n) {
+	    builtin_error ("reached end of file");
+	    FREE (buf);
+	    return (EXECUTION_FAILURE);
+	}
+	buf[n] = '\0';
+	arrayvar_insert (v2, element_index (ae1), buf);
+	FREE (buf);
+    }
+    return (EXECUTION_SUCCESS);
+}
+
+
+static void
+print_fixedwidth (align_flag, n, str)
+    int align_flag, n;
+    char *str;
+{
+    int size, i;
+
+    switch (align_flag) {
+    default:
+    case 'L':
+	if (n >= 0) {
+	    printf ("%-*.*s", n, n, str);
+	} else {
+	    n = -n;
+	    printf ("%*.*s", n, n, str);
+	}
+	break;
+    case 'R':
+	if (n >= 0) {
+	    printf ("%*.*s", n, n, str);
+	} else {
+	    n = -n;
+	    printf ("%-*.*s", n, n, str);
+	}
+	break;
+    case 'C':
+	if (n < 0)
+	    n = -n;
+	size = strlen (str);
+	if (n > size) {
+	    printf ("%*s", (n - size) / 2 , "");
+	    printf ("%s", str);
+	    printf ("%*s", (n - size) - (n - size) / 2 , "");
+	} else {
+	    printf ("%*.*s", n, n, str);
+	}
+	break;
+    }
+}
+
+
+/* LIST contains 2 arrays, field LENGTH and field DATA.  Print fixed-width
+ * strings to stdout.  The output can be left or right aligned, depending on
+ * whether ALIGN_FLAG is 'l' or 'r', respectively.  
+ */
+static int
+write_fixedstring (list, align_flag, print0)
+     WORD_LIST *list;
+     int align_flag;
+     int print0;
+{
+    int n;
+    char *arg;
+    SHELL_VAR *v1, *v2;
+    ARRAY *a1, *a2;
+    ARRAY_ELEMENT *ae1, *ae2;
+
+    v1 = name_to_arrayvar (list->word->word, 0);
+    v2 = name_to_arrayvar ((list->next)->word->word, 0);
+    if (v1 == 0 || v2 == 0)
+	return (EXECUTION_FAILURE);
+
+    a1 = array_cell (v1);
+    a2 = array_cell (v2);
+    for (ae1 = element_forw (a1->head), ae2 = element_forw (a2->head);
+	 ae1 != a1->head && ae2 != a2->head;
+	 ae1 = element_forw (ae1), ae2 = element_forw (ae2))
+    {
+	arg = element_value (ae1);
+	if (! legal_integer (arg, &n)) {
+	    builtin_error ("`%s': invalid field width", arg);
+	    fflush (stdout);
+	    return (EXECUTION_FAILURE);
+	}
+	arg = element_value (ae2);
+	print_fixedwidth (align_flag, n, arg);
+	if (print0)
+	    putchar ('\0');
+    }
+
+    fflush (stdout);
+    return (EXECUTION_SUCCESS);
+}
+
+
+int
+fixedstring_builtin (list)
+    WORD_LIST *list;
+{
+    int opt, rw_flag, align_flag, print0;
+
+    rw_flag = 0;
+    align_flag = 'L';
+    print0 = 0;
+
+    reset_internal_getopt ();
+    while ((opt = internal_getopt (list, "rw:0")) != -1) {
+	switch (opt) {
+	case 'r':
+	    rw_flag = opt;	/* -[rw] is mandatory */
+	    break;
+	case 'w':
+	    rw_flag = opt;	/* -[rw] is mandatory */
+	    align_flag = list_optarg[0];	/* -w[LCR], L=left, C=centre, R=right */
+	    break;
+	case '0':
+	    print0 = 1;
+	    break;
+	default:
+	    builtin_usage ();
+	    return (EX_BADUSAGE);
+	}
+    }
+    list = loptend;		/* skip over possible `--' */
+
+    if (list_length (list) != 2) {
+	builtin_usage ();
+	return (EX_BADUSAGE);
+    }
+
+    switch (rw_flag) {
+    case 'r':
+	return (read_fixedstring (list));
+    case 'w':
+	return (write_fixedstring (list, align_flag, print0));
+    default:
+	builtin_usage ();
+	return (EX_BADUSAGE);
+    }
+}
+
+
+char *fixedstring_doc[] = {
+    "Given a list of length in LENGTH array variable, read (-r) fixed-width",
+    "strings from stdin into DATA array variable.  Conversely, write (-w) DATA",
+    "to stdout, aligned to left (L), right (R), or centered (C) within the",
+    "specified length.  Default output is to simply concatenate, but option -0",
+    "will terminate each output string with \\0.",
+    (char *)NULL
+};
+struct builtin fixedstring_struct = {
+    "fixedstring", fixedstring_builtin, BUILTIN_ENABLED, fixedstring_doc,
+    "fixedstring {-r length data < file | -w[LCR] [-0] length data > file}",
+    (char *)NULL
+};
+
+#endif	/* ARRAY_VARS */
--- bash-3.2_orig/examples/loadables/william/gdbm.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/gdbm.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,360 @@
+/*******************************************************************************
+ * Interface to gdbm(3).  It simulates disk-based associative array.  Unlike
+ * in-memory implementation (which Bash doesn't have), a disk-based database
+ * will survive exit and shutdown.  It can be shared by multiple processes.
+ * Each call is independent, because each call will open and close the database.
+ */
+
+#include "loadables.h"
+
+
+#if defined (HAVE_GDBM)
+
+#include <gdbm.h>
+
+
+/* Return \0-terminated string from DATUM struct.  Caller should free the
+ * allocated memory.
+ */
+#define string_in_datum(d)	substring ((d).dptr, 0, (d).dsize)
+
+
+static datum cast_to_datum	__P((char *));
+static int cannot_open_gdbm	__P((char *));
+
+
+/* Return 'datum' structure, converted from ordinary string in-place.  From
+ * gdbm.h,
+ *	typedef struct {
+ *	    char *dptr;
+ *	    int dsize;
+ *	} datum;
+ */
+static datum
+cast_to_datum (s)
+    char *s;
+{
+    datum out;
+
+    out.dptr = s;
+    out.dsize = strlen (s);	/* exclude \0 */
+    return (out);
+}
+
+
+static int 
+cannot_open_gdbm (file)
+    char *file;
+{
+    builtin_error ("cannot open file `%s': %s", file, gdbm_strerror (gdbm_errno));
+    return (EXECUTION_FAILURE);
+}
+
+
+int
+gdbm_builtin (list)
+    WORD_LIST *list;
+{
+    GDBM_FILE dbf;
+    datum k, kk, v;
+    char *file, *key, *value, *name, *t;
+    SHELL_VAR *var;
+    int flag, opt, out;
+
+    flag = 0;
+    var = (SHELL_VAR *)NULL;
+
+    reset_internal_getopt ();
+    while ((opt = internal_getopt (list, "euikvK:V:W:r")) != -1) {
+	switch (opt) {
+	case 'e':
+	case 'u':
+	case 'i':
+	case 'k':
+	case 'v':
+	case 'r':
+	    flag = opt;
+	    break;
+#if defined (ARRAY_VARS)
+	case 'K':
+	case 'V':
+	case 'W':
+	    flag = opt;
+	    var = force_name_to_arrayvar (list_optarg, 1);
+	    if (var == 0)
+		return (EXECUTION_FAILURE);
+	    break;
+#endif
+	default:
+	    builtin_usage ();
+	    return (EX_BADUSAGE);
+	}
+    }
+    list = loptend;		/* skip over possible `--' */
+
+    if (list == 0) {		/* 0 argument */
+	builtin_usage ();
+	return (EX_BADUSAGE);
+    }
+
+    file = list->word->word; list = list->next;
+
+    if (list == 0) {		/* 1 argument */
+	/* Reorganize the database.  It's handled separately, because it opens
+	 * database as "writer", whereas other options open as "reader".
+	 */
+	if (flag == 'r') {
+	    dbf = gdbm_open (file, 0, GDBM_WRITER, 0644, NULL);
+	    if (dbf == 0)
+		return (cannot_open_gdbm (file));
+
+	    out = EXECUTION_SUCCESS;
+	    if (gdbm_reorganize (dbf)) {
+		builtin_error ("cannot reorganize `%s': %s", file, gdbm_strerror (gdbm_errno));
+		out = EXECUTION_FAILURE;
+	    }
+	    gdbm_close (dbf);
+	    return (out);
+	}
+
+	dbf = gdbm_open (file, 0, GDBM_READER, 0644, NULL);
+	if (dbf == 0)
+	    return (cannot_open_gdbm (file));
+
+	switch (flag) {
+	case 'e':		/* check if it's GDBM file */
+	    break;
+
+	case 'k':		/* print all keys */
+	case 'K':		/* save all keys into array */
+	    k = gdbm_firstkey (dbf);
+	    while (k.dptr) {
+		kk = gdbm_nextkey (dbf, k);
+		if (var == 0) {
+		    t = string_in_datum (k);
+		    puts (t);
+		    FREE (t);
+		}
+#if defined (ARRAY_VARS)
+		else {
+		    t = string_in_datum (k);
+		    arrayvar_append (var, t);
+		    FREE (t);
+		}
+#endif
+		FREE (k.dptr);
+		k = kk;
+	    }
+	    break;
+
+	case 'v':		/* print all values */
+	case 'V':		/* save all values into array */
+	    k = gdbm_firstkey (dbf);
+	    while (k.dptr) {
+		kk = gdbm_nextkey (dbf, k);
+		v = gdbm_fetch (dbf, k);
+		if (v.dptr) {
+		    if (var == 0) {
+			t = string_in_datum (v);
+			puts (t);
+			FREE (t);
+		    }
+#if defined (ARRAY_VARS)
+		    else {
+			t = string_in_datum (v);
+			arrayvar_append (var, t);
+			FREE (t);
+		    }
+#endif
+		}
+		FREE (k.dptr);
+		FREE (v.dptr);
+		k = kk;
+	    }
+	    break;
+
+	default:		/* print all key/value pairs */
+	case 'W':		/* save all key/value pairs into array sequentially */
+	    k = gdbm_firstkey (dbf);
+	    while (k.dptr) {
+		kk = gdbm_nextkey (dbf, k);
+		v = gdbm_fetch (dbf, k);
+		if (v.dptr) {
+		    if (var == 0) {
+			t = string_in_datum (k);
+			printf ("%s\t", t);
+			FREE (t);
+			t = string_in_datum (v);
+			printf ("%s\n", t);
+			FREE (t);
+		    } 
+#if defined (ARRAY_VARS)
+		    else {
+			t = string_in_datum (k);
+			arrayvar_append (var, t);
+			FREE (t);
+			t = string_in_datum (v);
+			arrayvar_append (var, t);
+			FREE (t);
+		    }
+#endif
+		}
+		FREE (k.dptr);
+		FREE (v.dptr);
+		k = kk;
+	    }
+	    break;
+	}
+	gdbm_close (dbf);
+	return (EXECUTION_SUCCESS);
+    }
+
+    key = list->word->word; list = list->next;
+
+    if (list == 0) {		/* 2 arguments */
+	switch (flag) {
+	    default:		/* print var[key] */
+	    case 'e':		/* check for key */
+		dbf = gdbm_open (file, 0, GDBM_READER, 0644, NULL);
+		break;
+	    case 'u':		/* delete key */
+		dbf = gdbm_open (file, 0, GDBM_WRITER, 0644, NULL);
+		break;
+	}
+	if (dbf == 0)
+	    return (cannot_open_gdbm (file));
+
+	out = EXECUTION_SUCCESS;
+	switch (flag) {
+	    default:		/* print var[key] */
+		v = gdbm_fetch (dbf, cast_to_datum (key));
+		if (v.dptr) {
+		    t = string_in_datum (v);
+		    puts (t);
+		    FREE (t);
+		}
+		FREE (v.dptr);
+		break;
+	    case 'e':		/* check for key */
+		if (! gdbm_exists (dbf, cast_to_datum (key)))
+		    out = EXECUTION_FAILURE;
+		break;
+	    case 'u':		/* delete key */
+		gdbm_delete (dbf, cast_to_datum (key));
+		break;
+	}
+	gdbm_close (dbf);
+	return (out);
+    }
+
+    /* 3 or more arguments: gdbm [-option] file key value ... */
+
+    value = list->word->word;
+
+    switch (flag) {
+	default:		/* store key/value to database */
+	case 'i':		/* store key/value, only if key is new */
+	    dbf = gdbm_open (file, 0, GDBM_WRCREAT, 0644, NULL);
+	    break;
+	case 'e':		/* check if key/value match */
+	case 'v':		/* save var[key] in variable 'value' */
+	    dbf = gdbm_open (file, 0, GDBM_READER, 0644, NULL);
+	    break;
+	case 'u':		/* delete if both key/value match */
+	    dbf = gdbm_open (file, 0, GDBM_WRITER, 0644, NULL);
+	    break;
+    }
+    if (dbf == 0)
+	return (cannot_open_gdbm (file));
+
+    out = EXECUTION_SUCCESS;
+    while (list && out == EXECUTION_SUCCESS) {
+	switch (flag) {
+	    default:		/* store key/value to database */
+		gdbm_store (dbf, cast_to_datum (key), cast_to_datum (value), GDBM_REPLACE);
+		break;
+	    case 'i':		/* store key/value, only if key is new */
+		gdbm_store (dbf, cast_to_datum (key), cast_to_datum (value), GDBM_INSERT);
+		break;
+	    case 'e':		/* check if key/value match */
+		v = gdbm_fetch (dbf, cast_to_datum (key));
+		if (v.dptr == 0 || ! STREQN (value, v.dptr, v.dsize))
+		    out = EXECUTION_FAILURE;
+		FREE (v.dptr);
+		break;
+	    case 'u':		/* delete if both key/value match */
+		v = gdbm_fetch (dbf, cast_to_datum (key));
+		if (v.dptr && STREQN (value, v.dptr, v.dsize))
+		    gdbm_delete (dbf, cast_to_datum (key));
+		FREE (v.dptr);
+		break;
+	    case 'v':		/* save var[key] in variable 'value' */
+		name = value;	/* 'value' is name of shell variable */
+		if (legal_identifier (name) == 0) {
+		    sh_invalidid (name);
+		    out = EXECUTION_FAILURE;
+		    break;
+		} 
+		v = gdbm_fetch (dbf, cast_to_datum (key));
+		if (v.dptr) {
+		    t = string_in_datum (v);
+		    bind_variable (name, t);
+		    FREE (t);
+		}
+		FREE (v.dptr);
+		break;
+	}
+
+	if (list = list->next) {
+	    key = list->word->word;
+	    if (list = list->next)
+		value = list->word->word;
+	    else {
+		builtin_error ("dangling `key', missing `value'");
+		out = EXECUTION_FAILURE;
+	    }
+	}
+    }
+    gdbm_close (dbf);
+    return (out);
+}
+
+
+char *gdbm_doc[] = {
+    "Interface to gdbm(3).  It simulates disk-based associative array.",
+    "    gdbm file           -- print all key/\\t/value pairs, ie. dict.items()",
+    "    gdbm -k file        -- print all keys, ie. dict.keys()",
+    "    gdbm -v file        -- print all values, ie. dict.values()",
+    "    gdbm file key       -- print var[key], ie. ${var[key]}",
+    "",
+    "    gdbm -r file        -- reorganize database",
+    "",
+    "    gdbm -K array file      -- save all keys into array",
+    "    gdbm -V array file      -- save all values into array",
+    "    gdbm -W array file      -- save all key/value pairs into array sequentially",
+    "",
+    "    gdbm file key value     -- store key/value, ie. var[key]=value",
+    "    gdbm -i file key value  -- store key/value, only if key is new",
+    "    gdbm -v file key name   -- store value in variable, ie. name=${var[key]}",
+    "",
+    "    gdbm -e file            -- test if file is GDBM database",
+    "    gdbm -e file key        -- test if key exists",
+    "    gdbm -e file key value  -- test if key exists and value is var[key]",
+    "",
+    "    gdbm -u file key        -- delete key, ie. unset var[key]",
+    "    gdbm -u file key value  -- delete key, only if value is var[key]",
+    "",
+    "More than one key/value pair can be specified on command line, in which",
+    "case, they would be processed in pairs.  It returns 1 immediately on any",
+    "error or test failure.  If all arguments are processed without error, then",
+    "returns success (0).  Each 'gdbm' command is complete, in that it opens and",
+    "closes the database file.  ",
+    (char *)NULL
+};
+struct builtin gdbm_struct = {
+    "gdbm", gdbm_builtin, BUILTIN_ENABLED, gdbm_doc,
+    "gdbm [-euikvr] [-KVW array] file [key | key value ...]",
+    (char *)NULL
+};
+
+#endif	/* HAVE_GDBM */
--- bash-3.2_orig/examples/loadables/william/gtk.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/gtk.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,1266 @@
+/*******************************************************************************
+ * Interface to GTK+ 2.6.1 for simple dialog/layout.
+ */
+
+#include "loadables.h"
+
+
+#if defined (HAVE_GTK2) && defined (HAVE_EXPAT)
+
+#define DISABLE_SHELL_CALLBACK	0
+
+
+#include <glib.h>	/* GSList *, g_slist_*() */
+#include <gtk/gtk.h>
+#include <expat.h>
+
+/* For pre-1.95.7 version which doesn't have XMLCALL.  Copied from Expat
+ * documentation.
+ */
+#ifndef XMLCALL
+#if defined(_MSC_EXTENSIONS) && !defined(__BEOS__) && !defined(__CYGWIN__)
+#define XMLCALL __cdecl
+#elif defined(__GNUC__)
+#define XMLCALL __attribute__((cdecl))
+#else
+#define XMLCALL
+#endif
+#endif
+
+
+static void button_callback		__P((GtkWidget *, gpointer));
+static void checkbutton_callback	__P((GtkWidget *, gpointer));
+static void entry_callback		__P((GtkWidget *, gpointer));
+static void combobox_callback		__P((GtkWidget *, gpointer));
+static void comboboxentry_callback	__P((GtkWidget *, gpointer));
+static void dialog_callback		__P((GtkWidget *, gint, gpointer));
+static void scale_callback		__P((GtkWidget *, gpointer));
+static void spinbutton_callback		__P((GtkWidget *, gpointer));
+static void calendar_callback		__P((GtkWidget *, gpointer));
+static void fileselection_callback	__P((GtkWidget *, gpointer));
+static void filechooserdialog_callback	__P((GtkWidget *, gint, gpointer));
+
+static GtkWidget *get_real_parent	__P((void));
+static void pack_widget			__P((GtkWidget *));
+static int set_packing_parameters	__P((GtkWidget *, char *, char *));
+static void setup_toplevel_window	__P((GtkWidget *));
+
+
+/*******************************************************************************
+ * Callback functions for GTK+.
+ */
+
+static void
+button_callback (w, string)
+    GtkWidget *w;
+    gpointer string;
+{
+#if DISABLE_SHELL_CALLBACK
+    printf (" inside button_callback: command={%s}\n", (char *)string);
+#else
+    parse_and_execute ((char *)string, "button callback",
+		       SEVAL_NOHIST | SEVAL_NONINT | SEVAL_NOFREE);
+#endif
+}
+
+
+static void
+checkbutton_callback (w, string)
+    GtkWidget *w;
+    gpointer string;
+{
+#if DISABLE_SHELL_CALLBACK
+    if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (w)) == TRUE)
+	printf (" inside checkbutton_callback: {%s}=on\n", (char *)string);
+    else
+	printf (" inside checkbutton_callback: {%s}=off\n", (char *)string);
+#else
+    if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (w)) == TRUE)
+	bind_variable_if_legal ((char *)string, "on");
+    else
+	bind_variable_if_legal ((char *)string, "off");
+#endif
+}
+
+
+static void
+entry_callback (w, string)
+    GtkWidget *w;
+    gpointer string;
+{
+    const gchar *out;
+
+    out = gtk_entry_get_text (GTK_ENTRY (w));
+#if DISABLE_SHELL_CALLBACK
+    printf (" inside entry_callback: {%s}={%s}\n", (char *)string, (char *)out);
+#else
+    bind_variable_if_legal ((char *)string, (char *)out);
+#endif
+}
+
+
+static void
+combobox_callback (w, string)
+    GtkWidget *w;
+    gpointer string;
+{
+    gchar *out;
+
+    out = gtk_combo_box_get_active_text (GTK_COMBO_BOX (w));
+#if DISABLE_SHELL_CALLBACK
+    printf (" inside combobox_callback: {%s}={%s}\n", (char *)string, (char *)out);
+#else
+    bind_variable_if_legal ((char *)string, (char *)out);
+#endif
+}
+
+
+static void
+comboboxentry_callback (w, string)
+    GtkWidget *w;
+    gpointer string;
+{
+    const gchar *out;
+
+    out = gtk_entry_get_text (GTK_ENTRY (GTK_BIN (w)->child));
+#if DISABLE_SHELL_CALLBACK
+    printf (" inside comboboxentry_callback: {%s}={%s}\n", (char *)string, (char *)out);
+#else
+    bind_variable_if_legal ((char *)string, (char *)out);
+#endif
+}
+
+
+static void
+dialog_callback (w, id, string)
+    GtkWidget *w;
+    gint id;
+    gpointer string;
+{
+#if DISABLE_SHELL_CALLBACK
+    printf (" inside dialog_callback: {%s}={%d}\n", (char *)string, (int)id);
+#else
+    bind_var_to_int ((char *)string, (intmax_t)id);
+#endif
+}
+
+
+static void
+scale_callback (w, string)
+    GtkWidget *w;
+    gpointer string;
+{
+    int digits;
+    double x;
+    char buf[80];
+
+    digits = gtk_scale_get_digits (GTK_SCALE (w));
+    x = gtk_range_get_value (GTK_RANGE (w));
+#if DISABLE_SHELL_CALLBACK
+    printf (" inside scale_callback: {%s}={%.*f}\n", (char *)string, digits, x);
+#else
+    snprintf (buf, 80, "%.*f", digits, x);;
+    buf[79] = '\0';	/* just in case */
+    bind_variable_if_legal ((char *)string, buf);
+#endif
+}
+
+
+static void
+spinbutton_callback (w, string)
+    GtkWidget *w;
+    gpointer string;
+{
+    int digits;
+    double x;
+    char buf[80];
+
+    digits = gtk_spin_button_get_digits (GTK_SPIN_BUTTON (w));
+    x = gtk_spin_button_get_value (GTK_SPIN_BUTTON (w));
+#if DISABLE_SHELL_CALLBACK
+    printf (" inside spinbutton_callback: {%s}={%.*f}\n", (char *)string, digits, x);
+#else
+    snprintf (buf, 80, "%.*f", digits, x);
+    buf[79] = '\0';	/* just in case */
+    bind_variable_if_legal ((char *)string, buf);
+#endif
+}
+
+
+static void
+calendar_callback (w, string)
+    GtkWidget *w;
+    gpointer string;
+{
+    int year, month, day;	/* year>=0, month=[0,11], day=[1,31] */
+    char buf[80];
+    
+    gtk_calendar_get_date (GTK_CALENDAR (w), &year, &month, &day);
+#if DISABLE_SHELL_CALLBACK
+    printf (" inside calendar_callback: {%s}={%d-%02d-%02d}\n", (char *)string, year, month + 1, day);
+#else
+    snprintf (buf, 80, "%d-%02d-%02d", year, month + 1, day);
+    buf[79] = '\0';	/* just in case */
+    bind_variable_if_legal ((char *)string, buf);
+#endif
+}
+
+
+static void
+fileselection_callback (w, string)
+    GtkWidget *w;
+    gpointer string;
+{
+    GtkWidget *top;
+    const gchar *out;
+
+    /* 'w' is button inside FileSelection widget which is toplevel, like Dialog
+     * and Window widgets.  And, 'filename' selected is located there.
+     */
+    top = gtk_widget_get_toplevel (w);
+    out = gtk_file_selection_get_filename (GTK_FILE_SELECTION (top));
+#if DISABLE_SHELL_CALLBACK
+    printf (" inside fileselection_callback: {%s}={%s}\n", (char *)string, (char *)out);
+#else
+    bind_variable_if_legal ((char *)string, (char *)out);
+#endif
+}
+
+
+static void
+filechooserdialog_callback (w, id, string)
+    GtkWidget *w;
+    gint id;		/* same as Dialog */
+    gpointer string;
+{
+    gchar *out;
+
+    out = gtk_file_chooser_get_filename (GTK_FILE_CHOOSER (w));
+    if (id == GTK_RESPONSE_OK)
+#if DISABLE_SHELL_CALLBACK
+	printf (" inside filechooserdialog_callback: {%s}={%s}\n", (char *)string, (char *)out);
+#else
+	bind_variable_if_legal ((char *)string, (char *)out);
+#endif
+    g_free (out);	/* Documentation says I should free it */
+}
+
+
+/*******************************************************************************
+ * Stuffs needed by Expat parser.
+ */
+
+static GSList *widget_list;		/* globally initialized */
+static int xml_element_depth;
+static GSList *radio_group;
+
+static char *data_text;	
+static int tablerow, tablecol;
+
+
+#define unknown_attribute(tag,a,b)	builtin_error ("<%s %s=\"%s\">: unknown attribute", tag, a, b)
+
+#define set_on_or_off(func,widget)	do { \
+    if (STREQ (b, "on")) \
+	func (widget, TRUE); \
+    else if (STREQ (b, "off")) \
+	func (widget, FALSE); \
+    else \
+	unknown_attribute (tag, a, b); \
+} while (0)
+
+
+/* Get parent widget that you're packing into.  Usually it's the current widget
+ * on the stack, but Dialog is special case.
+ */
+static GtkWidget *
+get_real_parent()
+{
+    if (widget_list == 0)
+	return (GtkWidget *)NULL;
+    else if (GTK_IS_DIALOG (widget_list->data))
+	return (GTK_DIALOG (widget_list->data)->vbox);
+    else
+	return (widget_list->data);
+}
+
+
+/* Pack into parent widget.  Table is special case, where items are populated
+ * sequentially, row by row.
+ */
+static void
+pack_widget (w)
+    GtkWidget *w;
+{
+    GtkWidget *parent, *top;
+
+    parent = get_real_parent();
+
+    if (parent == 0) {
+	return;
+    }
+    else if (GTK_IS_TABLE (parent)) {
+	gtk_table_attach_defaults (GTK_TABLE (parent), w,
+				   (guint)tablecol, (guint)(tablecol + 1),
+				   (guint)tablerow, (guint)(tablerow + 1));
+	tablecol++;
+	if (tablecol >= GTK_TABLE (parent)->ncols) {
+	    tablecol = 0;
+	    tablerow++;
+	}
+	if (tablerow >= GTK_TABLE (parent)->nrows)	/* wrap around */
+	    tablerow = 0;
+    }
+    else if (GTK_IS_SCROLLED_WINDOW (parent)) {
+	gtk_scrolled_window_add_with_viewport (GTK_SCROLLED_WINDOW (parent), w);
+    }
+    else
+	gtk_container_add (GTK_CONTAINER (parent), w);
+}
+
+
+/* Set the packing parameters (expand, fill, padding) of parent box widget.
+ * Return (0) if the parent is not box widget or if attribute didn't match.
+ * Return (1) if parameter was set.
+ */
+static int
+set_packing_parameters (w, a, b)
+    GtkWidget *w;
+    char *a, *b;
+{
+    int n, matched;
+
+    GtkWidget *parent;
+    gboolean expand, fill;
+    guint padding;
+    GtkPackType pack_type;
+
+    parent = get_real_parent();
+    if (! GTK_IS_BOX (parent))
+	return (0);
+
+    gtk_box_query_child_packing (GTK_BOX (parent), w, &expand, &fill, &padding, &pack_type);
+
+    matched = 0;
+    if (STREQ (a, "pack")) {
+	if (STREQ (b, "on")) {
+	    expand = TRUE;
+	    fill = TRUE;
+	    padding = 0;
+	    matched = 1;
+	}
+	else if (STREQ (b, "off")) {
+	    expand = FALSE;
+	    fill = FALSE;
+	    padding = 0;
+	    matched = 1;
+	}
+    }
+    else if (STREQ (a, "expand")) {
+	if (STREQ (b, "on")) {
+	    expand = TRUE;
+	    matched = 1;
+	}
+	else if (STREQ (b, "off")) {
+	    expand = FALSE;
+	    matched = 1;
+	}
+    }
+    else if (STREQ (a, "fill")) {
+	if (STREQ (b, "on")) {
+	    fill = TRUE;
+	    matched = 1;
+	}
+	else if (STREQ (b, "off")) {
+	    fill = FALSE;
+	    matched = 1;
+	}
+    }
+    else if (STREQ (a, "padding") && legal_positive_integer (b, &n)) {
+	padding = n;
+	matched = 1;
+    }
+
+    if (matched)
+	gtk_box_set_child_packing (GTK_BOX (parent), w, expand, fill, padding, pack_type);
+
+    return (matched);
+}
+
+
+static void
+setup_toplevel_window (w)
+    GtkWidget *w;
+{
+    GtkWidget *parent, *top;
+
+    parent = get_real_parent();
+
+    g_signal_connect_swapped (G_OBJECT (w), "delete_event",
+			      G_CALLBACK (gtk_widget_destroy), (gpointer)w);
+    if (parent == 0)
+	g_signal_connect (G_OBJECT (w), "destroy", G_CALLBACK (gtk_main_quit), NULL);
+    else {
+	top = gtk_widget_get_toplevel (parent);
+	gtk_window_set_transient_for (GTK_WINDOW (w), GTK_WINDOW (top));
+	gtk_window_set_destroy_with_parent (GTK_WINDOW (w), TRUE);
+    }
+}
+
+
+static void XMLCALL
+start_handler (userData, tag, att)	/* command tag att[0]=att[1] ... */
+    void *userData;	/* not used */
+    XML_Char *tag, **att;
+{
+    char *a, *b;
+    WORD_LIST *p, *list;
+    int n, m;
+    GtkWidget *w, *top;
+    double x, y, step;
+
+    w = (GtkWidget *)NULL;
+    xml_element_depth++;
+
+    /* Toplevel window must be the first tag.
+     */
+    if (xml_element_depth == 1 && ! (STREQ (tag, "window") ||
+				     STREQ (tag, "dialog") ||
+				     STREQ (tag, "fileselection") ||
+				     STREQ (tag, "filechooserdialog"))) {
+	builtin_error ("`%s': expected toplevel window", tag);
+	return;
+    }
+    else if (xml_element_depth > 1 && widget_list == 0) {
+	return;
+    }
+
+    if (STREQ (tag, "window")) {		/* top level */
+	w = gtk_window_new (GTK_WINDOW_TOPLEVEL);
+	setup_toplevel_window (w);
+
+	for ( ; att[0] && att[1]; att += 2) {
+	    a = att[0];
+	    b = att[1];
+	    if (STREQ (a, "label")) {
+		gtk_window_set_title (GTK_WINDOW (w), (gchar *)b);
+	    }
+	    else if (STREQ (a, "border") && legal_positive_integer (b, &n)) {
+		gtk_container_set_border_width (GTK_CONTAINER (w), (guint)n);
+	    }
+	    else if (STREQ (a, "size") && sscanf (b, "%dx%d", &n, &m) == 2) {
+		gtk_window_set_default_size (GTK_WINDOW (w), (guint)n, (guint)m);
+	    }
+	    else
+		unknown_attribute (tag, a, b);
+	}
+    }
+    else if (STREQ (tag, "dialog")) {		/* top level */
+	w = gtk_dialog_new();
+	setup_toplevel_window (w);
+
+	for ( ; att[0] && att[1]; att += 2) {
+	    a = att[0];
+	    b = att[1];
+	    if (STREQ (a, "label")) {
+		gtk_window_set_title (GTK_WINDOW (w), (gchar *)b);
+	    }
+	    else if (STREQ (a, "border") && legal_positive_integer (b, &n)) {
+		gtk_container_set_border_width (GTK_CONTAINER (w), (guint)n);
+	    }
+	    else if (STREQ (a, "size") && sscanf (b, "%dx%d", &n, &m) == 2) {
+		gtk_window_set_default_size (GTK_WINDOW (w), (guint)n, (guint)m);
+	    }
+	    else if (STREQ (a, "buttons")) {
+		list = string_minus_separator (b, "");		/* CSV string */
+		for (p = list, n = 0; p; p = p->next, n++)
+		    gtk_dialog_add_button (GTK_DIALOG (w), (gchar *)(p->word->word), (gint)n);
+		dispose_words (list);
+	    }
+	    else if (STREQ (a, "id")) {
+		g_signal_connect (G_OBJECT (w), "response",
+				  G_CALLBACK (dialog_callback), (gpointer)savestring (b));
+		g_signal_connect_swapped (G_OBJECT (w), "response",
+					  G_CALLBACK (gtk_widget_destroy), (gpointer)w);
+	    }
+	    else
+		unknown_attribute (tag, a, b);
+	}
+    }
+    else if (STREQ (tag, "fileselection")) {		/* top level */
+	w = gtk_file_selection_new (NULL);	/* title */
+	setup_toplevel_window (w);
+
+	for ( ; att[0] && att[1]; att += 2) {
+	    a = att[0];
+	    b = att[1];
+	    if (STREQ (a, "id")) {
+		g_signal_connect (G_OBJECT (GTK_FILE_SELECTION (w)->ok_button), "clicked",
+				  G_CALLBACK (fileselection_callback), (gpointer)savestring (b));
+		g_signal_connect_swapped (G_OBJECT (GTK_FILE_SELECTION (w)->ok_button),
+					  "clicked",
+					  G_CALLBACK (gtk_widget_destroy), (gpointer)w);
+		g_signal_connect_swapped (G_OBJECT (GTK_FILE_SELECTION (w)->cancel_button),
+					  "clicked",
+					  G_CALLBACK (gtk_widget_destroy), (gpointer)w);
+	    }
+	    else if (STREQ (a, "initial")) {
+		gtk_file_selection_set_filename (GTK_FILE_SELECTION (w), (gchar *)b);
+	    }
+	    else if (STREQ (a, "fileop")) {
+		if (STREQ (b, "on"))
+		    gtk_file_selection_show_fileop_buttons (GTK_FILE_SELECTION (w));
+		else if (STREQ (b, "off"))
+		    gtk_file_selection_hide_fileop_buttons (GTK_FILE_SELECTION (w));
+		else 
+		    unknown_attribute (tag, a, b);
+	    }
+	    else if (STREQ (a, "size") && sscanf (b, "%dx%d", &n, &m) == 2) {
+		gtk_window_set_default_size (GTK_WINDOW (w), (guint)n, (guint)m);
+	    }
+	    else
+		unknown_attribute (tag, a, b);
+	}
+    }
+    else if (STREQ (tag, "filechooserdialog")) {	/* top level */
+	w = gtk_file_chooser_dialog_new (NULL, NULL,	/* title, parent */
+		GTK_FILE_CHOOSER_ACTION_OPEN,
+		GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL, GTK_STOCK_OK, GTK_RESPONSE_OK,
+		NULL);
+	setup_toplevel_window (w);
+
+	for ( ; att[0] && att[1]; att += 2) {
+	    a = att[0];
+	    b = att[1];
+	    if (STREQ (a, "id")) {
+		g_signal_connect (G_OBJECT (w), "response",
+				  G_CALLBACK (filechooserdialog_callback),
+				  (gpointer)savestring (b));
+		g_signal_connect_swapped (G_OBJECT (w), "response",
+					  G_CALLBACK (gtk_widget_destroy), (gpointer)w);
+	    }
+	    else if (STREQ (a, "initial")) {
+		gtk_file_chooser_set_filename (GTK_FILE_CHOOSER (w), (gchar *)b);
+	    }
+	    else if (STREQ (a, "action")) {
+		if (STREQ (b, "open"))
+		    gtk_file_chooser_set_action (GTK_FILE_CHOOSER (w),
+						 GTK_FILE_CHOOSER_ACTION_OPEN);
+		else if (STREQ (b, "save"))
+		    gtk_file_chooser_set_action (GTK_FILE_CHOOSER (w),
+						 GTK_FILE_CHOOSER_ACTION_SAVE);
+		else if (STREQ (b, "selectfolder"))
+		    gtk_file_chooser_set_action (GTK_FILE_CHOOSER (w),
+						 GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER);
+		else if (STREQ (b, "createfolder"))
+		    gtk_file_chooser_set_action (GTK_FILE_CHOOSER (w),
+						 GTK_FILE_CHOOSER_ACTION_CREATE_FOLDER);
+		else
+		    unknown_attribute (tag, a, b);
+	    }
+	    else if (STREQ (a, "size") && sscanf (b, "%dx%d", &n, &m) == 2) {
+		gtk_window_set_default_size (GTK_WINDOW (w), (guint)n, (guint)m);
+	    }
+	    else
+		unknown_attribute (tag, a, b);
+	}
+    }
+    else if (STREQ (tag, "hbox") || STREQ (tag, "vbox")) {
+	if (STREQ (tag, "hbox"))
+	    w = gtk_hbox_new (FALSE, 0);	/* homogeneous, spacing */
+	else
+	    w = gtk_vbox_new (FALSE, 0);	/* homogeneous, spacing */
+	pack_widget (w);
+
+	for ( ; att[0] && att[1]; att += 2) {
+	    a = att[0];
+	    b = att[1];
+	    if (STREQ (a, "spacing") && legal_positive_integer (b, &n)) {
+		gtk_box_set_spacing (GTK_BOX (w), (gint)n);
+	    }
+	    else if (STREQ (a, "homogeneous")) {
+		set_on_or_off (gtk_box_set_homogeneous, GTK_BOX (w));
+	    }
+	    else
+		unknown_attribute (tag, a, b);
+	}
+    }
+    else if (STREQ (tag, "hbuttonbox") || STREQ (tag, "vbuttonbox")) {
+	if (STREQ (tag, "hbuttonbox")) 
+	    w = gtk_hbutton_box_new();
+	else 
+	    w = gtk_vbutton_box_new();
+	pack_widget (w);
+
+	for ( ; att[0] && att[1]; att += 2) {
+	    a = att[0];
+	    b = att[1];
+	    if (STREQ (a, "spacing") && legal_positive_integer (b, &n)) {
+		gtk_box_set_spacing (GTK_BOX (w), (gint)n);
+	    }
+	    else if (STREQ (a, "homogeneous")) {
+		set_on_or_off (gtk_box_set_homogeneous, GTK_BOX (w));
+	    }
+	    else if (STREQ (a, "layout")) {
+		if (STREQ (b, "spread"))
+		    gtk_button_box_set_layout (GTK_BUTTON_BOX (w), GTK_BUTTONBOX_SPREAD);
+		else if (STREQ (b, "edge"))
+		    gtk_button_box_set_layout (GTK_BUTTON_BOX (w), GTK_BUTTONBOX_EDGE);
+		else if (STREQ (b, "start"))
+		    gtk_button_box_set_layout (GTK_BUTTON_BOX (w), GTK_BUTTONBOX_START);
+		else if (STREQ (b, "end"))
+		    gtk_button_box_set_layout (GTK_BUTTON_BOX (w), GTK_BUTTONBOX_END);
+		else
+		    unknown_attribute (tag, a, b);
+	    }
+	    else
+		unknown_attribute (tag, a, b);
+	}
+    }
+    else if (STREQ (tag, "hpaned")) {
+	w = gtk_hpaned_new();
+	pack_widget (w);
+    }
+    else if (STREQ (tag, "vpaned")) {
+	w = gtk_vpaned_new();
+	pack_widget (w);
+    }
+    else if (STREQ (tag, "scrolledwindow")) {
+	w = gtk_scrolled_window_new (NULL, NULL);	/* hadjustment, vadjustment */
+	pack_widget (w);
+    }
+    else if (STREQ (tag, "hseparator")) {
+	w = gtk_hseparator_new();
+	pack_widget (w);
+    }
+    else if (STREQ (tag, "vseparator")) {
+	w = gtk_vseparator_new();
+	pack_widget (w);
+    }
+    else if (STREQ (tag, "arrowright")) {
+	w = gtk_arrow_new (GTK_ARROW_RIGHT, GTK_SHADOW_OUT /* default */);
+	pack_widget (w);
+    }
+    else if (STREQ (tag, "arrowleft")) {
+	w = gtk_arrow_new (GTK_ARROW_LEFT, GTK_SHADOW_OUT /* default */);
+	pack_widget (w);
+    }
+    else if (STREQ (tag, "arrowup")) {
+	w = gtk_arrow_new (GTK_ARROW_UP, GTK_SHADOW_OUT /* default */);
+	pack_widget (w);
+    }
+    else if (STREQ (tag, "arrowdown")) {
+	w = gtk_arrow_new (GTK_ARROW_DOWN, GTK_SHADOW_OUT /* default */);
+	pack_widget (w);
+    }
+
+    /* The below widgets are usually packed into box.  So, process packing
+     * parameters.
+     */
+    else if (STREQ (tag, "table")) {
+	w = gtk_table_new (0, 0, FALSE);	/* rows, columns, homogeneous */
+	pack_widget (w);
+
+	for ( ; att[0] && att[1]; att += 2) {
+	    a = att[0];
+	    b = att[1];
+	    if (set_packing_parameters (w, a, b))
+		continue;
+	    if (STREQ (a, "size") && sscanf (b, "%dx%d", &n, &m) == 2) {
+		gtk_table_resize (GTK_TABLE (w), (guint)n, (guint)m);
+	    }
+	    else if (STREQ (a, "spacing") && legal_positive_integer (b, &n)) {
+		gtk_table_set_row_spacings (GTK_TABLE (w), (guint)n);
+		gtk_table_set_col_spacings (GTK_TABLE (w), (guint)n);
+	    }
+	    else if (STREQ (a, "homogeneous")) {
+		set_on_or_off (gtk_table_set_homogeneous, GTK_TABLE (w));
+	    }
+	    else
+		unknown_attribute (tag, a, b);
+	}
+	tablerow = tablecol = 0;
+    }
+    else if (STREQ (tag, "frame")) {
+	w = gtk_frame_new (NULL);	/* label */
+	pack_widget (w);
+
+	for ( ; att[0] && att[1]; att += 2) {
+	    a = att[0];
+	    b = att[1];
+	    if (set_packing_parameters (w, a, b))
+		continue;
+	    if (STREQ (a, "label")) {
+		gtk_frame_set_label (GTK_FRAME (w), (gchar *)b);
+	    }
+	    else if (STREQ (a, "align") && sscanf (b, "%lf,%lf", &x, &y) == 2) {
+		gtk_frame_set_label_align (GTK_FRAME (w), (gfloat)x, (gfloat)y);
+	    }
+	    else
+		unknown_attribute (tag, a, b);
+	}
+    }
+    else if (STREQ (tag, "label")) {
+	w = gtk_label_new (NULL);	/* label */
+	pack_widget (w);
+
+	for ( ; att[0] && att[1]; att += 2) {
+	    a = att[0];
+	    b = att[1];
+	    if (set_packing_parameters (w, a, b))
+		continue;
+	    if (STREQ (a, "label")) {
+		gtk_label_set_text (GTK_LABEL (w), b);
+	    }
+	    else if (STREQ (a, "justify")) {
+		if (STREQ (b, "left")) 
+		    gtk_label_set_justify (GTK_LABEL (w), GTK_JUSTIFY_LEFT);
+		else if (STREQ (b, "right")) 
+		    gtk_label_set_justify (GTK_LABEL (w), GTK_JUSTIFY_RIGHT);
+		else if (STREQ (b, "center")) 
+		    gtk_label_set_justify (GTK_LABEL (w), GTK_JUSTIFY_CENTER);
+		else if (STREQ (b, "fill")) 
+		    gtk_label_set_justify (GTK_LABEL (w), GTK_JUSTIFY_FILL);
+		else
+		    unknown_attribute (tag, a, b);
+	    }
+	    else if (STREQ (a, "align") && sscanf (b, "%lf,%lf", &x, &y) == 2) {
+		gtk_misc_set_alignment (GTK_MISC (w), (gfloat)x, (gfloat)y);
+	    }
+	    else if (STREQ (a, "wrap")) {
+		set_on_or_off (gtk_label_set_line_wrap, GTK_LABEL (w));
+	    }
+	    else
+		unknown_attribute (tag, a, b);
+	}
+	FREE (data_text);
+	data_text = (char *)NULL;
+    }
+    else if (STREQ (tag, "button")) {
+	w = gtk_button_new ();
+	pack_widget (w);
+
+	for ( ; att[0] && att[1]; att += 2) {
+	    a = att[0];
+	    b = att[1];
+	    if (set_packing_parameters (w, a, b))
+		continue;
+	    if (STREQ (a, "label")) {
+		gtk_button_set_label (GTK_BUTTON (w), (gchar *)b);
+	    }
+	    /* From: Raul Suarez <rarsa@yahoo.com> (KWLUG).  Add image in a file
+	     * to button.  Should be specified after 'label'. */
+	    else if (STREQ (a, "image")) {
+		gtk_button_set_image (GTK_BUTTON (w), gtk_image_new_from_file((gchar *)b));
+	    }
+	    else if (STREQ (a, "stock")) {
+		gtk_button_set_label (GTK_BUTTON (w), (gchar *)b);
+		gtk_button_set_use_stock (GTK_BUTTON (w), TRUE);
+	    }
+	    else if (STREQ (a, "command") || STREQ (a, "delete") || STREQ (a, "quit")) {
+		if (*b)
+		    g_signal_connect (G_OBJECT (w), "clicked",
+				      G_CALLBACK (button_callback), (gpointer)savestring (b));
+		/* 'b' must be copied, because g_signal_connect() doesn't make
+		 * copy.
+		 */
+		if (STREQ (a, "delete")) {
+		    g_signal_connect_swapped (G_OBJECT (w), "clicked",
+					      G_CALLBACK (gtk_widget_destroy), (gpointer)w);
+		} else if (STREQ (a, "quit")) {
+		    top = gtk_widget_get_toplevel (w);
+		    g_signal_connect_swapped (G_OBJECT (w), "clicked",
+					      G_CALLBACK (gtk_widget_destroy), (gpointer)top);
+		}
+	    }
+	    else
+		unknown_attribute (tag, a, b);
+	}
+    }
+    else if (STREQ (tag, "checkbutton") || STREQ (tag, "radiobutton") || STREQ (tag, "togglebutton")) {
+	if (STREQ (tag, "checkbutton"))
+	    w = gtk_check_button_new ();
+	else if (STREQ (tag, "togglebutton"))
+	    w = gtk_toggle_button_new();
+	else {
+	    w = gtk_radio_button_new (radio_group);
+	    radio_group = gtk_radio_button_get_group (GTK_RADIO_BUTTON (w));
+	}
+	pack_widget (w);
+
+	for ( ; att[0] && att[1]; att += 2) {
+	    a = att[0];
+	    b = att[1];
+	    if (set_packing_parameters (w, a, b))
+		continue;
+	    if (STREQ (a, "label")) {
+		gtk_button_set_label (GTK_BUTTON (w), (gchar *)b);
+	    }
+	    else if (STREQ (a, "id")) {
+		g_signal_connect (G_OBJECT (w),
+				  STREQ (tag, "togglebutton")? "toggled": "clicked", 
+				  G_CALLBACK (checkbutton_callback), (gpointer)savestring (b));
+		/* use the same callback for check/radio/toggle buttons */
+	    }
+	    else if (STREQ (a, "initial")) {
+		set_on_or_off (gtk_toggle_button_set_active, GTK_TOGGLE_BUTTON (w));
+	    }
+	    else
+		unknown_attribute (tag, a, b);
+	}
+    }
+    else if (STREQ (tag, "entry")) {
+	w = gtk_entry_new ();
+	pack_widget (w);
+
+	for ( ; att[0] && att[1]; att += 2) {
+	    a = att[0];
+	    b = att[1];
+	    if (set_packing_parameters (w, a, b))
+		continue;
+	    if (STREQ (a, "id")) {
+		g_signal_connect (G_OBJECT (w), "changed",
+				  G_CALLBACK (entry_callback), (gpointer)savestring (b));
+	    }
+	    else if (STREQ (a, "initial")) {
+		gtk_entry_set_text (GTK_ENTRY (w), (gchar *)b);
+	    }
+	    else if (STREQ (a, "visible")) {
+		set_on_or_off (gtk_entry_set_visibility, GTK_ENTRY (w));
+	    }
+	    else if (STREQ (a, "editable")) {
+		set_on_or_off (gtk_editable_set_editable, GTK_EDITABLE (w));
+	    }
+	    else
+		unknown_attribute (tag, a, b);
+	}
+    }
+    else if (STREQ (tag, "combobox") || STREQ (tag, "comboboxentry")) {
+	if (STREQ (tag, "combobox"))
+	    w = gtk_combo_box_new_text();
+	else
+	    w = gtk_combo_box_entry_new_text();
+	pack_widget (w);
+
+	for ( ; att[0] && att[1]; att += 2) {
+	    a = att[0];
+	    b = att[1];
+	    if (set_packing_parameters (w, a, b))
+		continue;
+	    if (STREQ (a, "id")) {
+		g_signal_connect (G_OBJECT (w), "changed",
+				  STREQ (tag, "combobox")?
+				      G_CALLBACK (combobox_callback):
+				      G_CALLBACK (comboboxentry_callback),
+				  (gpointer)savestring (b));
+	    }
+	    else
+		unknown_attribute (tag, a, b);
+	}
+	FREE (data_text);
+	data_text = (char *)NULL;
+    }
+    else if (STREQ (tag, "hscale") || STREQ (tag, "vscale")) {
+	if (STREQ (tag, "hscale"))
+	    w = gtk_hscale_new (NULL);		/* adjustment */
+	else 
+	    w = gtk_vscale_new (NULL);		/* adjustment */
+	pack_widget (w);
+
+	for ( ; att[0] && att[1]; att += 2) {
+	    a = att[0];
+	    b = att[1];
+	    if (set_packing_parameters (w, a, b))
+		continue;
+	    if (STREQ (a, "id")) {
+		g_signal_connect (G_OBJECT (w), "value_changed",
+				  G_CALLBACK (scale_callback), (gpointer)savestring (b));
+	    }
+	    else if (STREQ (a, "range") && sscanf (b, "%lf,%lf,%lf", &x, &y, &step) == 3) {
+		gtk_range_set_range (GTK_RANGE (w), (gdouble)x, (gdouble)y);
+		gtk_range_set_increments (GTK_RANGE (w), (gdouble)step, (gdouble)(10 * step));
+	    }
+	    else if (STREQ (a, "initial") && sscanf (b, "%lf", &x) == 1) {
+		gtk_range_set_value (GTK_RANGE (w), (gdouble)x);
+	    }
+	    else if (STREQ (a, "digits") && legal_positive_integer (b, &n)) {
+		gtk_scale_set_digits (GTK_SCALE (w), (gint)n);
+	    }
+	    else if (STREQ (a, "inverted")) {
+		set_on_or_off (gtk_range_set_inverted, GTK_RANGE (w));
+	    }
+	    else
+		unknown_attribute (tag, a, b);
+	}
+    }
+    else if (STREQ (tag, "spinbutton")) {
+	w = gtk_spin_button_new (NULL, 0, 0);	/* adjustment, climb_rate, digits */
+	pack_widget (w);
+
+	for ( ; att[0] && att[1]; att += 2) {
+	    a = att[0];
+	    b = att[1];
+	    if (set_packing_parameters (w, a, b))
+		continue;
+	    if (STREQ (a, "id")) {
+		g_signal_connect (G_OBJECT (w), "value_changed",
+				  G_CALLBACK (spinbutton_callback), (gpointer)savestring (b));
+	    }
+	    else if (STREQ (a, "range") && sscanf (b, "%lf,%lf,%lf", &x, &y, &step) == 3) {
+		gtk_spin_button_set_range (GTK_SPIN_BUTTON (w), (gdouble)x, (gdouble)y);
+		gtk_spin_button_set_increments (GTK_SPIN_BUTTON (w),
+					        (gdouble)step, (gdouble)(10 * step));
+	    }
+	    else if (STREQ (a, "initial") && sscanf (b, "%lf", &x) == 1) {
+		gtk_spin_button_set_value (GTK_SPIN_BUTTON (w), (gdouble)x);
+	    }
+	    else if (STREQ (a, "digits") && legal_positive_integer (b, &n)) {
+		gtk_spin_button_set_digits (GTK_SPIN_BUTTON (w), (guint)n);
+	    }
+	    else if (STREQ (a, "wrap")) {
+		set_on_or_off (gtk_spin_button_set_wrap, GTK_SPIN_BUTTON (w));
+	    }
+	    else if (STREQ (a, "numeric")) {
+		set_on_or_off (gtk_spin_button_set_numeric, GTK_SPIN_BUTTON (w));
+	    }
+	    else if (STREQ (a, "snap")) {
+		set_on_or_off (gtk_spin_button_set_snap_to_ticks, GTK_SPIN_BUTTON (w));
+	    }
+	    else
+		unknown_attribute (tag, a, b);
+	}
+    }
+    else if (STREQ (tag, "calendar")) {
+	int year, month, day;
+	GtkCalendarDisplayOptions flags;
+
+	w = gtk_calendar_new();
+	pack_widget (w);
+
+	for ( ; att[0] && att[1]; att += 2) {
+	    a = att[0];
+	    b = att[1];
+	    if (set_packing_parameters (w, a, b))
+		continue;
+	    if (STREQ (a, "id")) {
+		g_signal_connect (G_OBJECT (w), "day_selected",
+				  G_CALLBACK (calendar_callback), (gpointer)savestring (b));
+	    }
+	    else if (STREQ (a, "initial")) {
+		n = sscanf (b, "%d-%d-%d", &year, &month, &day);
+		if (n == 3) {
+		    gtk_calendar_select_month (GTK_CALENDAR (w), (guint)(month - 1), (guint)year);
+		    gtk_calendar_select_day (GTK_CALENDAR (w), (guint)day);
+		}
+		else if (n == 2) {
+		    gtk_calendar_select_month (GTK_CALENDAR (w), (guint)(month - 1), (guint)year);
+		}
+		else
+		    unknown_attribute (tag, a, b);
+	    }
+	    else if (STREQ (a, "mark") && legal_positive_integer (b, &day)) {
+		gtk_calendar_mark_day (GTK_CALENDAR (w), (guint)day);
+	    }
+	    else if (STREQ (a, "monthchange")) {
+		flags = gtk_calendar_get_display_options (GTK_CALENDAR (w));
+		if (STREQ (b, "on")) 
+		    flags &= ~GTK_CALENDAR_NO_MONTH_CHANGE;
+		else if (STREQ (b, "off")) 
+		    flags |= GTK_CALENDAR_NO_MONTH_CHANGE;
+		else
+		    unknown_attribute (tag, a, b);
+		gtk_calendar_set_display_options (GTK_CALENDAR (w), flags);
+	    }
+	    else if (STREQ (a, "weeknumbers")) {
+		flags = gtk_calendar_get_display_options (GTK_CALENDAR (w));
+		if (STREQ (b, "on")) 
+		    flags |= GTK_CALENDAR_SHOW_WEEK_NUMBERS;
+		else if (STREQ (b, "off")) 
+		    flags &= ~GTK_CALENDAR_SHOW_WEEK_NUMBERS;
+		else
+		    unknown_attribute (tag, a, b);
+		gtk_calendar_set_display_options (GTK_CALENDAR (w), flags);
+	    }
+	    else
+		unknown_attribute (tag, a, b);
+	}
+    }
+    else if (STREQ (tag, "radio")) {
+	/* Special case: <radio></radio> is artificial syntax, used to group
+	 * <radiobutton>.  It does not change the widget stack.  Nesting is
+	 * ignored, because <radio> or </radio> simply resets 'radio_group'
+	 * global variable.
+	 */
+	radio_group = (GSList *)NULL;
+    }
+    else
+	builtin_error ("`%s': unknown GTK+ start tag", tag);
+    
+    if (w)
+	widget_list = g_slist_prepend (widget_list, (gpointer)w);
+}
+
+
+static void XMLCALL
+end_handler (userData, tag)
+    void *userData;	/* not used */
+    XML_Char *tag;
+{
+    GtkWidget *w;
+    GSList *g;
+    WORD_LIST *p, *list;
+    char *t;
+
+    xml_element_depth--;
+    if (widget_list == 0)		/* no window */
+	return;
+
+    if (STREQ (tag, "radio")) {		/* special case */
+	radio_group = (GSList *)NULL;
+	return;
+    }
+
+    if (STREQ (tag, "label") && data_text) {
+	w = (GtkWidget *)(widget_list->data);
+	t = strip_leading_trailing (data_text, STRIP_LR);
+	gtk_label_set_text (GTK_LABEL (w), t);
+	FREE (t);
+	FREE (data_text);
+	data_text = (char *)NULL;
+    }
+    else if ((STREQ (tag, "combobox") || STREQ (tag, "comboboxentry")) && data_text) {
+	w = (GtkWidget *)(widget_list->data);
+	t = strip_leading_trailing (data_text, STRIP_LR);
+	list = string_minus_separator (t, "\n");
+	FREE (t);
+	for (p = list; p; p = p->next) {
+	    t = strip_leading_trailing (p->word->word, STRIP_LR);
+	    gtk_combo_box_append_text (GTK_COMBO_BOX (w), (gchar *)t);
+	    FREE (t);
+	}
+	dispose_words (list);
+	FREE (data_text);
+	data_text = (char *)NULL;
+    }
+    else if (STREQ (tag, "table")) {
+	tablerow = tablecol = 0;
+    }
+
+    if (STREQ (tag, "window") || STREQ (tag, "dialog") || 
+	    STREQ (tag, "fileselection") || STREQ (tag, "filechooserdialog") ||
+	    STREQ (tag, "hbox") || STREQ (tag, "vbox") ||
+	    STREQ (tag, "hbuttonbox") || STREQ (tag, "vbuttonbox") ||
+	    STREQ (tag, "hpaned") || STREQ (tag, "vpaned") ||
+	    STREQ (tag, "hseparator") || STREQ (tag, "vseparator") ||
+	    STREQ (tag, "arrowright") || STREQ (tag, "arrowleft") || 
+	    STREQ (tag, "arrowup") || STREQ (tag, "arrowdown") || 
+	    STREQ (tag, "frame") || STREQ (tag, "label") ||
+	    STREQ (tag, "table") || STREQ (tag, "scrolledwindow") ||
+
+	    STREQ (tag, "button") || STREQ (tag, "togglebutton") ||
+	    STREQ (tag, "checkbutton") || STREQ (tag, "radiobutton") ||
+	    STREQ (tag, "entry") ||
+	    STREQ (tag, "combobox") || STREQ (tag, "comboboxentry") ||
+	    STREQ (tag, "hscale") || STREQ (tag, "vscale") ||
+	    STREQ (tag, "spinbutton") || STREQ (tag, "calendar")
+       ) {
+	w = (GtkWidget *)(widget_list->data);
+	gtk_widget_show (w);
+
+	g = widget_list;	/* pop */
+	widget_list = widget_list->next;
+	g->next = (GSList *)NULL;
+	g_slist_free (g);
+    } else
+	builtin_error ("`%s': unknown GTK+ end tag", tag);
+}
+
+
+static void XMLCALL
+data_handler (userData, data, len)
+    void *userData;	/* not used */
+    XML_Char *data;	/* 'data' is not 0-terminated */
+    int len;
+{
+    GtkWidget *w;
+    char *tag;
+
+    if (widget_list == 0)	/* no window */
+	return;
+
+    w = (GtkWidget *)(widget_list->data);
+    if (GTK_IS_LABEL (w) || GTK_IS_COMBO_BOX (w) || GTK_IS_COMBO_BOX_ENTRY (w))
+	data_text = string_nadd (data_text, data, len);
+}
+
+
+/*******************************************************************************
+ * Main builtin
+ */
+int
+gtk_builtin (list)
+     WORD_LIST *list;
+{
+    int out, opt, argc;
+    char *s, **argv;
+    XML_Parser p;
+    WORD_LIST *plist;
+
+    argv = make_builtin_argv  (list, &argc);
+    if (gtk_init_check (&argc, &argv) == FALSE) {
+	builtin_error ("gtk_init_check() failed.");
+	FREE (argv);
+	return (EXECUTION_FAILURE);
+    }
+
+    list = plist = strvec_to_word_list (argv, 1 /* alloc */, 1 /* starting_index */);
+    FREE (argv);
+
+    if (no_options (list))
+	return (EX_BADUSAGE);
+    list = loptend;		/* skip over possible `--' */
+
+    widget_list = (GSList *)NULL;
+    xml_element_depth = 0;
+    radio_group = (GSList *)NULL;
+
+    p = XML_ParserCreate (NULL);
+    XML_SetStartElementHandler (p, start_handler);
+    XML_SetEndElementHandler (p, end_handler);
+    XML_SetCharacterDataHandler (p, data_handler);
+
+    out = EXECUTION_SUCCESS;
+    if (list == 0) {		/* read from stdin (fd=0) */
+	s = slurp_fd_into_string (0);
+	if (s == 0)
+	    out = EXECUTION_FAILURE;
+	else if (XML_Parse (p, s, strlen (s), 0 /* isFinal */) == XML_STATUS_ERROR) {
+	    builtin_error ("Parse error at line %d: %s",
+		    XML_GetCurrentLineNumber (p),
+		    XML_ErrorString (XML_GetErrorCode (p)));
+	    out = EXECUTION_FAILURE;
+	}
+	FREE (s);
+    } else {
+	for ( ; list && out == EXECUTION_SUCCESS; list = list->next) {
+	    s = slurp_filename_into_string (list->word->word);
+	    if (s == 0)
+		out = EXECUTION_FAILURE;
+	    else if (XML_Parse (p, s, strlen (s), 0 /* isFinal */) == XML_STATUS_ERROR) {
+		builtin_error ("Parse error at line %d: %s",
+			XML_GetCurrentLineNumber (p),
+			XML_ErrorString (XML_GetErrorCode (p)));
+		out = EXECUTION_FAILURE;
+	    }
+	    FREE (s);
+	}
+    }
+    if (out == EXECUTION_SUCCESS)	/* tell Expat to finish parsing */
+	XML_Parse (p, "", 0, 1 /* isFinal */);
+    
+    XML_ParserFree (p);
+    dispose_words (plist);
+
+    /* Run gtk_main(), only if syntax is okey, and there is toplevel window.
+     */
+    if (out == EXECUTION_SUCCESS && gtk_window_list_toplevels())
+	gtk_main();
+
+    return (out);
+}
+
+
+char *gtk_doc[] = {
+    "Interface to GTK+ 2.6.1 (www.gtk.org).  It reads XML syntax describing the",
+    "layout of widgets from stdin or file.  It uses Expat to parse the input",
+    "syntax, and makes appropriate GTK+ calls as it encounters widget tags and",
+    "attributes.  Currently, the following tags and attributes are recognized:",
+    "",
+    "<window label=TEXT border=N size=NxN></window>",
+    "<dialog label=TEXT border=N size=NxN buttons=CSV id=NAME></dialog>",
+    "<fileselection id=NAME initial=PATH fileop=[on|off] size=NxN/>",
+    "<filechooserdialog id=NAME initial=PATH action=ACTION size=NxN/>",
+    "    <hbox spacing=N homogeneous=[on|off]></hbox>",
+    "    <vbox spacing=N homogeneous=[on|off]></vbox>",
+    "    <hbuttonbox spacing=N homogeneous=[on|off] layout=LAYOUT></hbuttonbox>",
+    "    <vbuttonbox spacing=N homogeneous=[on|off] layout=LAYOUT></vbuttonbox>",
+    "    <hpaned></hpaned>",
+    "    <vpaned></vpaned>",
+    "    <scrolledwindow></scrolledwindow>",
+    "        <hseparator/>",
+    "        <vseparator/>",
+    "        <arrowup/>",
+    "        <arrowdown/>",
+    "        <arrowleft/>",
+    "        <arrowright/>",
+    "        <table size=NxN spacing=N homogeneous=[on|off] pack=PACK></table>",
+    "        <frame label=TEXT align=X,Y pack=PACK></frame>",
+    "        <label label=TEXT justify=JUSTIFY align=X,Y wrap=[on|off] pack=PACK>TEXT</label>",
+    "        <button [label|stock]=TEXT image=FILE [command|delete|quit]=COMMAND pack=PACK />",
+    "        <checkbutton label=TEXT id=NAME initial=[on|off] pack=PACK />",
+    "        <radio></radio>",
+    "            <radiobutton label=TEXT id=NAME initial=[on|off] pack=PACK />",
+    "        <togglebutton label=TEXT id=NAME initial=[on|off] pack=PACK />",
+    "        <entry id=NAME initial=TEXT [visible|editable]=[on|off] pack=PACK />",
+    "        <combobox id=NAME pack=PACK>TEXT</combobox>",
+    "        <comboboxentry id=NAME pack=PACK>TEXT</comboboxentry>",
+    "        <hscale id=NAME range=RANGE inverted=[on|off] pack=PACK/>",
+    "        <vscale id=NAME range=RANGE inverted=[on|off] pack=PACK/>",
+    "        <spinbutton id=NAME range=RANGE [wrap|numeric|snap]=[on|off] pack=PACK/>",
+    "        <calendar id=NAME initial=YEAR-MONTH[-DAY] mark=DAY [monthchange|weeknumbers]=[on|off] pack=PACK/>",
+    "where",
+    "    NAME = shell variable containing text entry or button state",
+    "    COMMAND = shell command to be run when the button is clicked",
+    "    LAYOUT = [ spread | edge | start | end ]",
+    "    JUSTIFY = [ left | right | center | fill ]",
+    "    ACTION = [ open | save | selectfolder | createfolder ]",
+    "    N,YEAR,MONTH,DAY = integers",
+    "    X,Y = floating points [0,1]",
+    "    CSV = comma separated values",
+    "    pack=PACK",
+    "        is any combination of 'expand=[on|off]', 'fill=[on|off]', and",
+    "        'padding=N', or general 'pack=[on|off]' which means",
+    "        'expand=[on|off]', 'fill=[on|off]', and 'padding=0'.",
+    "    range=RANGE",
+    "        is any combination of 'range=MIN,MAX,STEP', 'initial=VALUE', and",
+    "        'digits=N', where MIN, MAX, STEP, and VALUE are double.",
+    "",
+    "The top-level <window> of GTK+ can have only one widget.  So, a box widget",
+    "is used to pack other widgets, which can be box widgets recursively.  Here,",
+    "PACK determines how a child widget is packed into parent box widgets.  When",
+    "packing into <table> widget, items will be packed sequentially, going",
+    "across the rows, and will silently wrap around.  Table widget is not",
+    "affected by PACK parameters.",
+    "",
+    "<dialog> widget is top-level window, like <window> widget, except that",
+    "top half is where you pack other widgets, and bottom half is where buttons",
+    "are placed.  The buttons are numbered from 0 left-to-right.  And, when",
+    "clicked, the dialog window closes, and the button number is saved to shell",
+    "variable NAME.  CSV contains the usual GTK+ label for stock buttons, like",
+    "'gtk-ok' and 'gtk-cancel'.  All top-level windows will be destroyed when",
+    "parent window is destroyed.",
+    "",
+    "TEXT for <label> widget can be given as attribute or as data element, in",
+    "which case the leading/trailing whitespaces are stripped.  TEXT for",
+    "<combobox> and <comboboxentry> widgets, the leading/trailing whitespaces",
+    "are stripped before splitting into each line and also afterwards.",
+    "",
+    "Buttons and Entry (ie. command=COMMAND, id=NAME) widgets are the only means",
+    "of getting data from user.  Every time a char is changed in <entry> or",
+    "<comboboxentry> widgets, its content is saved to shell variable NAME.  When",
+    "<button> is clicked, shell COMMAND (if not empty) will be executed at the",
+    "same level as 'gtk' builtin.  Then, 'delete' will delete the button, and",
+    "'quit' will delete the top-level window that the button is in.  If button",
+    "label is given as 'stock', then GTK+ stock button is used.",
+    "",
+    "Optional <radio></radio> is an artificial syntax, used to group radio",
+    "buttons.  It doesn't affect the widget layout.",
+    (char *)NULL
+};
+struct builtin gtk_struct = {
+    "gtk", gtk_builtin, BUILTIN_ENABLED, gtk_doc,
+    "gtk [file... | < file]",
+    (char *)NULL
+};
+
+#endif	/* HAVE_EXPAT && HAVE_GTK2 */
--- bash-3.2_orig/examples/loadables/william/herefile.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/herefile.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,71 @@
+/*******************************************************************************
+ * Here-file.  Same as 'cat', except the stdin or file is treated as
+ * 'here-document', and parameter expansion, command substitution, and
+ * arithmetic expansion are preformed.
+ */
+
+#include "loadables.h"
+
+
+int
+herefile_builtin (list)
+    WORD_LIST *list;
+{
+    int opt, retcount, fd;
+    char *out, *in;
+    size_t size;
+
+    if (no_options (list))
+	return (EX_BADUSAGE);
+    list = loptend;		/* skip over possible `--' */
+
+    retcount = 0;
+
+    if (list == 0) {		/* read from stdin (fd=0) */
+	in = slurp_fd_into_string (0);
+	if (in == 0)
+	    retcount++;
+	else {
+	    out = expand_string_to_string (in, Q_HERE_DOCUMENT);
+	    if (out) {
+		size = strlen (out);
+		if (zwrite (1, out, size) < size)
+		    retcount++;
+	    }
+	    FREE (out);
+	}
+	FREE (in);
+    } else {
+	/* 'cat' processes all arguments, even if there is error. */
+	for ( ; list; list = list->next) {
+	    in = slurp_filename_into_string (list->word->word);
+	    if (in == 0)
+		retcount++;
+	    else {
+		out = expand_string_to_string (in, Q_HERE_DOCUMENT);
+		if (out) {
+		    size = strlen (out);
+		    if (zwrite (1, out, size) < size)
+			retcount++;
+		}
+		FREE (out);
+	    }
+	    FREE (in);
+	}
+    }
+    return (retcount);
+}
+
+
+char *herefile_doc[] = {
+    "Builtin counterpart to here-file operator '<<<<'.  Same as 'cat', except",
+    "the stdin or file is treated as here-document, and parameter expansion,",
+    "command substitution, and arithmetic expansion are preformed.  It returns",
+    "the number of errors encountered.  This is useful for multiple templates.",
+    (char *) NULL
+};
+struct builtin herefile_struct = {
+    "herefile", herefile_builtin, BUILTIN_ENABLED, herefile_doc,
+    "herefile [file... | < file]",
+    (char *)NULL
+};
--- bash-3.2_orig/examples/loadables/william/isnumber.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/isnumber.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,82 @@
+/*******************************************************************************
+ * isnumber { alnum | alpha | ascii | blank | cntrl | digit | graph | lower
+ *	| print | punct | space | upper | xdigit | letter | word }  number...
+ */
+
+#include "loadables.h"
+
+
+int
+isnumber_builtin (list)
+    WORD_LIST *list;
+{
+    int i;
+    char *name;
+
+    if (no_options (list))
+	return (EX_BADUSAGE);
+    list = loptend;		/* skip over possible `--' */
+
+    if (list == 0 || list->next == 0) {		/* 0 or 1 argument */
+	builtin_usage ();
+	return (EX_BADUSAGE);
+    }
+
+    /* 2 or more arguments:  isnumber alpha number... */
+
+    name = list->word->word;  list = list->next;
+
+    for ( ; list; list = list->next) {
+	if (! legal_integer (list->word->word, &i)) {
+	    sh_invalidnum (list->word->word);
+	    return (EXECUTION_FAILURE);
+	}
+	if (STREQ (name, "alnum")) { if (! ISALNUM (i)) return (EXECUTION_FAILURE); }
+	else if (STREQ (name, "alpha")) { if (! ISALPHA (i)) return (EXECUTION_FAILURE); }
+	else if (STREQ (name, "ascii")) { if (! isascii (i)) return (EXECUTION_FAILURE); }
+	else if (STREQ (name, "blank")) { if (! ISBLANK (i)) return (EXECUTION_FAILURE); }
+	else if (STREQ (name, "cntrl")) { if (! ISCNTRL (i)) return (EXECUTION_FAILURE); }
+	else if (STREQ (name, "digit")) { if (! ISDIGIT (i)) return (EXECUTION_FAILURE); }
+	else if (STREQ (name, "graph")) { if (! ISGRAPH (i)) return (EXECUTION_FAILURE); }
+	else if (STREQ (name, "lower")) { if (! ISLOWER (i)) return (EXECUTION_FAILURE); }
+	else if (STREQ (name, "print")) { if (! ISPRINT (i)) return (EXECUTION_FAILURE); }
+	else if (STREQ (name, "punct")) { if (! ISPUNCT (i)) return (EXECUTION_FAILURE); }
+	else if (STREQ (name, "space")) { if (! ISSPACE (i)) return (EXECUTION_FAILURE); }
+	else if (STREQ (name, "upper")) { if (! ISUPPER (i)) return (EXECUTION_FAILURE); }
+	else if (STREQ (name, "xdigit")) { if (! ISXDIGIT (i)) return (EXECUTION_FAILURE); }
+	else if (STREQ (name, "letter")) { if (! ISLETTER (i)) return (EXECUTION_FAILURE); }
+	else if (STREQ (name, "word")) { if (! ISWORD (i)) return (EXECUTION_FAILURE); }
+	else {
+	    sh_invalidoptname (name);
+	    return (EXECUTION_FAILURE);
+	}
+    }
+    return (EXECUTION_SUCCESS);
+}
+
+
+char *isnumber_doc[] = {
+    "Shell version of isupper(3), islower(3), and others in <ctype.h>.  It reads",
+    "numbers and returns success or failure.  Currently supported options are",
+    "    alnum   -- wrapper for isalnum(3)",
+    "    alpha   -- wrapper for isalpha(3)",
+    "    ascii   -- wrapper for isascii(3)",
+    "    blank   -- wrapper for isblank(3)",
+    "    cntrl   -- wrapper for iscntrl(3)",
+    "    digit   -- wrapper for isdigit(3)",
+    "    graph   -- wrapper for isgraph(3)",
+    "    lower   -- wrapper for islower(3)",
+    "    print   -- wrapper for isprint(3)",
+    "    punct   -- wrapper for ispunct(3)",
+    "    space   -- wrapper for isspace(3)",
+    "    upper   -- wrapper for isupper(3)",
+    "    xdigit  -- wrapper for isxdigit(3)",
+    "    letter  -- wrapper for isletter(), aka. isalpha()",
+    "    word    -- wrapper for isletter() || isdigit() || '_'",
+    (char *)NULL
+};
+struct builtin isnumber_struct = {
+    "isnumber", isnumber_builtin, BUILTIN_ENABLED, isnumber_doc,
+    "isnumber { alnum | alpha | ascii | blank | cntrl | digit | graph | lower | print | punct | space | upper | xdigit | letter | word } number...",
+    (char *)NULL
+};
--- bash-3.2_orig/examples/loadables/william/loadables.h	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/loadables.h	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,37 @@
+#include <config.h>
+
+#if defined (HAVE_UNISTD_H)
+#  ifdef _MINIX
+#    include <sys/types.h>
+#  endif
+#  include <unistd.h>
+#endif
+
+#include <stdio.h>		/* puts(), printf(), BUFSIZE, ... */
+
+#include "shell.h"		/* includes lots of headers */
+#include "bashansi.h"		/* string.h, strings.h, stdlib.h */
+#include "common.h"		/* builtin_error(), ... */
+#include "chartypes.h"		/* TOUPPER(), TOLOWER(), ... */
+#include "filecntl.h"		/* open() */
+#include "posixstat.h"		/* open() */
+
+#include "bashgetopt.h"		/* internal_getopt(), ... */
+#include "builtins.h"		/* xxx_doc[], builtin xxx_struct */
+
+#include "subroutines.h"
+
+
+/* Like all_digits(), but return 0 if it's empty or NULL.
+ */
+#define pure_digits(s)		((s) && *(s) && all_digits (s))
+
+int check_sum_digit	__P((char *, char *));
+
+
+#define VCAT_FULLARRAY		0x1
+#define VCAT_PRINT0 		0x2
+
+int vcat_engine		__P((char *, int, int));
+int vset_engine		__P((char *, int, int));
+
--- bash-3.2_orig/examples/loadables/william/maskcard.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/maskcard.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,95 @@
+/*******************************************************************************
+ * Mask card number in-place, with MASK string (repeated if necessary), except
+ * for last N chars.
+ */
+
+#include "loadables.h"
+
+static int mask_card_number	__P((char *, char *, int, int));
+
+
+static int
+mask_card_number (card, mask, firstn, lastn)
+    char *card, *mask;
+    int firstn, lastn;
+{
+    int i, j, size, msize;
+
+    if (card == 0 || *card == 0 || mask == 0 || *mask == 0)
+	return (EXECUTION_FAILURE);
+
+    size = strlen (card);
+    msize = strlen (mask);
+
+    if (firstn < 0 || lastn < 0)
+	return (EXECUTION_FAILURE);
+
+    for (i = firstn, j = 0; i < size - lastn; i++, j++) {
+	if (j >= msize)
+	    j = 0;
+	card[i] = mask[j];
+    }
+    return (EXECUTION_SUCCESS);
+}
+
+
+int
+maskcard_builtin (list)
+    WORD_LIST *list;
+{
+    char *card, *mask;
+    int opt, lastn, firstn;
+
+    firstn = 0;
+    lastn = 4;
+
+    reset_internal_getopt ();
+    while ((opt = internal_getopt (list, "b#e#")) != -1) {
+	switch (opt) {
+	case 'e':
+	    if (! legal_positive_integer (list_optarg, &lastn)) {
+		sh_invalidnum (list_optarg);
+		return (EXECUTION_FAILURE);
+	    }
+	    break;
+	case 'b':
+	    if (! legal_positive_integer (list_optarg, &firstn)) {
+		sh_invalidnum (list_optarg);
+		return (EXECUTION_FAILURE);
+	    }
+	    break;
+	default:
+	    builtin_usage ();
+	    return (EX_BADUSAGE);
+	}
+    }
+    list = loptend;		/* skip over possible `--' */
+
+    if (list_length (list) != 2) {	/* must be 2 arguments */
+	builtin_usage ();
+	return (EX_BADUSAGE);
+    }
+
+    card = list->word->word;  list = list->next;
+    mask = list->word->word;  list = list->next;
+    if (mask_card_number (card, mask, firstn, lastn) == EXECUTION_FAILURE)
+	return (EXECUTION_FAILURE);
+    else {
+	puts (card);
+	return (EXECUTION_SUCCESS);
+    }
+}
+
+
+char *maskcard_doc[] = {
+    "Mask card NUMBER using MASK, repeated if necessary, except for the last 4",
+    "chars by default.  If option -[be] is given, then FIRSTN chars from the",
+    "beginning and LASTN chars from the end will be left unmasked.  Prints the",
+    "result to stdout if successful (0); otherwise, returns failure (1).",
+    (char *)NULL
+};
+struct builtin maskcard_struct = {
+    "maskcard", maskcard_builtin, BUILTIN_ENABLED, maskcard_doc,
+    "maskcard [-b firstn] [-e lastn] number mask",
+    (char *)NULL
+};
--- bash-3.2_orig/examples/loadables/william/match.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/match.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,85 @@
+/*******************************************************************************
+ * Shell version of Awk match():
+ *	match [-23] string regex SUBMATCH
+ * where they return success (0) if string contains regex pattern.
+ *
+ * By default, SUBMATCH contains matching string and its parenthesized groups.
+ * For -2 option, SUBMATCH contains 2 elements, non-matching prefix and the
+ * leftover suffix (ie. before and after the regex).  For -3 option, SUBMATCH
+ * contains 3+ elements, the non-matching prefix, the matching string and
+ * subgroups, and the leftover suffix.
+ *
+ * Shell option 'nocaseglob' applies to regular expression, also.
+ */
+
+#include "loadables.h"
+
+
+#if defined (HAVE_POSIX_REGEXP)
+
+int
+match_builtin (list)
+     WORD_LIST *list;
+{
+    char *string, *regex, *submatch;
+    int opt, regex_flag;
+    SHELL_VAR *var;
+
+    regex_flag = 1;
+
+    reset_internal_getopt ();
+    while ((opt = internal_getopt (list, "s")) != -1) {
+	switch (opt) {
+	case 's':
+	    regex_flag = 0;
+	    break;
+	default:
+	    builtin_usage ();
+	    return (EX_BADUSAGE);
+	}
+    }
+    list = loptend;		/* skip over possible `--' */
+
+    switch (list_length (list)) {
+    case 2:
+        string = list->word->word;	list = list->next;
+        regex = list->word->word;	list = list->next;
+        submatch = (char *)NULL;
+        break;
+    case 3:
+        string = list->word->word;	list = list->next;
+        regex = list->word->word;	list = list->next;
+        submatch = list->word->word;
+        break;
+    default:
+        builtin_usage ();
+        return (EX_BADUSAGE);
+    }
+
+    if (regex_flag)
+        return (regex_match (string, regex, submatch));
+    else
+        return (string_match (string, regex, submatch));
+}
+
+
+char *match_doc[] = {
+    "Return success (0) if STRING contains REGEX pattern.  If SUBMATCH is",
+    "specified, then it will contain prefix before regex match, entire matching",
+    "string (REGEX), any parenthesized groups in regex pattern (group[1],",
+    "group[2], ...), and suffix after regex match.  That is,",
+    "    submatch=( prefix REGEX group[1] group[2] ... group[n] suffix )",
+    "",
+    "If shell option 'nocaseglob' is set, then match is case-insensitive.  With",
+    "-s option, the pattern is treated as fixed string instead of regex, in",
+    "which case SUBMATCH will contain 3 elements, ie.",
+    "    submatch=( prefix REGEX suffix )",
+    (char *)NULL
+};
+struct builtin match_struct = {
+    "match", match_builtin, BUILTIN_ENABLED, match_doc,
+    "match [-s] string regex [submatch]",
+    (char *)NULL
+};
+
+#endif	/* HAVE_POSIX_REGEXP */
--- bash-3.2_orig/examples/loadables/william/multi.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/multi.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,226 @@
+/*******************************************************************************
+ * Read TRS (Tender Retail Systems) Multi response string.
+ *	multi -r msg ANS RCP RCT < file
+ * 
+ * If there is error in the request string, Multi sends back 
+ *	<025>...\0			<-- NAK (^U)
+ * Otherwise, it tries to connect to a bank host.  When the it gets replies or
+ * times out, Multi sends back
+ *	<006>Wait, request sent\0	<-- ACK (^F)
+ *	<002>ANS<002>			<-- STX (^B)
+ *	    string\r\n
+ *	<034>RCP<034>			<-- FS (^\)
+ *	    key:data\r\n
+ *	    ...\r\n
+ *	<034>RCT<034>			<-- FS (^\)
+ *	    receipt\r\n
+ *	    ...\r\n
+ *	<003>				<-- ETX (^C)
+ * where ANS is usually a single line, but RCP and RCT are multi lines.
+ *
+ * Write Multi request string to stdout.  The output is a single string, made up
+ * of fixed-width fields and terminated by CRLF.  The field length and field
+ * data are specified in separate array variables. Eg.
+ *	multi -w length data > file
+ */
+
+#include "loadables.h"
+
+
+#if defined (ARRAY_VARS)
+
+enum trs_response_section {
+    NO_section,
+    MSG_section,
+    ANS_section,
+    RCP_section,
+    RCT_section
+};
+
+static int initialize_sections		__P((char *, char *, char *, char *));
+static int read_multi			__P((WORD_LIST *));
+static int write_multi			__P((WORD_LIST *));
+static void print_fixedstring		__P((int, int, char*));
+
+
+static int
+initialize_sections (msg, ANS, RCP, RCT)
+    char *msg, *ANS, *RCP, *RCT;
+{
+    return (force_name_to_arrayvar (msg, 1) &&
+	    force_name_to_arrayvar (ANS, 1) &&
+	    force_name_to_arrayvar (RCP, 1) &&
+	    force_name_to_arrayvar (RCT, 1));
+}
+
+
+static int
+read_multi (list)
+    WORD_LIST *list;
+{
+    char *msg, *ANS, *RCP, *RCT, *t, *line;
+    WORD_LIST *response, *p;
+    SHELL_VAR *var;
+    enum trs_response_section section;
+
+    if (list_length (list) != 4) {
+	builtin_usage ();
+	return (EX_BADUSAGE);
+    }
+
+    msg = list->word->word;	list = list->next;
+    ANS = list->word->word;	list = list->next;
+    RCP = list->word->word;	list = list->next;
+    RCT = list->word->word;	list = list->next;
+
+    response = slurp_fd_into_list (0, '\n', (int *)NULL);
+    if (response == 0 || ! initialize_sections (msg, ANS, RCP, RCT))
+	return (EXECUTION_FAILURE);
+
+    var = (SHELL_VAR *)NULL;
+    section = NO_section;
+
+    for (p = response; p; p = p->next) {
+	line = strip_CRLF (p->word->word);
+
+	if (*line == '\003') {		/* "end of transaction" */
+	    var = (SHELL_VAR *)NULL;
+	    line += 1;      /* one after \003 */
+	}
+
+	if (*line == '\025' || *line == '\006') {	/* "beginning of transaction" */
+	    initialize_sections (msg, ANS, RCP, RCT);
+	    var = force_name_to_arrayvar (msg, 1);
+	    section = MSG_section;
+	    line += 1;
+	}
+	else if (*line == '\002') {
+	    if (STREQN (line, "\002ANS\002", 5)) {
+		var = force_name_to_arrayvar (ANS, 1);
+		section = ANS_section;
+		line += 5;
+	    } else {
+		var = (SHELL_VAR *)NULL;
+	    }
+	}
+	else if (*line == '\034') {
+	    if (STREQN (line, "\034RCP\034", 5)) {
+		var = force_name_to_arrayvar (RCP, 1);
+		section = RCP_section;
+		line += 5;
+	    } else if (STREQN (line, "\034RCT\034", 5)) {
+		var = force_name_to_arrayvar (RCT, 1);
+		section = RCT_section;
+		line += 5;
+	    } else {
+		var = (SHELL_VAR *)NULL;
+	    }
+	}
+
+	if (var) {
+#if 0
+	    if (section == RCP_section) {
+		t = strchr (line, ':');
+		if (t)
+		    *t++ = '\0';
+		arrayvar_append (var, line);
+		arrayvar_append (var, (t? t: ""));
+	    } else
+#endif
+		arrayvar_append (var, line);
+	}
+    }
+
+    dispose_words (response);
+    return (section == NO_section)? EXECUTION_FAILURE: EXECUTION_SUCCESS;
+}
+
+
+static int
+write_multi (list)
+     WORD_LIST *list;
+{
+    int retval;
+
+    list = make_word_list (make_bare_word ("-wL"), list);
+
+    retval = fixedstring_builtin (list);
+    if (retval == EXECUTION_SUCCESS) {
+	putchar ('\r');
+	putchar ('\n');		/* terminate with CRLF */
+	fflush (stdout);
+    }
+
+    list->next = (WORD_LIST *)NULL;
+    dispose_words (list);
+    return (retval);
+}
+
+
+int
+multi_builtin (list)
+     WORD_LIST *list;
+{
+    int opt, rw_flag;
+
+    rw_flag = 0;
+
+    reset_internal_getopt ();
+    while ((opt = internal_getopt (list, "rw")) != -1) {
+	switch (opt) {
+	case 'r':
+	case 'w':
+	    rw_flag = opt;	/* -[rw] is mandatory */
+	    break;
+	default:
+	    builtin_usage ();
+	    return (EX_BADUSAGE);
+	}
+    }
+    list = loptend;		/* skip over possible `--' */
+
+    switch (rw_flag) {
+    case 'r':
+	return (read_multi (list));
+    case 'w':
+	return (write_multi (list));
+    default:
+	builtin_usage ();
+	return (EX_BADUSAGE);
+    }
+}
+
+
+char *multi_doc[] = {
+    "Read (-r) Multi response string from stdin,",
+    "    <025>...\\0",
+    "or",
+    "    <006>...\\0",
+    "    <002>ANS<002>",
+    "        string\\r\\n",
+    "    <034>RCP<034>",
+    "        key:data\\r\\n",
+    "        ...\\r\\n",
+    "    <034>RCT<034>",
+    "        receipt\\r\\n",
+    "        ...\\r\\n",
+    "    <003>",
+    "and extract the lines in ANS, RCP, and RCT sections into corresponding",
+    "array variables.  One line per array element, and without the trailing",
+    "\\r\\n.  If there are multiple records, then the last record will be",
+    "extracted.",
+    "",
+    "Write (-w) Multi request string to stdout.  The output is concatenated",
+    "fixed-width strings, ending in \\r\\n.  The LENGTH and DATA of strings are",
+    "specified in array variables on the command line.  It's equivalent to",
+    "    fixedstring -wL length data",
+    "    printf '\\r\\n'",
+    (char *)NULL
+};
+struct builtin multi_struct = {
+    "multi", multi_builtin, BUILTIN_ENABLED, multi_doc,
+    "multi {-r msg ANS RCP RCT < file | -w length data > file}",
+    (char *)NULL
+};
+
+#endif	/* ARRAY_VARS */
--- bash-3.2_orig/examples/loadables/william/mysql.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/mysql.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,152 @@
+/*******************************************************************************
+ * Interface to MySQL-4.0.15a.
+ */
+
+#include "loadables.h"
+
+
+#if defined (HAVE_MYSQL)
+
+#include <mysql/mysql.h>
+
+int
+Msql_builtin (list)
+    WORD_LIST *list;
+{
+    int opt, out, i, j;
+    SHELL_VAR *var;
+    char *host, *port, *dbname, *user, *password, *text, *t;
+
+    MYSQL mysql;
+    MYSQL_RES *result;
+    my_ulonglong NR;
+    unsigned int NF;
+    MYSQL_ROW row;
+    unsigned long *length;
+
+    var = (SHELL_VAR *)NULL;
+    host = port = dbname = user = password = (char *)NULL;
+
+    reset_internal_getopt ();
+    while ((opt = internal_getopt (list, "a:h:p:d:u:P:")) != -1) {
+	switch (opt) {
+#if defined (ARRAY_VARS)
+	case 'a':
+	    var = force_name_to_arrayvar (list_optarg, 1);
+	    if (var == 0)
+		return (EXECUTION_FAILURE);
+	    break;
+#endif
+        case 'h':
+            host = list_optarg;
+            break;
+        case 'p':
+            port = list_optarg;
+            break;
+        case 'd':
+            dbname = list_optarg;
+            break;
+        case 'u':
+            user = list_optarg;
+            break;
+        case 'P':
+            password = list_optarg;
+            break;
+	default:
+	    builtin_usage ();
+	    return (EX_BADUSAGE);
+	}
+    }
+    list = loptend;		/* skip over possible `--' */
+
+    if (list == 0) {	        /* 0 argument */
+	builtin_usage ();
+	return (EX_BADUSAGE);
+    }
+
+    unbind_variable ("NF");
+    unbind_variable ("NR");
+
+    /* 1 or more arguments: Msql [-option] SQL... */
+
+    if (mysql_init (&mysql) == 0) {
+	builtin_error ("cannot initialize");
+	return (EXECUTION_FAILURE);
+    } 
+    if (mysql_real_connect (&mysql, 
+	    host, user, password, dbname,	/* NULL means default value */
+	    (unsigned int)atoi (port? port: "0"),	/* 0 means default port */
+	    (char *)NULL,	/* unix socket */
+	    (unsigned long)0 /* client flag */) == 0) {
+	builtin_error ("cannot connect to server: %s", mysql_error(&mysql));
+	mysql_close (&mysql);
+	return (EXECUTION_FAILURE);
+    }
+
+    out = EXECUTION_SUCCESS;
+    for ( ; list && out == EXECUTION_SUCCESS; list = list->next) {
+	text = list->word->word;
+	if (mysql_query (&mysql, text)) {
+	    out = EXECUTION_FAILURE;
+	    builtin_error ("query failed: %s", mysql_error(&mysql));
+	}
+	else if (result = mysql_store_result (&mysql)) {
+	    NR = mysql_num_rows (result);	bind_var_to_int ("NR", NR);
+	    NF = mysql_num_fields (result);	bind_var_to_int ("NF", NF);
+	    row = mysql_fetch_row (result);
+	    length = mysql_fetch_lengths (result);
+	    for (i = 0; i < NR; i++) {
+		for (j = 0; j < NF; j++) {
+		    t = row[j];		/* not a copy.  Don't free it */
+		    if (t && strlen (t) != length[j])
+			t = "(binary)";
+		    if (var == 0) {
+			printf ("%s", t);
+			putchar ((j < NF-1) ? '\t' : '\n');
+		    }
+#if defined (ARRAY_VARS)
+		    else
+			arrayvar_append (var, t);
+#endif
+		}
+	    }
+	    mysql_free_result (result);
+	}
+	else if (mysql_field_count (&mysql)) {		/* expected something */
+	    out = EXECUTION_FAILURE;
+	    builtin_error ("result failed: %s", mysql_error(&mysql));
+	}
+    }
+
+    mysql_close (&mysql);
+    return (out);
+}
+
+
+char *Msql_doc[] = {
+    "Interface to MySQL-4.0.15a (www.mysql.com).  After connecting to database,",
+    "arguments are feed to SQL engine sequentially.  It returns 1 immediately on",
+    "any error.  If all arguments are processed without error, then returns",
+    "success (0).  Each 'Msql' command is complete, in that it opens and closes",
+    "connection with the database.",
+    "",
+    "    Msql [-hpduP ...] SQL...",
+    "        Print query result (if any) to stdout.  Fields are separated by \\t,",
+    "        one row per line.",
+    "",
+    "    Msql -a array [-hpduP ...] SQL...",
+    "        Save query result (if any) into array.  Fields are appended",
+    "        sequentially, row by row; and, they are culumative.",
+    "",
+    "Options -[hpduP] are optional.  Default value will be used for missing",
+    "parameters.  For convenience, shell variables NF and NR are set from the",
+    "last query result.",
+    (char *)NULL
+};
+struct builtin Msql_struct = {
+    "Msql", Msql_builtin, BUILTIN_ENABLED, Msql_doc,
+    "Msql [-a array] [-h host -p port -d dbname -u user -P password ] SQL...",
+    (char *)NULL
+};
+
+#endif	/* HAVE_MYSQL */
--- bash-3.2_orig/examples/loadables/william/postgresql.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/postgresql.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,162 @@
+/*******************************************************************************
+ * Interface to PostgreSQL-7.4.3.
+ */
+
+#include "loadables.h"
+
+
+#if defined (HAVE_POSTGRESQL)
+
+#include <pgsql/libpq-fe.h>
+
+int
+Psql_builtin (list)
+    WORD_LIST *list;
+{
+    int opt, out, NR, NF, i, j, size;
+    SHELL_VAR *var;
+    char *host, *port, *dbname, *user, *password, *conninfo, *text, *t;
+    PGconn     *conn;
+    PGresult   *res;
+
+    var = (SHELL_VAR *)NULL;
+    host = port = dbname = user = password = (char *)NULL;
+    size = 0;
+
+    reset_internal_getopt ();
+    while ((opt = internal_getopt (list, "a:h:p:d:u:P:")) != -1) {
+	switch (opt) {
+#if defined (ARRAY_VARS)
+	case 'a':
+	    var = force_name_to_arrayvar (list_optarg, 1);
+	    if (var == 0)
+		return (EXECUTION_FAILURE);
+	    break;
+#endif
+        case 'h':
+            host = list_optarg;
+            size += strlen (list_optarg) + 10;
+            break;
+        case 'p':
+            port = list_optarg;
+            size += strlen (list_optarg) + 10;
+            break;
+        case 'd':
+            dbname = list_optarg;
+            size += strlen (list_optarg) + 10;
+            break;
+        case 'u':
+            user = list_optarg;
+            size += strlen (list_optarg) + 10;	
+            break;
+        case 'P':
+            password = list_optarg;
+            size += strlen (list_optarg) + 10;	/* 'password= ' is the max */
+            break;
+	default:
+	    builtin_usage ();
+	    return (EX_BADUSAGE);
+	}
+    }
+    list = loptend;		/* skip over possible `--' */
+
+    if (list == 0) {	        /* 0 argument */
+	builtin_usage ();
+	return (EX_BADUSAGE);
+    }
+
+    unbind_variable ("NF");
+    unbind_variable ("NR");
+
+    /* 1 or more arguments: Psql [-option] SQL... */
+
+    conninfo = (char *)xmalloc (size + 1);
+    *conninfo = '\0';
+    if (host)
+	sprintf (conninfo + strlen(conninfo), "host=%s ", host);
+    if (port)
+	sprintf (conninfo + strlen(conninfo), "port=%s ", port);
+    if (dbname)
+	sprintf (conninfo + strlen(conninfo), "dbname=%s ", dbname);
+    if (user)
+	sprintf (conninfo + strlen(conninfo), "user=%s ", user);
+    if (password)
+	sprintf (conninfo + strlen(conninfo), "password=%s ", password);
+
+    conn = PQconnectdb(conninfo);
+    if (PQstatus(conn) != CONNECTION_OK) {
+	builtin_error ("cannot connect to `%s': %s", conninfo, PQerrorMessage(conn));
+	PQfinish(conn);
+	return (EXECUTION_FAILURE);
+    }
+
+    out = EXECUTION_SUCCESS;
+    for ( ; list && out == EXECUTION_SUCCESS; list = list->next) {
+	text = list->word->word;
+	res = PQexec(conn, text);
+
+	switch (PQresultStatus(res)) {
+	case PGRES_EMPTY_QUERY:
+	case PGRES_COMMAND_OK:
+	    break;
+	case PGRES_TUPLES_OK:
+	    NR = PQntuples (res);	bind_var_to_int ("NR", NR);
+	    NF = PQnfields (res);	bind_var_to_int ("NF", NF);
+	    for (i = 0; i < NR; i++) {
+		for (j = 0; j < NF; j++) {
+		    t = PQgetvalue(res, i, j);	/* not a copy.  Don't free it */
+		    if (PQfformat (res, j))
+			t = "(binary)";
+		    if (var == 0) {
+			printf ("%s", t);
+			putchar ((j < NF-1) ? '\t' : '\n');
+		    }
+#if defined (ARRAY_VARS)
+		    else
+			arrayvar_append (var, t);
+#endif
+		}
+	    }
+	    break;
+	default:
+	    out = EXECUTION_FAILURE;
+	    builtin_error ("exec failed: %s", PQresultErrorMessage(res));
+	    break;
+	}
+	PQclear(res);
+    }
+
+    PQfinish(conn);
+    return (out);
+}
+
+
+char *Psql_doc[] = {
+    "Interface to PostgreSQL-7.4.3/8.1.4 (www.postgresql.org).  After connecting",
+    "to database, arguments are feed to SQL engine sequentially.  It returns 1",
+    "immediately on any error.  If all arguments are processed without error,",
+    "then returns success (0).  Each 'Psql' command is complete, in that it",
+    "opens and closes connection with the database.",
+    "",
+    "    Psql [-hpduP ...] SQL...",
+    "        Print query result (if any) to stdout.  Fields are separated by \\t,",
+    "        one row per line.",
+    "",
+    "    Psql -a array [-hpduP ...] SQL...",
+    "        Save query result (if any) into array.  Fields are appended",
+    "        sequentially, row by row; and, they are cumulative.",
+    "",
+    "Options -[hpduP] are the same as the content of ~/.pgpass, ie.",
+    "    host:port:dbname:user:password",
+    "and they are optional.  Default value will be used for missing parameters.",
+    "For convenience, shell variables NF and NR are set from the last query",
+    "result.",
+    (char *)NULL
+};
+struct builtin Psql_struct = {
+    "Psql", Psql_builtin, BUILTIN_ENABLED, Psql_doc,
+    "Psql [-a array] [-h host -p port -d dbname -u user -P password ] SQL...",
+    (char *)NULL
+};
+
+#endif	/* HAVE_POSTGRESQL */
--- bash-3.2_orig/examples/loadables/william/protobase.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/protobase.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,119 @@
+/*******************************************************************************
+ * Read/write SDC (Southern DataComm) ProtoBase IN/OUT files.
+ *	protobase -r name < file
+ *	protobase -w name > file
+ * 
+ * Protobase API file is CSV-like text file, 2 fields per line separated by
+ * comma, ie.
+ *	nnnn,data\n
+ * where 'nnnn' is 1-4 digits (array index), and 'data' is string (array value).
+ *
+ * If there are more than one transaction, then they are separated by <RS> char
+ * (036, 30, 0x1E).
+ */
+
+#include "loadables.h"
+
+
+#if defined (ARRAY_VARS)
+
+int
+protobase_builtin (list)
+    WORD_LIST *list;
+{
+    char *name, *line, *t;
+    int opt, rw_flag, i;
+    WORD_LIST *p, *plist;
+    SHELL_VAR *var;
+    ARRAY *a;
+    ARRAY_ELEMENT *ae;
+
+    rw_flag = 0;
+
+    reset_internal_getopt ();
+    while ((opt = internal_getopt (list, "rw")) != -1) {
+	switch (opt) {
+	case 'r':
+	case 'w':
+	    rw_flag = opt;	/* -[rw] is mandatory */
+	    break;
+	default:
+	    builtin_usage ();
+	    return (EX_BADUSAGE);
+	}
+    }
+    list = loptend;		/* skip over possible `--' */
+
+    if (list == 0 || list->next || rw_flag == 0) {	/* -[rw] option and NAME are mandatory */
+	builtin_usage ();
+	return (EX_BADUSAGE);
+    }
+
+    switch (rw_flag) {
+    case 'r':
+	name = list->word->word;
+	var = force_name_to_arrayvar (name, 1);
+	if (var == 0)
+	    return (EXECUTION_FAILURE);
+
+	plist = slurp_fd_into_list (0, '\n', (int *)NULL);
+	for (p = plist; p; p = p->next) {
+	    line = p->word->word;
+	    t = strchr (line, '\036' /* RS */);
+	    if (t) {		/* prepare for new transaction */
+		array_flush (array_cell (var));
+		line = t + 1;	/* one after \036 */
+	    }
+
+	    t = strchr (line, ',');
+	    if (t) {
+		*t++ = '\0';
+		if (legal_positive_integer (line, &i) && i <= 9999)
+		    arrayvar_insert (var, i, t);
+		else
+		    builtin_error ("`%s': skipping illegal field number", line);
+	    }
+	}
+	dispose_words (plist);
+	break;
+
+    case 'w':
+	name = list->word->word;
+	var = name_to_arrayvar (name, 0);
+	if (var == 0)
+	    return (EXECUTION_FAILURE);
+
+	a = array_cell (var);
+	for (ae = element_forw (a->head); ae != a->head; ae = element_forw (ae)) {
+	    i = element_index (ae);
+	    if (i >= 0 && i <= 9999)
+		printf ("%d,%s\n", i, element_value (ae));
+	    else
+		builtin_error ("`%d': skipping illegal field number", i);
+	}
+	fflush (stdout);
+	break;
+    }
+
+    return (EXECUTION_SUCCESS);
+}
+
+
+char *protobase_doc[] = {
+    "Read (-r) or write (-w) Protobase API file to/from array variable.",
+    "Protobase API file is CSV-like text file, 2 fields per line separated by",
+    "comma, ie.",
+    "    nnnn,data\\n",
+    "where 'nnnn' can be 1-4 digits (array index), and 'data' is string (array",
+    "value).  Lines with invalid index are ignored when reading or writing.",
+    "Multiple transactions are separated by <036> char (RS), in which case, only",
+    "the last transaction will be extracted.",
+    (char *)NULL
+};
+struct builtin protobase_struct = {
+    "protobase", protobase_builtin, BUILTIN_ENABLED, protobase_doc,
+    "protobase {-r name < file | -w name > file}",
+    (char *)NULL
+};
+
+#endif	/* ARRAY_VARS */
--- bash-3.2_orig/examples/loadables/william/rpn.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/rpn.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,1222 @@
+/*******************************************************************************
+ * Simple RPN calculator, modelled after HP-42S calculator.
+ */
+
+#include "loadables.h"
+#include <math.h>
+
+
+#define M_1_SQRT2	M_SQRT1_2	/* 1/sqrt(2),  I don't know why they did that */
+
+#define swap(a,b)	do { t = a; a = b; b = t; } while (0)
+
+static int precision = 6;
+static int format = 'f';
+static int maxcount = 1000;
+
+static double X, Y, Z, T;
+static double r0, r1, r2, r3, r4, r5, r6, r7, r8, r9;
+static double Sx, Sy, Sxx, Syy, Sxy, N, A, B, C, D;
+static double a[9], b[3];
+static WORD_LIST *func_list, *fd_list;
+static double day, hour, minute, second;
+
+
+static double pop		__P((void));
+static void push		__P((double));
+static int bind_or_print	__P((char *, double));
+static int process_token	__P((char *));
+static int subroutine		__P((WORD_LIST *));
+
+
+static double
+pop ()
+{
+    double x;
+    
+    x = X; X = Y; Y = Z; Z = T;
+    return (x);
+}
+
+
+static void
+push (x)
+    double x;
+{
+    T = Z; Z = Y; Y = X; X = x;
+}
+
+
+/* Returns 
+ *	EXECUTION_SUCCESS (0)
+ *	EXECUTION_FAILURE (1)
+ */
+static int
+bind_or_print (vname, x)
+    char *vname;
+    double x;
+{
+    char buf[80], *fmt;
+
+    switch (format) {
+    case 'f': fmt = "%.*f"; break;
+    case 'e': fmt = "%.*e"; break;
+    case 'g': fmt = "%.*g"; break;
+    }
+    snprintf (buf, 80, fmt, precision, x);
+    buf[79] = '\0';	/* just in case */
+
+    if (vname && *vname) {
+	if (bind_variable_if_legal (vname, buf) == 0) {
+	    builtin_error ("cannot assign to `%s' variable", vname);
+	    return (EXECUTION_FAILURE);
+	}
+    } else
+	puts (buf);
+
+    return (EXECUTION_SUCCESS);
+}
+
+
+/* Returns
+ *	EXECUTION_SUCCESS (0)
+ *	EXECUTION_FAILURE (1)
+ */
+static int 
+process_token (token)
+    char *token;
+{
+    int n, size, end;
+    double x, y, z, t;
+
+    size = strlen (token);
+    end = 0;
+
+    /* Initialization and internal registers
+    */
+    if (STREQ (token, "clear")) {
+	X = Y = Z = T = 0;
+    }
+    else if (STREQ (token, "clearall")) {
+	X = Y = Z = T = 0;
+	r0 = r1 = r2 = r3 = r4 = r5 = r6 = r7 = r8 = r9 = 0;
+    }
+    else if (STREQ (token, "sto_y")) {	/* sto_[yzt] */
+	Y = X;
+    }
+    else if (STREQ (token, "sto_z")) {
+	Z = X;
+    }
+    else if (STREQ (token, "sto_t")) {
+	T = X;
+    }
+    else if (STREQ (token, "sto_0")) {	/* sto_[0-9] */
+	r0 = X;
+    }
+    else if (STREQ (token, "sto_1")) {
+	r1 = X;
+    }
+    else if (STREQ (token, "sto_2")) {
+	r2 = X;
+    }
+    else if (STREQ (token, "sto_3")) {
+	r3 = X;
+    }
+    else if (STREQ (token, "sto_4")) {
+	r4 = X;
+    }
+    else if (STREQ (token, "sto_5")) {
+	r5 = X;
+    }
+    else if (STREQ (token, "sto_6")) {
+	r6 = X;
+    }
+    else if (STREQ (token, "sto_7")) {
+	r7 = X;
+    }
+    else if (STREQ (token, "sto_8")) {
+	r8 = X;
+    }
+    else if (STREQ (token, "sto_9")) {
+	r9 = X;
+    }
+    else if (STREQ (token, "rcl_y")) {	/* rcl_[yzt] */
+	push (Y);
+    }
+    else if (STREQ (token, "rcl_z")) {
+	push (Z);
+    }
+    else if (STREQ (token, "rcl_t")) {
+	push (T);
+    }
+    else if (STREQ (token, "rcl_0")) {	/* rcl_[0-9] */
+	push (r0);
+    }
+    else if (STREQ (token, "rcl_1")) {
+	push (r1);
+    }
+    else if (STREQ (token, "rcl_2")) {
+	push (r2);
+    }
+    else if (STREQ (token, "rcl_3")) {
+	push (r3);
+    }
+    else if (STREQ (token, "rcl_4")) {
+	push (r4);
+    }
+    else if (STREQ (token, "rcl_5")) {
+	push (r5);
+    }
+    else if (STREQ (token, "rcl_6")) {
+	push (r6);
+    }
+    else if (STREQ (token, "rcl_7")) {
+	push (r7);
+    }
+    else if (STREQ (token, "rcl_8")) {
+	push (r8);
+    }
+    else if (STREQ (token, "rcl_9")) {
+	push (r9);
+    }
+
+    /* Stack manipulations
+    */
+    else if (STREQ (token, "x<>y") || STREQ (token, "swap")) {
+	swap (X, Y);
+    }
+    else if (STREQ (token, "x<>z") || STREQ (token, "swap_z")) {
+	swap (X, Z);
+    }
+    else if (STREQ (token, "x<>t") || STREQ (token, "swap_t")) {
+	swap (X, T);
+    }
+    else if (STREQ (token, "drop")) {
+	pop();
+    }
+    else if (STREQ (token, "dup")) {
+	push (X);
+    }
+    else if (STREQ (token, "fmin")) {
+	x = pop();
+	y = pop();
+	push (fmin (y, x));
+    }
+    else if (STREQ (token, "fmax")) {
+	x = pop();
+	y = pop();
+	push (fmax (y, x));
+    }
+
+    /* sign/number conversion
+    */
+    else if (STREQ (token, "+/-")) {
+	X = -X;
+    }
+    else if (STREQ (token, "sign")) {
+	if (X < 0)
+	    X = -1;
+	else if (X > 0)
+	    X = 1;
+	else
+	    X = 0;
+    }
+    else if (STREQ (token, "|x|") || STREQ (token, "fabs")) {
+	X = fabs (X);
+    }
+    else if (STREQ (token, "floor")) {
+	X = floor (X);
+    }
+    else if (STREQ (token, "ceil")) {
+	X = ceil (X);
+    }
+    else if (STREQ (token, "trunc")) {
+	X = trunc (X);
+    }
+    else if (STREQ (token, "round")) {
+	X = round (X);
+    }
+    else if (STREQ (token, "rint")) {
+	X = rint (X);
+    }
+    else if (STREQ (token, "fmod")) {
+	x = pop();
+	y = pop();
+	push (fmod (y, x));
+    }
+    else if (STREQ (token, "modf")) {
+	x = pop();
+	x = modf (x, &y);
+	push (y);
+	push (x);
+    }
+
+    /* DHMS.sss format
+     */
+    else if (STREQ (token, "clearhms")) {
+	day = hour = minute = second = 0;
+    }
+    else if (STREQ (token, "hms++")) {
+	second += X; n = floor (second/60); second -= n * 60; minute += n;
+	minute += Y; n = floor (minute/60); minute -= n * 60; hour += n;
+	hour += Z;   n = floor (hour/24);   hour -= n * 24;   day += n;
+        day += T;
+	T = day;
+	Z = hour;
+	Y = minute;
+	X = second;
+    }
+    else if (STREQ (token, "hms--")) {
+	second -= X; n = floor (second/60); second -= n * 60; minute += n;
+	minute -= Y; n = floor (minute/60); minute -= n * 60; hour += n;
+	hour -= Z;   n = floor (hour/24);   hour -= n * 24;   day += n;
+        day -= T;
+	T = day;
+	Z = hour;
+	Y = minute;
+	X = second;
+    }
+
+    /* Basic arithmetics
+    */
+    else if (STREQ (token, "-")) {
+	x = pop();
+	y = pop();
+	push (y - x);
+    }
+    else if (STREQ (token, "+")) {
+	x = pop();
+	y = pop();
+	push (y + x);
+    }
+    else if (STREQ (token, "*") || STREQ (token, "x")) {
+	x = pop();
+	y = pop();
+	push (y * x);
+    }
+    else if (STREQ (token, "/")) {
+	x = pop();
+	y = pop();
+	push (y / x);
+    }
+    else if (STREQ (token, "%")) {
+	X = Y * X/100;
+    }
+    else if (STREQ (token, "%ch")) {
+	X = 100 * (X - Y)/Y;
+    }
+    else if (STREQ (token, "x++")) {
+	X++;
+    }
+    else if (STREQ (token, "x--")) {
+	X--;
+    }
+    else if (STREQ (token, "y++")) {
+	Y++;
+    }
+    else if (STREQ (token, "y--")) {
+	Y--;
+    }
+    else if (STREQ (token, "1-x")) {
+	X = 1 - X;
+    }
+    else if (STREQ (token, "1-y")) {
+	Y = 1 - Y;
+    }
+
+    /* Power functions
+    */
+    else if (STREQ (token, "1/x")) {
+	X = 1/X;
+    }
+    else if (STREQ (token, "x^2") || STREQ (token, "sqr")) {
+	X = X * X;
+    }
+    else if (STREQ (token, "x^3") || STREQ (token, "cub")) {
+	X = X * X * X;
+    }
+    else if (STREQ (token, "sqrt")) {
+	X = sqrt (X);
+    }
+    else if (STREQ (token, "cbrt")) {
+	X = cbrt (X);
+    }
+    else if (STREQ (token, "hypot")) {
+	x = pop();
+	y = pop();
+	push (hypot (y, x));
+    }
+    else if (STREQ (token, "y^x") || STREQ (token, "pow")) {
+	x = pop();
+	y = pop();
+	push (pow (y, x));
+    }
+
+    /* Exponential and logarithmic functions
+    */
+    else if (STREQ (token, "e^x") || STREQ (token, "exp")) {
+	X = exp (X);
+    }
+    else if (STREQ (token, "10^x") || STREQ (token, "exp10")) {
+	X = exp10 (X);
+    }
+    else if (STREQ (token, "2^x") || STREQ (token, "exp2")) {
+	X = exp2 (X);
+    }
+    else if (STREQ (token, "ln") || STREQ (token, "log")) {
+	X = log (X);
+    }
+    else if (STREQ (token, "log10")) {
+	X = log10 (X);
+    }
+    else if (STREQ (token, "log2")) {
+	X = log2 (X);
+    }
+    else if (STREQ (token, "e^x-1")) {
+	X = expm1 (X);
+    }
+    else if (STREQ (token, "ln(1+x)")) {
+	X = log1p (X);
+    }
+
+    /* Trigonometric functions
+    */
+    else if (STREQ (token, "rad->deg")) {
+	X = 180 * X/M_PI;
+    }
+    else if (STREQ (token, "deg->rad")) {
+	X = M_PI * X/180;
+    }
+    else if (STREQ (token, "rect->polar")) {
+	double r, w;
+
+	x = pop();
+	y = pop();
+	r = hypot (y, x);
+	w = atan2 (y, x);
+	push (w);
+	push (r);
+    }
+    else if (STREQ (token, "polar->rect")) {
+	double r, w;
+
+	r = pop();
+	w = pop();
+	x = r * cos (w);
+	y = r * sin (w);
+	push (y);
+	push (x);
+    }
+    else if (STREQ (token, "sin")) {
+	X = sin (X);
+    }
+    else if (STREQ (token, "cos")) {
+	X = cos (X);
+    }
+    else if (STREQ (token, "tan")) {
+	X = tan (X);
+    }
+    else if (STREQ (token, "asin")) {
+	X = asin (X);
+    }
+    else if (STREQ (token, "acos")) {
+	X = acos (X);
+    }
+    else if (STREQ (token, "atan")) {
+	X = atan (X);
+    }
+    else if (STREQ (token, "atan2")) {
+	x = pop();
+	y = pop();
+	push (atan2 (y, x));
+    }
+
+    /* Hyperbolic functions
+    */
+    else if (STREQ (token, "sinh")) {
+	X = sinh (X);
+    }
+    else if (STREQ (token, "cosh")) {
+	X = cosh (X);
+    }
+    else if (STREQ (token, "tanh")) {
+	X = tanh (X);
+    }
+    else if (STREQ (token, "asinh")) {
+	X = asinh (X);
+    }
+    else if (STREQ (token, "acosh")) {
+	X = acosh (X);
+    }
+    else if (STREQ (token, "atanh")) {
+	X = atanh (X);
+    }
+
+    /* Bessel functions
+    */
+    else if (STREQ (token, "j0")) {
+	X = j0 (X);
+    }
+    else if (STREQ (token, "j1")) {
+	X = j1 (X);
+    }
+    else if (sscanf (token, "j%d%n", &n, &end) == 1 && size == end) {
+	X = jn (n, X);
+    }
+    else if (STREQ (token, "y0")) {
+	X = y0 (X);
+    }
+    else if (STREQ (token, "y1")) {
+	X = y1 (X);
+    }
+    else if (sscanf (token, "y%d%n", &n, &end) == 1 && size == end) {
+	X = yn (n, X);
+    }
+
+    /* Error and gamma functions
+    */
+    else if (STREQ (token, "erf")) {
+	X = erf (X);
+    }
+    else if (STREQ (token, "erfc")) {
+	X = erfc (X);
+    }
+    else if (STREQ (token, "lgamma")) {
+	X = lgamma (X);
+    }
+    else if (STREQ (token, "tgamma")) {
+	X = tgamma (X);
+    }
+
+    /* Output
+    */
+    else if (STREQ (token, "=")) {
+	bind_or_print ((char *)NULL, T);
+	bind_or_print ((char *)NULL, Z);
+	bind_or_print ((char *)NULL, Y);
+	bind_or_print ((char *)NULL, X);
+    }
+    else if (size >= 2 && STREQ (token + size - 2, "=x")) {
+	token[size - 2] = '\0';
+	bind_or_print (token, X);
+    }
+    else if (size >= 2 && STREQ (token + size - 2, "=y")) {
+	token[size - 2] = '\0';
+	bind_or_print (token, Y);
+    }
+    else if (size >= 2 && STREQ (token + size - 2, "=z")) {
+	token[size - 2] = '\0';
+	bind_or_print (token, Z);
+    }
+    else if (size >= 2 && STREQ (token + size - 2, "=t")) {
+	token[size - 2] = '\0';
+	bind_or_print (token, T);
+    }
+
+    /* Constants
+    */
+    else if (STREQ (token, "pi")) {
+	push (M_PI);
+    }
+    else if (STREQ (token, "pi/2")) {
+	push (M_PI_2);
+    }
+    else if (STREQ (token, "pi/4")) {
+	push (M_PI_4);
+    }
+    else if (STREQ (token, "1/pi")) {
+	push (M_1_PI);
+    }
+    else if (STREQ (token, "2/pi")) {
+	push (M_2_PI);
+    }
+    else if (STREQ (token, "2/sqrt(pi)")) {
+	push (M_2_SQRTPI);
+    }
+    else if (STREQ (token, "sqrt(2)")) {
+	push (M_SQRT2);
+    }
+    else if (STREQ (token, "1/sqrt(2)")) {
+	push (M_1_SQRT2);
+    }
+    else if (STREQ (token, "e")) {
+	push (M_E);
+    }
+    else if (STREQ (token, "ln(2)")) {
+	push (M_LN2);
+    }
+    else if (STREQ (token, "ln(10)")) {
+	push (M_LN10);
+    }
+    else if (STREQ (token, "log2(e)")) {
+	push (M_LOG2E);
+    }
+    else if (STREQ (token, "log10(e)")) {
+	push (M_LOG10E);
+    }
+
+    /* Input
+     */
+    else if (sscanf (token, "x=%lf%n", &x, &end) == 1 && size == end) {
+	X = x;
+    }
+    else if (sscanf (token, "y=%lf%n", &x, &end) == 1 && size == end) {
+	Y = x;
+    }
+    else if (sscanf (token, "z=%lf%n", &x, &end) == 1 && size == end) {
+	Z = x;
+    }
+    else if (sscanf (token, "t=%lf%n", &x, &end) == 1 && size == end) {
+	T = x;
+    }
+    else if (sscanf (token, "%lf%n", &x, &end) == 1 && size == end) {
+	push (x);		/* number should come after '-' and '+' */
+    }
+
+    /* Statistic:
+     *      Sx = \sum_i^N x_i,	Sxx = \sum_i^N x_i^2,
+     *      Sy = \sum_i^N y_i,	Syy = \sum_i^N y_i^2
+     *      Sxy = \sum_i^N x_i y_i
+     */
+    else if (STREQ (token, "clearstat")) {
+	Sx = Sy = Sxx = Syy = Sxy = N = 0;
+    }
+    else if (STREQ (token, "stat++")) {
+	N += 1;
+	Sx += X;
+	Sy += Y;
+	Sxx += X * X;
+	Syy += Y * Y;
+	Sxy += X * Y;
+    }
+    else if (STREQ (token, "stat--")) {
+	N -= 1;
+	Sx -= X;
+	Sy -= Y;
+	Sxx -= X * X;
+	Syy -= Y * Y;
+	Sxy -= X * Y;
+    }
+    else if (STREQ (token, "N")) {
+	push (N);
+    }
+    else if (STREQ (token, "Sx")) {
+	push (Sx);
+    }
+    else if (STREQ (token, "Sy")) {
+	push (Sy);
+    }
+    else if (STREQ (token, "Sxx")) {
+	push (Sxx);
+    }
+    else if (STREQ (token, "Syy")) {
+	push (Syy);
+    }
+    else if (STREQ (token, "Sxy")) {
+	push (Sxy);
+    }
+    else if (STREQ (token, "mean")) {
+	push (Sy/N);
+	push (Sx/N);
+    }
+    else if (STREQ (token, "wmean")) {
+	push (Sxy/Sy);
+    }
+    else if (STREQ (token, "stddev")) {
+	double det;
+
+	det = Syy * N - Sy * Sy;
+	y = sqrt (det/(N * (N-1)));
+	push (y);
+	det = Sxx * N - Sx * Sx;
+	x = sqrt (det/(N * (N-1)));
+	push (x);
+    }
+
+    /* Linear regression: y=Ax+B
+     *	    Sxx A + Sx B = Sxy
+     *	     Sx A +  N B = Sy
+     * where 
+     *      A = (Sxy N - Sy Sx)/det
+     *      B = (Sxx Sy - Sx Sxy)/det
+     *      det = Sxx N - Sx Sx
+     */
+    else if (STREQ (token, "linreg")) {
+	double det, r;
+
+	det = Sxx * N - Sx * Sx;	/* y=Ax+B */
+	A = (Sxy * N - Sy * Sx) / det;
+	B = (Sxx * Sy - Sx * Sxy) / det;
+	det = Syy * N - Sy * Sy;	/* x=Cy+D */
+	C = (Sxy * N - Sx * Sy) / det;
+	D = (Syy * Sx - Sy * Sxy) / det;
+	r = sqrt (A * C);
+	push (r);
+    }
+    else if (STREQ (token, "newy")) {
+	x = pop();
+	push (A * x + B);
+    }
+    else if (STREQ (token, "newx")) {
+	y = pop();
+	push (C * y + D);
+    }
+    else if (STREQ (token, "A")) {
+	push (A);
+    }
+    else if (STREQ (token, "B")) {
+	push (B);
+    }
+    else if (STREQ (token, "C")) {
+	push (C);
+    }
+    else if (STREQ (token, "D")) {
+	push (D);
+    }
+
+    /* System of equations: 2x2, 3x3
+     *	|a0 a1| |x| = |b0|
+     *	|a2 a3| |y|   |b1|
+     *  and
+     *	|a0 a1 a2| |x| = |b0|
+     *	|a3 a4 a5| |y| = |b1|
+     *	|a6 a7 a8| |z| = |b2|
+     */
+    else if (STREQN (token, "A=", 2) || STREQN (token, "b=", 2)) {
+	WORD_LIST *p, *plist;
+	int i;
+
+	plist = list_string (token + 2, ifs_value, 0);
+	switch (token[0]) {
+	case 'A':
+	    i = 0;
+	    for (p = plist; p && i < 9; p = p->next) {
+		process_token (p->word->word);
+		a[i++] = X;
+	    }
+	    break;
+	case 'b':
+	    i = 0;
+	    for (p = plist; p && i < 3; p = p->next) {
+		process_token (p->word->word);
+		b[i++] = X;
+	    }
+	    break;
+	}
+	dispose_words (plist);
+    }
+    else if (STREQ (token, "system2")) {
+	double det;
+
+	det = a[0] * a[3] - a[2] * a[1];
+	x = (b[0] * a[3] - b[1] * a[1]) / det;
+	y = (a[0] * b[1] - a[2] * b[0]) / det;
+	push (y);
+	push (x);
+    }
+    else if (STREQ (token, "system3")) {
+	double det;
+
+	det = a[0]*a[4]*a[8] + a[1]*a[5]*a[6] + a[2]*a[3]*a[7] -
+	    a[6]*a[4]*a[2] - a[3]*a[1]*a[8] - a[0]*a[7]*a[5];
+	x = (b[0]*a[4]*a[8] + a[1]*a[5]*b[2] + a[2]*b[1]*a[7] -
+		b[2]*a[4]*a[2] - b[1]*a[1]*a[8] - b[0]*a[7]*a[5]) / det;
+	y = (a[0]*b[1]*a[8] + b[0]*a[5]*a[6] + a[2]*a[3]*b[2] -
+		a[6]*b[1]*a[2] - a[3]*b[0]*a[8] - a[0]*b[2]*a[5]) / det;
+	z = (a[0]*a[4]*b[2] + a[1]*b[1]*a[6] + b[0]*a[3]*a[7] -
+		a[6]*a[4]*b[0] - a[3]*a[1]*b[2] - a[0]*a[7]*b[1]) / det;
+	push (z);
+	push (y);
+	push (x);
+    }
+
+    /* f(x)=...
+    */
+    else if (STREQN (token, "f(x)=", 5)) {
+	dispose_words (func_list);
+	func_list = list_string (token + 5, ifs_value, 0);
+    }
+    else if (STREQ (token, "f(x)")) {
+	return (subroutine (func_list));
+    }
+    else if (STREQN (token, "fd(x)=", 6)) {
+	dispose_words (fd_list);
+	fd_list = list_string (token + 6, ifs_value, 0);
+    }
+    else if (STREQ (token, "fd(x)")) {
+	return (subroutine (fd_list));
+    }
+    /* Ubiquitous Newton-Raphson algorithm for solving
+     *	    f(x) = 0
+     * where a root is repeatedly estimated by
+     *	    x = x - f(x)/f'(x)
+     * until |dx|/(1+|x|) < TOL is achieved.  This termination condition is a
+     * compromise between
+     *	    |dx| < TOL,  if x is small
+     *	    |dx|/|x| < TOL,  if x is large
+     */
+    else if (STREQ (token, "newton")) {		/* 1 initial estimate, X */
+	double dx, f, fd, TOL;
+	int count;
+
+	count = 0;
+	TOL = exp10 (-precision);
+
+	x = X;
+	subroutine (func_list);
+	f = X;
+	X = x;
+	subroutine (fd_list);
+	fd = X;
+	while (1) {
+	    dx = f / fd;
+	    if (fabs(dx) < TOL * (1 + fabs(x))) 
+		break;
+	    if (count++ > maxcount) {
+		builtin_error ("iteration limit reached");
+                X = x - dx;
+		return (EXECUTION_FAILURE);
+	    }
+	    x -= dx;
+	    X = x;
+	    subroutine (func_list);
+	    f = X;
+	    X = x;
+	    subroutine (fd_list);
+	    fd = X;
+	}
+	X = x - dx;
+    }
+    /* Similar to Newton's method, but the derivative is estimated by divided
+     * difference using only function calls.  A root is estimated by
+     *	    x = x - f(x) (x - oldx)/(f(x) - f(oldx))
+     * where
+     *	    oldx = x[i-1] and x = x[i].
+     */
+    else if (STREQ (token, "secant")) {		/* 2 initial estimates, X and Y */
+	double oldf, f, oldx, dx, TOL;
+	int count;
+
+	count = 0;
+	TOL = exp10 (-precision);
+
+	oldx = Y;
+	x = X;
+	subroutine (func_list);
+	f = X;
+	X = oldx;
+	subroutine (func_list);
+	oldf = X;
+	if (fabs(f) > fabs(oldf)) {	/* swap so that f(x) is closer to 0 */
+	    swap (x, oldx);
+	    swap (f, oldf);
+	}
+	while (1) {
+	    dx = f * (x - oldx) / (f - oldf);
+	    if (fabs(dx) < TOL * (1 + fabs(x)))
+		break;
+	    if (count++ > maxcount) {
+		builtin_error ("iteration limit reached");
+                X = x - dx;
+		return (EXECUTION_FAILURE);
+	    }
+	    oldx = x;
+	    x -= dx;
+	    oldf = f;
+	    X = x;
+	    subroutine (func_list);
+	    f = X;
+	}
+	X = x - dx;
+    }
+    /* Closed Simpson's rule for 
+     *	    \int_a^b f(x) dx
+     * Divide [a,b] iteratively into h, h/2, h/4, h/8, ... step sizes; and,
+     * for each step size, evaluate f(x) at a+h, a+3h, a+5h, a+7h, ..., b-3h,
+     * b-h, noting that other points have already been sampled.
+     * 
+     * At each iteration step, data are sampled only where necessary so that
+     * the total data is represented by adding sampled points from all
+     * previous steps:
+     *	    step 1:	h	a---------------b
+     *	    step 2:	h/2 	a-------^-------b
+     *	    step 3:	h/4	a---^-------^---b
+     *	    step 4:	h/8	a-^---^---^---^-b
+     *	    total:		a-^-^-^-^-^-^-^-b
+     * So, for step size of h/n, there are n intervals, and the data are
+     * sampled at the boundaries including the 2 end points.
+     * 
+     * If old = Trapezoid formula for an old step size 2h, then Trapezoid
+     * formula for the new step size h is obtained by 
+     *	    new = old/2 + h{f(a+h) + f(a+3h) + f(a+5h) + f(a+7h) +...+
+     *		    f(b-3h) + f(b-h)}
+     * Also, Simpson formula for the new step size h is given by
+     *	    simpson = (4 new - old)/3
+     */
+    else if (STREQ (token, "int_x^y")) {
+	double a, b, TOL, h;
+	double old, old2, new, new2, fa, fb, sum;
+	int count;
+
+	count = 0;
+	TOL = exp10 (-precision);
+	a = X;
+	b = Y;
+	h = b - a;
+
+	X = a;
+	subroutine (func_list);
+	fa = X;
+	X = b;
+	subroutine (func_list);
+	fb = X;
+	old2 = old = h * (fa + fb)/2;
+	while (1) {
+	    h = h/2;
+	    sum = 0;
+	    for (x = a + h; x < b; x += 2*h) {
+		X = x;
+		subroutine (func_list); 
+		sum += X;
+	    }
+	    new = old/2 + h * sum;
+	    new2 = (4 * new - old)/3;
+	    if (fabs(new2 - old2) < TOL * (1 + fabs(old2)))
+		break;
+	    if (count++ > maxcount) {
+		builtin_error ("iteration limit reached");
+                X = new2;
+		return (EXECUTION_FAILURE);
+	    }
+	    old = new;		/* Trapezoid */
+	    old2 = new2;		/* Simpson */
+	}
+	X = new2;
+    }
+    /* Open Simpson's rule (excluding end points) for
+     *	    \int_a^b f(x) dx
+     * Divide [a,b] iteratively into h, h/3, h/9, h/27, ... step sizes; and,
+     * for each step size, evaluate f(x) at a+h/2, a+2h+h/2, a+3h+h/2,
+     * a+5h+h/2, a+6h+h/2, ... , b-3h-h/2, b-2h-h/2, b-h/2, noting that other
+     * points have already been sampled.
+     * 
+     * At each iteration step, data are sampled only where necessary so that
+     * the total data is represented by adding sampled points from all
+     * previous steps:
+     *	    step 1:	h	a-----------------^-----------------b
+     *	    step 2:	h/3	a-----^-----------------------^-----b
+     *	    step 3:	h/9	a-^-------^---^-------^---^-------^-b
+     *	    total:		a-^---^---^---^---^---^---^---^---^-b
+     * So, for step size of h/n, there are n intervals, and the data are
+     * sampled at the midpoints.
+     * 
+     * If old = Trapezoid formula for an old step size 3h, then Trapezoid
+     * formula for the new step size h is obtained by 
+     *	    new = old/3 + h{f(a+h/2) + f(a+2h+h/2) + f(a+3h+h/2) +
+     *		    f(a+5h+h/2) + f(a+6h+h/2) +...+ f(b-3h-h/2) +
+     *		    f(b-2h-h/2) + f(b-h/2)}
+     * Also, Simpson formula for the new step size h is given by
+     *	    simpson = (9 new - old)/8
+     */
+    else if (STREQ (token, "oint_x^y")) {
+	double a, b, TOL, h;
+	double old, old2, new, new2, sum;
+	int count;
+
+	count = 0;
+	TOL = exp10 (-precision);
+	a = X;
+	b = Y;
+	h = b - a;
+
+	X = (a + b)/2;
+	subroutine (func_list);
+	old2 = old = h * X;
+	while (1) {
+	    h = h/3;
+	    sum = 0;
+	    for (x = a + h/2; x < b; x += 3*h) {
+		X = x;
+		subroutine (func_list);
+		sum += X;
+		X = x + 2*h;
+		subroutine (func_list);
+		sum += X;
+	    }
+	    new = old/3 + h * sum;
+	    new2 = (9 * new - old)/8;
+	    if (fabs(new2 - old2) < TOL * (1 + fabs(old2))) 
+		break;
+	    if (count++ > maxcount) {
+		builtin_error ("iteration limit reached");
+                X = new2;
+		return (EXECUTION_FAILURE);
+	    }
+	    old = new;		/* Trapezoid */
+	    old2 = new2;		/* Simpson */
+	}
+	X = new2;
+    }
+
+    /* Conditional test: x<y, x<NUMBER, ...
+    */
+    else if (STREQ (token, "[x<y]")) {		/* x?y */
+	return (X < Y)? EXECUTION_SUCCESS: EXECUTION_FAILURE;
+    }
+    else if (STREQ (token, "[x>y]")) {
+	return (X > Y)? EXECUTION_SUCCESS: EXECUTION_FAILURE;
+    }
+    else if (STREQ (token, "[x==y]")) {
+	return (X == Y)? EXECUTION_SUCCESS: EXECUTION_FAILURE;
+    }
+    else if (STREQ (token, "[x!=y]")) {
+	return (X != Y)? EXECUTION_SUCCESS: EXECUTION_FAILURE;
+    }
+    else if (STREQ (token, "[x<=y]")) {
+	return (X <= Y)? EXECUTION_SUCCESS: EXECUTION_FAILURE;
+    }
+    else if (STREQ (token, "[x>=y]")) {
+	return (X >= Y)? EXECUTION_SUCCESS: EXECUTION_FAILURE;
+    }
+    else if (sscanf (token, "[x<%lf]%n", &x, &end) == 1 && size == end) {	/* x?NUMBER */
+	return (X < x)? EXECUTION_SUCCESS: EXECUTION_FAILURE;
+    }
+    else if (sscanf (token, "[x>%lf]%n", &x, &end) == 1 && size == end) {
+	return (X > x)? EXECUTION_SUCCESS: EXECUTION_FAILURE;
+    }
+    else if (sscanf (token, "[x==%lf]%n", &x, &end) == 1 && size == end) {
+	return (X == x)? EXECUTION_SUCCESS: EXECUTION_FAILURE;
+    }
+    else if (sscanf (token, "[x!=%lf]%n", &x, &end) == 1 && size == end) {
+	return (X != x)? EXECUTION_SUCCESS: EXECUTION_FAILURE;
+    }
+    else if (sscanf (token, "[x<=%lf]%n", &x, &end) == 1 && size == end) {
+	return (X <= x)? EXECUTION_SUCCESS: EXECUTION_FAILURE;
+    }
+    else if (sscanf (token, "[x>=%lf]%n", &x, &end) == 1 && size == end) {
+	return (X >= x)? EXECUTION_SUCCESS: EXECUTION_FAILURE;
+    }
+
+    /* Number test
+    */
+    else if (STREQ (token, "isnan(x)")) {
+	return (isnan (X))? EXECUTION_SUCCESS: EXECUTION_FAILURE;
+    }
+    else if (STREQ (token, "isinf(x)")) {
+	return (isinf (X))? EXECUTION_SUCCESS: EXECUTION_FAILURE;
+    }
+    else if (STREQ (token, "isfinite(x)")) {
+	return (isfinite (X))? EXECUTION_SUCCESS: EXECUTION_FAILURE;
+    }
+    else if (STREQ (token, "isnormal(x)")) {
+	return (isnormal (X))? EXECUTION_SUCCESS: EXECUTION_FAILURE;
+    }
+
+    else {
+	builtin_error ("`%s': illegal token", token);
+	return (EXECUTION_FAILURE);
+    }
+    return (EXECUTION_SUCCESS);
+}
+
+
+/* Returns
+ *	EXECUTION_SUCCESS (0)
+ *	EXECUTION_FAILURE (1)
+ */
+static int 
+subroutine (list)
+    WORD_LIST *list;
+{
+    int out;
+
+    for ( ; list; list = list->next)
+	out = process_token (list->word->word);
+
+    return (out);	/* the last return value */
+}
+
+
+int
+rpn_builtin (list)
+     WORD_LIST *list;
+{
+    int opt;
+
+    reset_internal_getopt ();
+    while ((opt = internal_getopt (list, "f:e:g:n:")) != -1) {
+	switch (opt) {
+	case 'f':
+	case 'e':
+	case 'g':
+	    format = opt;
+	    if (! legal_positive_integer (list_optarg, &precision)) {
+		sh_invalidnum (list_optarg);
+		return (EXECUTION_FAILURE);
+	    }
+	    break;
+	case 'n':
+	    if (! legal_positive_integer (list_optarg, &maxcount)) {
+		sh_invalidnum (list_optarg);
+		return (EXECUTION_FAILURE);
+	    }
+	    break;
+	default:
+	    builtin_usage ();
+	    return (EX_BADUSAGE);
+	}
+    }
+    list = loptend;		/* skip over possible `--' */
+
+    if (list == 0) {		/* 0 argument */
+	builtin_usage ();
+	return (EX_BADUSAGE);
+    }
+
+    return (subroutine (list));
+}
+
+
+char *rpn_doc[] = {
+    "Simple RPN calculator, modelled after HP calculators.  It has the usual X,",
+    "Y, Z, T stack variables, and supports most functions in <math.h>.  It reads",
+    "sequence of tokens from command line.  If the token is number or constant,",
+    "then it's pushed onto the stack as X.  If the token is an operation, then it",
+    "performs the operation on the stack.  Currently, the following tokens are",
+    "recognized:",
+    "",
+    "Stack operations:",
+    "",
+    "    clear  clearall",
+    "        Clears the stack, or both the stack and internal registers 0-9.",
+    "    sto_[yzt0-9]  rcl_[yzt0-9]",
+    "        Store X into internal register 0-9, Y, Z, or T.  Or, recall",
+    "        internal register 0-9, Y, Z, or T to the stack as X.",
+    "    swap  swap_z  swap_t  x<>y  x<>z  x<>t",
+    "        Swap X with Y, Z, T.",
+    "    drop  dup",
+    "        Pop X, or duplicate X.",
+    "",
+    "HMS functions:",
+    "",
+    "    clearhms",
+    "        Clears internal counters used in 'hms' arithmetic.",
+    "    hms++  hms-- ",
+    "        Add or substract DHMS.sss format, where D (day), H (hour), M",
+    "        (minute), S.sss (second) are loaded to T, Z, Y, X stack variables,",
+    "        separately.",
+    "",
+    "Basic arithmetics:",
+    "",
+    "    +/-",
+    "        Toggles the sign of X.",
+    "    sign",
+    "        -1, 0, 1 if X<0, X==0, X>0, respectively.",
+    "    |x|  fabs  floor  ceil  trunc  round  rint  fmod  modf",
+    "        Support fabs(3), floor(3), ceil(3), trunc(3), round(3), rint(3),",
+    "        fmod(3), modf(3).",
+    "    fmin  fmax",
+    "        Replace X and Y with min or max.",
+    "    -  +  *  x  /  x++  x--  y++  y--  1-x  1-y",
+    "        Basic arithmetic.  Since '*' is shell glob character, you can use",
+    "        'x' instead.",
+    "    %  %ch",
+    "        Y remains unchanged.  Replace X with % of Y, or % of change from Y.",
+    "",
+    "Scientific functions:",
+    "",
+    "    1/x  x^2  x^3  sqr  cub  sqrt  cbrt  hypot  y^x  pow",
+    "    e^x  10^x  2^x  exp  exp10  exp2  ln  log  log10  log2  e^x-1  ln(1+x)",
+    "    sin  cos  tan  asin  acos  atan  atan2",
+    "    sinh  cosh  tanh  asinh  acosh  atanh",
+    "    j0  j1  jn  y0  y1  yn  erf  erfc  lgamma  tgamma",
+    "        Scientific functions.  'ln' and 'log' are the same, so use 'log10'",
+    "        for base-10 logarithm.",
+    "    rad->deg  deg->rad",
+    "        Convert degree to radian, and vice versa.",
+    "    polar->rect  rect->polar",
+    "        Convert (x,y) to (r,angle), and vice versa.  'angle' is in radian.",
+    "",
+    "Output:",
+    "",
+    "    =  =[x|y|z|t]  VAR=[x|y|z|t]",
+    "        saves X, Y, Z, or T to shell variable VAR.  If VAR is missing, then",
+    "        print the stack variable to stdout.  If '=' is given by itself,",
+    "        then print all stack variables T, Z, Y, X (in that order) to",
+    "        stdout.  When printing to stdout or saving to shell variable, the",
+    "        default format is '%.6f'.  Option -[feg] selects 'f', 'e', 'g'",
+    "        format of printf(3), respectively, with the specified precision.",
+    "",
+    "Input:",
+    "",
+    "    pi  pi/2  pi/4  1/pi  2/pi  2/sqrt(pi)  sqrt(2)  1/sqrt(2)",
+    "    e  ln(2)  ln(10)  log2(e)  log10(e)",
+    "        These are constansts.",
+    "    NUMBER  [x|y|z|t]=NUMBER",
+    "        Assigns (double)NUMBER to X, Y, Z, or T.  If NUMBER is by itself,",
+    "        then push it onto the stack.",
+    "",
+    "Statistics (2-variable):",
+    "",
+    "    clearstat  stat++  stat--  N  Sx  Sy  Sxx  Syy  Sxy  mean  wmean  stddev",
+    "        Common 2-variable statistics is implemented, using variables Sx,",
+    "        Sy, Sxx, Syy, Sxy, which are \\sum_i of x_i, y_i, (x_i)^2, (y_i)^2,",
+    "        (x_i)(y_i), for i=1,2,3,...,N, where N is number of data points.",
+    "        Current X and Y values are added to or substracted from statistics",
+    "        variables by 'stat++' or 'stat--', respectively.  If the name of",
+    "        variable is given as token, then it will be recalled onto the",
+    "        stack.  'mean' and 'stddev' will put mean and (sample) standard",
+    "        deviation of x and y data in X and Y.  'wmean' is mean of x",
+    "        weighted by y, ie. Sxy/Sy instead of Sx/N.",
+    "",
+    "Linear regression:",
+    "",
+    "    linreg  newy  newx  A  B  C  D",
+    "        'linreg' does a simple linear regression of 'y=Ax+B' and 'x=Cy+D',",
+    "        using 2-variable statistics.  It returns regression coefficient in",
+    "        X.  The variables A, B, C, D can be recalled to the stack simply by",
+    "        using its name as token.  'newy' will calculate new y for given x",
+    "        data in X, and 'newx' will calculate new x for given y data in X.",
+    "",
+    "System solver (2x2, 3x3):",
+    "",
+    "    A=NUMBER...  b=NUMBER... system2  system3",
+    "        2x2 and 3x3 system of equations are solved using Determinant.",
+    "        Given Ax=b equation, 'A=...' specifies elements of A, going across",
+    "        the row, and 'b=...' specifies elements of b, going down the",
+    "        column.  Both must be single string, and the tokens will be split",
+    "        using the current IFS.  'system2' will return x=(X,Y) on the stack,",
+    "        and 'system3' will return x=(X,Y,Z) on the stack.",
+    "",
+    "Integration and Root solver:",
+    "",
+    "    f(x)=token...  f(x)  int_x^y  oint_x^y",
+    "    fd(x)=token...  fd(x)  newton  secant",
+    "        Numerical integration \\int_x^yf(x)dx uses open/closed Simpson's",
+    "        rule.  'int_x^y' evaluates end points f(x) and f(y), and 'oint_x^y'",
+    "        evaluates only the interior points.  Root solver f(x)=0 uses",
+    "        Newton/Secant method, where 'newton' uses X as initial estimate,",
+    "        and 'secant' uses X and Y for the 2 initial estimates.  Precision",
+    "        is determined by -[feg] options, and there is limit of 1000",
+    "        iterations set by '-n' option.  The function definition 'f(x)=...'",
+    "        and 'fd(x)=...' must be single string, and the tokens will be split",
+    "        using the current IFS.  'f(x)' or 'fd(x)' will process the sequence",
+    "        of token, like the main routine, and will leave the result in X.",
+    "",
+    "Conditional tests:",
+    "",
+    "    [x<NUMBER]  [x>NUMBER]  [x==NUMBER]  [x!=NUMBER]  [x<=NUMBER]  [x>=NUMBER]",
+    "    [x<y]  [x>y]  [x==y]  [x!=y]  [x<=y]  [x>=y]",
+    "        Return the result of conditional test, which will be either success",
+    "        (0) or failure (1) in shell sense.  Generally, the return value of",
+    "        'rpn' command is the result of last token processed.",
+    "    isnan(x)  isinf(x)  isfinite(x)  isnormal(x)",
+    "        Return success (0) if macro test is true, and return failure (1) if",
+    "        false.",
+(char *)NULL
+};
+struct builtin rpn_struct = {
+    "rpn", rpn_builtin, BUILTIN_ENABLED, rpn_doc,
+    "rpn [-feg precision] [-n maxcount] token...",
+    (char *)NULL
+};
--- bash-3.2_orig/examples/loadables/william/sqlite.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/sqlite.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,133 @@
+/*******************************************************************************
+ * Interface to SQLite-2.8.13.
+ */
+
+#include "loadables.h"
+
+
+#if defined (HAVE_SQLITE)
+
+#include <sqlite.h>
+
+static int NF, NR, called_back;
+
+
+static int
+callback (var, argc, argv, col_names)
+    SHELL_VAR *var;		/* cast from (void *) */
+    int argc;
+    char **argv, **col_names;
+{
+    int i;
+
+    called_back = 1;
+
+    for (i = 0; i < argc; i++) {
+	if (var == 0) {
+	    printf ("%s", argv[i]);
+	    putchar ((i<argc-1) ? '\t' : '\n');
+	}
+#if defined (ARRAY_VARS)
+	else
+	    arrayvar_append (var, argv[i]);
+#endif
+    }
+    NF = argc;
+    if (NF > 0) NR++;
+    return (0);
+}
+
+
+int
+Lsql_builtin (list)
+    WORD_LIST *list;
+{
+    int opt, out;
+    SHELL_VAR *var;
+    char *file, *text, *errmsg;
+    sqlite *db;
+
+    var = (SHELL_VAR *)NULL;
+    file = (char *)NULL;
+
+    reset_internal_getopt ();
+    while ((opt = internal_getopt (list, "a:d:")) != -1) {
+	switch (opt) {
+#if defined (ARRAY_VARS)
+	case 'a':
+	    var = force_name_to_arrayvar (list_optarg, 1);
+	    if (var == 0)
+		return (EXECUTION_FAILURE);
+	    break;
+#endif
+        case 'd':
+            file = list_optarg;
+            break;
+	default:
+	    builtin_usage ();
+	    return (EX_BADUSAGE);
+	}
+    }
+    list = loptend;		/* skip over possible `--' */
+
+    if (list == 0 || file == 0) {	/* 0 argument or no database */
+	builtin_usage ();
+	return (EX_BADUSAGE);
+    }
+
+    unbind_variable ("NF");
+    unbind_variable ("NR");
+
+    /* 1 or more arguments: sql [-option] SQL... */
+
+    if ((db = sqlite_open (file, 0 /* not used */, &errmsg)) == 0) {
+	builtin_error ("cannot open database `%s': %s", file, errmsg);
+	FREE (errmsg);
+	return (EXECUTION_FAILURE);
+    }
+
+    out = EXECUTION_SUCCESS;
+    for ( ; list && out == EXECUTION_SUCCESS; list = list->next) {
+	NF = NR = called_back = 0;
+	text = list->word->word;
+	if (sqlite_exec (db, text, callback, var, &errmsg) != SQLITE_OK) {
+	    out = EXECUTION_FAILURE;
+	    builtin_error ("exec failed: %s", errmsg);
+	    FREE (errmsg);
+	}
+	if (called_back) {
+	    bind_var_to_int ("NF", NF);
+	    bind_var_to_int ("NR", NR);
+	}
+    }
+    sqlite_close (db);
+    return (out);
+}
+
+
+char *Lsql_doc[] = {
+    "Interface to SQLite-2.8.13 (www.sqlite.org).  After connecting to database,",
+    "arguments are feed to SQL engine sequentially.  It returns 1 immediately on",
+    "any error.  If all arguments are processed without error, then returns",
+    "success (0).  Each 'Lsql' command is complete, in that it opens and closes",
+    "connection with the database.",
+    "",
+    "    Lsql -d file SQL...",
+    "        Print query result (if any) to stdout.  Fields are separated by \\t,",
+    "        one row per line.",
+    "",
+    "    Lsql -a array -d file SQL...",
+    "        Save query result (if any) into array.  Fields are appended",
+    "        sequentially, row by row; and, they are cumulative.",
+    "",
+    "For convenience, shell variables NF and NR are set from the last query",
+    "result.",
+    (char *)NULL
+};
+struct builtin Lsql_struct = {
+    "Lsql", Lsql_builtin, BUILTIN_ENABLED, Lsql_doc,
+    "Lsql [-a array] -d file SQL...",
+    (char *)NULL
+};
+
+#endif	/* HAVE_SQLITE */
--- bash-3.2_orig/examples/loadables/william/sscanf.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/sscanf.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,97 @@
+/*******************************************************************************
+ * Shell wrapper for sscanf(3),
+ *	sscanf input format var1 [... var9]
+ * and it supports 
+ *	- string format, ie. %s %c %[...] %[^...]
+ *	- up to 9 variables.
+ */
+
+#include "loadables.h"
+
+
+int
+sscanf_builtin (list)
+    WORD_LIST *list;
+{
+    char *input, *fmt, *t, *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8, *a9;
+    int n, size, out;
+    WORD_LIST *p;
+
+    if (no_options (list))
+	return (EX_BADUSAGE);
+    list = loptend;		/* skip over possible `--' */
+
+    n = list_length (list) - 2;
+    if (n < 1 || n > 9) {
+	builtin_usage ();
+	return (EX_BADUSAGE);
+    }
+    input = list->word->word;	list = list->next;
+    fmt = list->word->word;	list = list->next;
+
+    for (p = list ; p; p = p->next) {
+	t = p->word->word;
+	if (legal_identifier (t) == 0) {
+	    sh_invalidid (t);
+	    return (EXECUTION_FAILURE);
+	}
+    }
+
+    size = strlen (input);
+    a1 = (char *)xmalloc (size + 1); memset (a1, 0, size + 1);	/* %c does not put \0 */
+    a2 = (char *)xmalloc (size + 1); memset (a2, 0, size + 1);
+    a3 = (char *)xmalloc (size + 1); memset (a3, 0, size + 1);
+    a4 = (char *)xmalloc (size + 1); memset (a4, 0, size + 1);
+    a5 = (char *)xmalloc (size + 1); memset (a5, 0, size + 1);
+    a6 = (char *)xmalloc (size + 1); memset (a6, 0, size + 1);
+    a7 = (char *)xmalloc (size + 1); memset (a7, 0, size + 1);
+    a8 = (char *)xmalloc (size + 1); memset (a8, 0, size + 1);
+    a9 = (char *)xmalloc (size + 1); memset (a9, 0, size + 1);
+
+    if (sscanf (input, fmt, a1, a2, a3, a4, a5, a6, a7, a8, a9) == n) {
+	p = list = REVERSE_LIST (list, WORD_LIST *);
+	switch (n) {
+	    case 9: bind_variable (p->word->word, a9); p = p->next;
+	    case 8: bind_variable (p->word->word, a8); p = p->next;
+	    case 7: bind_variable (p->word->word, a7); p = p->next;
+	    case 6: bind_variable (p->word->word, a6); p = p->next;
+	    case 5: bind_variable (p->word->word, a5); p = p->next;
+	    case 4: bind_variable (p->word->word, a4); p = p->next;
+	    case 3: bind_variable (p->word->word, a3); p = p->next;
+	    case 2: bind_variable (p->word->word, a2); p = p->next;
+	    case 1: bind_variable (p->word->word, a1); p = p->next;
+	}
+	REVERSE_LIST (list, WORD_LIST *);
+	out = EXECUTION_SUCCESS;
+    } else {
+	builtin_error ("format and argument do not match");
+	out = EXECUTION_FAILURE;
+    }
+
+    FREE (a1);
+    FREE (a2);
+    FREE (a3);
+    FREE (a4);
+    FREE (a5);
+    FREE (a6);
+    FREE (a7);
+    FREE (a8);
+    FREE (a9);
+    return (out);
+}
+
+
+char *sscanf_doc[] = {
+    "Shell wrapper for sscanf(3).  Supports only string format, ie.",
+    "    %s          -- whitespace delimited string",
+    "    %c          -- character(s) converted to string",
+    "    %[...]      -- string composed of chars in [...]",
+    "    %[^...]     -- string composed of chars not in [...]",
+    "and up to 9 variables.",
+    (char *)NULL
+};
+struct builtin sscanf_struct = {
+    "sscanf", sscanf_builtin, BUILTIN_ENABLED, sscanf_doc,
+    "sscanf input format var1 [... var9]",
+    (char *)NULL
+};
--- bash-3.2_orig/examples/loadables/william/stack.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/stack.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,916 @@
+/*******************************************************************************
+ * Stack/queue operations on positional parameters or array.
+ */
+
+#include "loadables.h"
+
+
+extern char *this_command_name;
+extern int print_shift_error;
+
+enum stack_flag { 
+    append_flag,
+    collapse_flag,
+    prune_flag,
+    flip_flag,
+    overwrite_flag,
+    pop_flag,
+    push_flag,
+    read_flag,
+    rotateleft_flag,
+    rotateright_flag,
+    set_flag,
+    sort_flag,
+    swap_flag,
+    transpose_flag,
+    trim_flag,
+    uniq_flag,
+};
+
+#define	WANT_UNIQUE		0x1	/* uniq -u */
+#define	WANT_DUPLICATE		0x2	/* uniq -d */
+#define WANT_ALL_DUPLICATES	0x4	/* uniq -D */
+#define WANT_CASELESS		0x8	/* uniq -i */
+
+int uniq_options;
+
+
+static char **uniq			__P((char **, int));
+
+static void argv_back_into_parameters	__P((char **, int));
+static void parameters_uniq		__P((void));
+static void parameters_collapse		__P((void));
+static int stack_parameter_internal	__P((enum stack_flag, WORD_LIST *, int));
+
+static void argv_back_into_array	__P((char **, int, ARRAY *));
+static void array_uniq			__P((ARRAY *));
+static void insert_before		__P((ARRAY_ELEMENT *, ARRAY *, arrayind_t, char *, int));
+static void array_set_argv		__P((ARRAY *, char **, int));
+static int stack_array_internal		__P((SHELL_VAR *, enum stack_flag, WORD_LIST *, int));;
+
+
+/* Return new string vector, filled with copies according to various options
+ * similar to 'uniq [-Ddui]' command.  By default, single duplicate and single
+ * unique item are selected, just like 'uniq'.
+ */
+static char **
+uniq (vec1, uniq_options)
+    char **vec1;
+    int uniq_options;
+{
+    int i, j, size;
+    char **v, **vec2;
+
+    size = strvec_len (vec1);
+    vec2 = strvec_create (size + 1);
+
+    if ((uniq_options & ~WANT_CASELESS) == 0)
+	uniq_options |= WANT_DUPLICATE | WANT_UNIQUE;
+
+    v = vec2;
+    for (i = 0; i < size; i++) {
+	if (uniq_options & WANT_CASELESS)
+	    for (j = i + 1; vec1[j] && strcasecmp (vec1[i], vec1[j]) == 0; j++)
+		;		/* [i, j-1] = segment */
+	else
+	    for (j = i + 1; vec1[j] && STREQ (vec1[i], vec1[j]); j++)
+		;		/* [i, j-1] = segment */
+
+	if (j == i + 1 && uniq_options & WANT_UNIQUE)
+	    *(v++) = savestring (vec1[i]);
+
+	if (j > i + 1 && uniq_options & WANT_ALL_DUPLICATES) {
+	    for ( ; i < j; i++)
+		*(v++) = savestring (vec1[i]);
+	} else if (j > i + 1 && uniq_options & WANT_DUPLICATE)
+	    *(v++) = savestring (vec1[i]);
+
+	i = j - 1;
+    }
+    *v = (char *)NULL;
+    return (vec2);
+}
+
+
+/* Write string vector back into positional parameters, in-place and without
+ * memory deallocation or allocation.  It's assumed that they are of same size
+ * and contain the same pointers and contents, except for reordering of items.
+ * WARNING
+ */
+static void
+argv_back_into_parameters (v, size)
+    char **v;
+    int size;
+{
+    int i;
+    WORD_LIST *p;
+
+    for (i = 0; i < 9 && i < size; i++)	
+	dollar_vars[i+1] = v[i];
+    for (p = rest_of_args; p && i < size; i++, p = p->next)
+	p->word->word = v[i];
+}
+
+
+#if 0
+/* Remove consecutive duplicates in positional parameters.  Done in-place,
+ * without unnecessary copying back and forth.
+ */
+static void 
+parameters_uniq ()
+{
+    int i;
+    WORD_LIST *p, *oldp;
+
+    /* remove duplicates in $1..$9 */
+    for (i = 2; i < 10 && dollar_vars[i]; i++) {
+	if (STREQ (dollar_vars[i-1], dollar_vars[i]))
+	    remove_dollar_var (i--);
+    }
+    /* remove duplicates in $10, $11, ... */
+    if (rest_of_args) {
+	oldp = rest_of_args;
+	for (p = rest_of_args->next; p; p = p->next) {
+	    if (STREQ (oldp->word->word, p->word->word))
+		p = remove_list_item (oldp, p);
+	    else
+		oldp = p;
+	}
+    }
+    /* compare $9 and $10 */
+    if (rest_of_args && STREQ (dollar_vars[9], rest_of_args->word->word))
+	remove_dollar_var (9);
+}
+#endif
+
+
+/* Remove empty (null) positional parameters.  Done in-place, without
+ * unnecessary copying back and forth.
+ */
+static void 
+parameters_collapse ()
+{
+    int i;
+    WORD_LIST *p, *oldp;
+
+    /* remove null in $1..$9 */
+    for (i = 1; i < 10 && dollar_vars[i]; i++) {
+	if (*(dollar_vars[i]) == '\0')
+	    remove_dollar_var (i--);
+    }
+    /* remove null in $11, $12, ... (check $10 later) */
+    if (rest_of_args) {
+	oldp = rest_of_args;
+	for (p = rest_of_args->next; p; p = p->next) {
+	    if (*(p->word->word) == '\0')
+		p = remove_list_item (oldp, p);
+	    else
+		oldp = p;
+	}
+    }
+    /* remove null in $10 */
+    if (rest_of_args && *(rest_of_args->word->word) == '\0')
+	rest_of_args = remove_list_item ((WORD_LIST *)NULL, rest_of_args);
+}
+
+
+static int
+stack_parameter_internal (flag, list, shiftn)
+    enum stack_flag flag;
+    WORD_LIST *list;
+    int shiftn;
+{
+    int i, j, size;
+    char *t, **v, **vec1, **vec2;
+
+    switch (flag) {
+    case pop_flag:
+	/* Can't use builtin 'shift N', because it returns error if N is greater
+	 * than $#.  Also, options get processed again, using global variables.
+	 * So, shift one by one.  Return error, if parameter is empty.
+	 */
+	if (dollar_vars[1] == 0) {
+	    if (print_shift_error)
+		builtin_error ("nothing to shift");
+	    return (EXECUTION_FAILURE);
+	}
+	while (shiftn-- > 0 && dollar_vars[1])
+	    remove_dollar_var (1);
+	break;
+
+    case trim_flag:
+	if (dollar_vars[1] == 0) {
+	    if (print_shift_error)
+		builtin_error ("nothing to trim");
+	    return (EXECUTION_FAILURE);
+	}
+	stack_parameter_internal (rotateright_flag, (WORD_LIST *)NULL, shiftn);
+	stack_parameter_internal (pop_flag, (WORD_LIST *)NULL, shiftn);
+	break;
+
+    case push_flag:
+	parameters_push_list (list);
+	break;
+
+    case append_flag:
+	parameters_append_list (list);
+	break;
+
+    case swap_flag:
+	if (dollar_vars[1] == 0 || dollar_vars[2] == 0) {
+	    if (print_shift_error)
+		builtin_error ("nothing to swap");
+	    return (EXECUTION_FAILURE);
+	}
+	t = dollar_vars[1];
+	dollar_vars[1] = dollar_vars[2];
+	dollar_vars[2] = t;
+	break;
+
+    case set_flag:
+	parameters_set_list (list);
+	break;
+
+    case overwrite_flag:
+	parameters_overwrite_list (list);
+	break;
+
+    case uniq_flag:
+#if 0
+	parameters_uniq ();
+#else
+	vec1 = argv_from_parameters (0);
+	vec2 = uniq (vec1, uniq_options);	/* strings are copies */
+	parameters_set_argv (vec2, 0);
+	FREE (vec1);
+	FREE (vec2);
+#endif
+	break;
+
+    case collapse_flag:	
+    case prune_flag:		/* for parameters, "prune" == "collapse" */
+	parameters_collapse ();
+	break;
+
+    /* These routines simply re-order the positional parameters.  They don't
+     * change, add, or delete items.
+     */
+    case rotateleft_flag:
+    case rotateright_flag:
+    case flip_flag:
+    case transpose_flag:
+    case sort_flag:
+	vec1 = argv_from_parameters (0);
+	vec2 = argv_from_parameters (0);
+	size = strvec_len (vec1);
+	switch (flag) {
+	case rotateleft_flag:
+	    for (i = 0; i < size; i++)
+		vec2[i] = vec1[(i + shiftn) % size];
+	    break;
+	case rotateright_flag:
+	    for (i = 0; i < size; i++)
+		vec2[(i + shiftn) % size] = vec1[i];
+	    break;
+	case flip_flag:
+	    for (i = 0; i < size; i++)
+		vec2[i] = vec1[size-1 - i];
+	    break;
+	case transpose_flag:
+	    v = vec2;
+	    for (i = 0; i < shiftn && i < size; i++)
+		for (j = i; j < size; j += shiftn)
+		    *(v++) = vec1[j];
+	    break;
+	case sort_flag:
+	    strvec_sort (vec2);
+	    break;
+	}
+	argv_back_into_parameters (vec2, size);
+	FREE (vec1);
+	FREE (vec2);
+	break;
+
+    case read_flag:
+	if (dollar_vars[1] == 0) {
+	    if (print_shift_error)
+		builtin_error ("nothing to read");
+	    return (EXECUTION_FAILURE);
+	}
+	for ( ; list; list = list->next) {
+	    if (dollar_vars[1]) {
+		bind_variable (list->word->word, dollar_vars[1]);
+		remove_dollar_var (1);
+	    } else
+		bind_variable (list->word->word, "");
+	}
+	break;
+
+    default:
+	builtin_error ("no action was taken... typo?");
+	return (EX_BADUSAGE);
+    }
+
+    set_dollar_vars_changed ();		/* from remember_args() */
+    return (EXECUTION_SUCCESS);
+}
+
+
+#if defined (ARRAY_VARS)
+static int
+qsort_intcmp (x, y)	/* integer comparision for use in qsort() */
+    char **x, **y;
+{
+    intmax_t ix, iy;
+
+    ix = iy = 0;
+    if (x && *x && **x) legal_number (*x, &ix);
+    if (y && *y && **y) legal_number (*y, &iy);
+
+    if (ix < iy) return -1;
+    if (ix > iy) return 1;
+    return 0;
+}
+
+
+/* Write string vector into existing array, in-place and without memory
+ * deallocation or allocation.  It's assumed that they are of same size and
+ * contain the same pointers and contents, except for reordering of items.
+ * WARNING
+ */
+static void
+argv_back_into_array (v, size, a)
+    char **v;
+    int size;
+    ARRAY *a;
+{
+    int i;
+    ARRAY_ELEMENT *ae;
+
+    ae = element_forw (a->head);
+    i = 0;
+    while (ae != a->head && i < size) {
+	element_value (ae) = v[i];
+	ae = element_forw (ae);
+	i++;
+    }
+}
+
+
+#if 0
+static void
+array_uniq (a)		/* Remove consecutive duplicates */
+    ARRAY *a;
+{
+    ARRAY_ELEMENT *ae, *old;
+
+    ae = element_forw (a->head);
+    for (ae = element_forw (ae); ae != a->head; ae = element_forw (ae)) {
+	if (STREQ (element_value (ae->prev), element_value (ae))) {
+	    old = ae->prev;
+	    remove_array_element (ae, a);
+	    ae = old;
+	}
+    }
+    re_index_array (a, 0);
+}
+#endif
+
+
+/* Insert new element (with index I and string VAL) before array element AE in
+ * array A.  It updates 'num_elements' and 'max_index'.
+ */
+static void
+insert_before (ae, a, i, val, alloc)
+    ARRAY_ELEMENT *ae;
+    ARRAY *a;
+    arrayind_t i;
+    char *val;
+    int alloc;
+{
+    ARRAY_ELEMENT *new;
+
+    new = (ARRAY_ELEMENT *)xmalloc (sizeof (ARRAY_ELEMENT));
+    new->ind = i;
+    new->value = (alloc)? savestring (val): val;
+
+    /* was ADD_BEFORE() macros from array.c */
+    ae->prev->next = new;
+    new->prev = ae->prev;
+    ae->prev = new;
+    new->next = ae;
+
+    a->num_elements++;
+    if (i > a->max_index)	/* if inserting as last item */
+	a->max_index = i;
+}
+
+
+/* Assign string vector to array, flushing existing array elements.
+ */
+static void
+array_set_argv (a, v, alloc)
+    ARRAY *a;
+    char **v;		/* can be NULL or empty, in which case just flush */
+    int alloc;
+{
+    arrayind_t i;
+
+    array_flush (a);
+    for (i = 0; v && v[i]; i++)
+	insert_before (a->head, a, i, v[i], alloc);
+}
+
+
+static int
+stack_array_internal (var, flag, list, shiftn)
+    SHELL_VAR *var;
+    enum stack_flag flag;
+    WORD_LIST *list;
+    int shiftn;
+{
+    int i, j, size;
+    WORD_LIST *p;
+    char *t, **v, **vec1, **vec2;
+    ARRAY *a;
+    ARRAY_ELEMENT *ae, *old;
+
+    a = array_cell (var);
+    size = array_num_elements (a);
+
+    switch (flag) {
+    case pop_flag:
+	if (size == 0) {
+	    if (print_shift_error)
+		builtin_error ("nothing to shift");
+	    return (EXECUTION_FAILURE);
+	}
+	arrayvar_pop (var, shiftn);
+	break;
+
+    case trim_flag:
+	if (size == 0) {
+	    if (print_shift_error)
+		builtin_error ("nothing to trim");
+	    return (EXECUTION_FAILURE);
+	}
+	arrayvar_trim (var, shiftn);
+	break;
+
+    case push_flag:
+	arrayvar_push_list (var, list);
+	break;
+
+    case append_flag:
+	arrayvar_append_list (var, list);
+	break;
+
+    case swap_flag:
+	if (size < 2) {
+	    if (print_shift_error)
+		builtin_error ("nothing to swap");
+	    return (EXECUTION_FAILURE);
+	}
+	old = element_forw (a->head);
+	ae = element_forw (old);
+	t = element_value (old);
+	element_value (old) = element_value (ae);
+	element_value (ae) = t;
+	break;
+
+    case set_flag:
+	arrayvar_set_list (var, list);
+	break;
+
+    case overwrite_flag:
+	array_assign_list (a, list);
+	break;
+
+    case uniq_flag:
+#if 0
+	array_uniq (a);
+#else
+	vec1 = argv_from_array (a, 0);
+	vec2 = uniq (vec1, uniq_options);	/* strings are copies */
+	array_set_argv (a, vec2, 0);
+	FREE (vec1);
+	FREE (vec2);
+#endif
+	break;
+
+    case collapse_flag:		/* remove empty elements, and re-index */
+	array_prune (a);
+	re_index_array (a, 0);
+	break;
+    case prune_flag:		/* just remove empty elements */
+	array_prune (a);
+	break;
+
+    /* These routines simply re-order the array.  They don't change, add, or
+     * delete array elements.
+     */
+    case rotateleft_flag:
+    case rotateright_flag:
+    case flip_flag:
+    case transpose_flag:
+    case sort_flag:
+	vec1 = argv_from_array (a, 0);
+	vec2 = argv_from_array (a, 0);
+	switch (flag) {
+	case rotateleft_flag:
+	    for (i = 0; i < size; i++)
+		vec2[i] = vec1[(i + shiftn) % size];
+	    break;
+	case rotateright_flag:
+	    for (i = 0; i < size; i++)
+		vec2[(i + shiftn) % size] = vec1[i];
+	    break;
+	case flip_flag:
+	    for (i = 0; i < size; i++)
+		vec2[i] = vec1[size-1 - i];
+	    break;
+	case transpose_flag:
+	    v = vec2;
+	    for (i = 0; i < shiftn && i < size; i++)
+		for (j = i; j < size; j += shiftn)
+		    *(v++) = vec1[j];
+	    break;
+	case sort_flag:
+	    if (integer_p (var))
+		qsort (vec2, (size_t)size, (size_t)sizeof (char *), qsort_intcmp);
+	    else
+		strvec_sort (vec2);
+	    break;
+	}
+	argv_back_into_array (vec2, size, a);
+	FREE (vec1);
+	FREE (vec2);
+	break;
+
+    case read_flag:
+	if (size == 0) {
+	    if (print_shift_error)
+		builtin_error ("nothing to read");
+	    return (EXECUTION_FAILURE);
+	}
+	for (p = list; p; p = p->next) {
+	    if (array_empty (a))
+		bind_variable (p->word->word, "");
+	    else {
+		ae = element_forw (a->head);
+		bind_variable (p->word->word, element_value (ae));
+		remove_array_element (ae, a);
+	    }
+	}
+	break;
+
+    default:
+	builtin_error ("no action was taken... typo?");
+	return (EX_BADUSAGE);
+    }
+
+    return (EXECUTION_SUCCESS);
+}
+#endif	/* ARRAY_VARS */
+
+
+int
+pp_stack_builtin (list)
+     WORD_LIST *list;
+{
+    int opt, shiftn;
+    SHELL_VAR *var;
+    enum stack_flag flag;
+    WORD_LIST *p;
+
+    flag = -1;
+    if (this_command_name) {
+	if (0) ;
+	else if (STREQ (this_command_name, "pp_append")) flag = append_flag;
+	else if (STREQ (this_command_name, "pp_collapse")) flag = collapse_flag;
+	else if (STREQ (this_command_name, "pp_prune")) flag = prune_flag;
+	else if (STREQ (this_command_name, "pp_flip")) flag = flip_flag;
+	else if (STREQ (this_command_name, "pp_overwrite")) flag = overwrite_flag;
+	else if (STREQ (this_command_name, "pp_pop")) flag = pop_flag;
+	else if (STREQ (this_command_name, "pp_push")) flag = push_flag;
+	else if (STREQ (this_command_name, "pp_read")) flag = read_flag;
+	else if (STREQ (this_command_name, "pp_rotateleft")) flag = rotateleft_flag;
+	else if (STREQ (this_command_name, "pp_rotateright")) flag = rotateright_flag;
+	else if (STREQ (this_command_name, "pp_set")) flag = set_flag;
+	else if (STREQ (this_command_name, "pp_sort")) flag = sort_flag;
+	else if (STREQ (this_command_name, "pp_swap")) flag = swap_flag;
+	else if (STREQ (this_command_name, "pp_transpose")) flag = transpose_flag;
+	else if (STREQ (this_command_name, "pp_trim")) flag = trim_flag;
+	else if (STREQ (this_command_name, "pp_uniq")) flag = uniq_flag;
+	else {
+	    builtin_usage ();
+	    return (EX_BADUSAGE);
+	}
+    }
+
+    var = (SHELL_VAR *)NULL;
+    shiftn = 0;
+    uniq_options = 0;
+
+    reset_internal_getopt ();
+    while ((opt = internal_getopt (list, "a:Ddui")) != -1) {
+	switch (opt) {
+#if defined (ARRAY_VARS)
+	case 'a':
+	    var = name_to_arrayvar (list_optarg, 1 /* check_readonly */);
+	    if (var == 0)
+		return (EXECUTION_FAILURE);
+	    break;
+#endif
+	case 'D':
+	    uniq_options |= WANT_ALL_DUPLICATES;
+	    break;
+	case 'd':
+	    uniq_options |= WANT_DUPLICATE;
+	    break;
+	case 'u':
+	    uniq_options |= WANT_UNIQUE;
+	    break;
+	case 'i':
+	    uniq_options |= WANT_CASELESS;
+	    break;
+
+	default:
+	    builtin_usage ();
+	    return (EX_BADUSAGE);
+	}
+    }
+    list = loptend;		/* skip over possible `--' */
+
+    switch (flag) {
+    case pop_flag:              /* takes 0 or 1 argument */
+    case trim_flag:
+    case rotateleft_flag:
+    case rotateright_flag:
+	if (list && list->next) {
+	    builtin_usage ();
+	    return (EX_BADUSAGE);
+	}
+	shiftn = 1;
+	if (list && ! legal_positive_integer (list->word->word, &shiftn)) {
+	    sh_invalidnum (list->word->word);
+	    return (EXECUTION_FAILURE);
+	}
+        break;
+
+    case push_flag:             /* takes 1 or more arguments */
+    case append_flag:
+    case set_flag:
+    case overwrite_flag:
+    case read_flag:
+	if (list == 0) {
+	    builtin_usage ();
+	    return (EX_BADUSAGE);
+	}
+	if (flag == read_flag) {	/* Also, check variable names */
+	    for (p = list; p; p = p->next) {
+		if (legal_identifier (p->word->word) == 0) {
+		    sh_invalidid (p->word->word);
+		    return (EXECUTION_FAILURE);
+		}
+	    }
+	}
+	break;
+
+    case swap_flag:             /* takes no argument */
+    case flip_flag:
+    case sort_flag:
+    case uniq_flag:
+    case collapse_flag:
+    case prune_flag:
+	if (list) {
+	    builtin_usage ();
+	    return (EX_BADUSAGE);
+	}
+	break;
+
+    case transpose_flag:	/* takes 1 argument */
+	if (list == 0 || list->next) {
+	    builtin_usage ();
+	    return (EX_BADUSAGE);
+	}
+	if (! legal_positive_integer (list->word->word, &shiftn)) {
+	    sh_invalidnum (list->word->word);
+	    return (EXECUTION_FAILURE);
+	}
+	break;
+
+    default:
+	builtin_usage ();
+	return (EX_BADUSAGE);
+    }
+
+#if defined (ARRAY_VARS)
+    if (var)
+	return stack_array_internal (var, flag, list, shiftn);
+    else
+#endif
+	return stack_parameter_internal (flag, list, shiftn);
+}
+
+
+char *pp_pop_doc[] = {
+    "Delete first N (default 1) positional parameters or array elements.  It",
+    "returns error, if parameter or array is empty.  Unlike positional",
+    "parameter, array indexes are not changed.",
+    (char *)NULL
+};
+struct builtin pp_pop_struct = {
+    "pp_pop", pp_stack_builtin, BUILTIN_ENABLED, pp_pop_doc,
+    "pp_pop [-a array] [n]",
+    (char *)NULL
+};
+
+
+char *pp_trim_doc[] = {
+    "Delete last N (default 1) positional parameters or array elements.  It",
+    "returns error, if parameter or array is empty.",
+    (char *)NULL
+};
+struct builtin pp_trim_struct = {
+    "pp_trim", pp_stack_builtin, BUILTIN_ENABLED, pp_trim_doc,
+    "pp_trim [-a array] [n]",
+    (char *)NULL
+};
+
+
+char *pp_push_doc[] = {
+    "Insert arguments at the beginning of positional parameters or array.",
+    (char *)NULL
+};
+struct builtin pp_push_struct = {
+    "pp_push", pp_stack_builtin, BUILTIN_ENABLED, pp_push_doc,
+    "pp_push [-a array] arg...",
+    (char *)NULL
+};
+
+
+char *pp_append_doc[] = {
+    "Append arguments at the end of positional parameters or array.",
+    (char *)NULL
+};
+struct builtin pp_append_struct = {
+    "pp_append", pp_stack_builtin, BUILTIN_ENABLED, pp_append_doc,
+    "pp_append [-a array] arg...",
+    (char *)NULL
+};
+
+
+char *pp_swap_doc[] = {
+    "Swap first 2 parameters (ie. $1, $2) or array elements.  It returns error,",
+    "if parameter or array does not have at least 2 items to swap.",
+    (char *)NULL
+};
+struct builtin pp_swap_struct = {
+    "pp_swap", pp_stack_builtin, BUILTIN_ENABLED, pp_swap_doc,
+    "pp_swap [-a array]",
+    (char *)NULL
+};
+
+
+char *pp_set_doc[] = {
+    "Set arguments as new positional parameters or array.  Equivalent to",
+    "    set arg...",
+    "    set -A array arg...         (Ksh)",
+    (char *)NULL
+};
+struct builtin pp_set_struct = {
+    "pp_set", pp_stack_builtin, BUILTIN_ENABLED, pp_set_doc,
+    "pp_set [-a array] arg...",
+    (char *)NULL
+};
+
+
+char *pp_overwrite_doc[] = {
+    "Overwrite in-place.  For array, it's equivalent to",
+    "    set +A array arg...         (Ksh)",
+    (char *)NULL
+};
+struct builtin pp_overwrite_struct = {
+    "pp_overwrite", pp_stack_builtin, BUILTIN_ENABLED, pp_overwrite_doc,
+    "pp_overwrite [-a array] arg...",
+    (char *)NULL
+};
+
+
+char *pp_rotateleft_doc[] = {
+    "Rotate N (default 1) positional parameters or array elements to the left.",
+    (char *)NULL
+};
+struct builtin pp_rotateleft_struct = {
+    "pp_rotateleft", pp_stack_builtin, BUILTIN_ENABLED, pp_rotateleft_doc,
+    "pp_rotateleft [-a array] [n]",
+    (char *)NULL
+};
+
+
+char *pp_rotateright_doc[] = {
+    "Rotate N (default 1) positional parameters or array elements to the right.",
+    (char *)NULL
+};
+struct builtin pp_rotateright_struct = {
+    "pp_rotateright", pp_stack_builtin, BUILTIN_ENABLED, pp_rotateright_doc,
+    "pp_rotateright [-a array] [n]",
+    (char *)NULL
+};
+
+
+char *pp_flip_doc[] = {
+    "Flip the order of positional parameters or array elements.",
+    (char *)NULL
+};
+struct builtin pp_flip_struct = {
+    "pp_flip", pp_stack_builtin, BUILTIN_ENABLED, pp_flip_doc,
+    "pp_flip [-a array]",
+    (char *)NULL
+};
+
+
+char *pp_transpose_doc[] = {
+    "Transpose positional parameters or array representing matrix ordered by",
+    "rows into a sequence that is ordered by columns.  N is the size of row.",
+    "For example, given a sequence",
+    "    (1 2 3 4 a b c d)",
+    "representing 2x4 array with 2 rows (1 2 3 4) and (a b c d),",
+    "    pp_transpose 4",
+    "will produce",
+    "    (1 a 2 b 3 c 4 d)",
+    "representing 4x2 array with 4 rows (1 a), (2 b), (3 c), and (4 d).  To get",
+    "back the original sequence,",
+    "    pp_transpose 2",
+    (char *)NULL
+};
+struct builtin pp_transpose_struct = {
+    "pp_transpose", pp_stack_builtin, BUILTIN_ENABLED, pp_transpose_doc,
+    "pp_transpose [-a array] n",
+    (char *)NULL
+};
+
+
+char *pp_sort_doc[] = {
+    "Sort positional parameters or array, in ascending order.  If array is",
+    "integer type, then numerical sorting is done.",
+    (char *)NULL
+};
+struct builtin pp_sort_struct = {
+    "pp_sort", pp_stack_builtin, BUILTIN_ENABLED, pp_sort_doc,
+    "pp_sort [-a array]",
+    (char *)NULL
+};
+
+
+char *pp_uniq_doc[] = {
+    "Remove duplicate items from already sorted list.  This builtin takes",
+    "additional -[Ddui] options, similar to 'uniq' command:",
+    "    -D      return all duplicates (ie. remove all unique items)",
+    "    -d      return only duplicates",
+    "    -u      return only uniques (ie. remove all duplicate items)",
+    "    -i      do caseless comparison",
+    (char *)NULL
+};
+struct builtin pp_uniq_struct = {
+    "pp_uniq", pp_stack_builtin, BUILTIN_ENABLED, pp_uniq_doc,
+    "pp_uniq [-a array] [-Ddui]",
+    (char *)NULL
+};
+
+
+char *pp_read_doc[] = {
+    "Pop the positional parameters or array elements, and assign them into",
+    "variables.  If there is shortage of items, then '' (null) is assigned to",
+    "the leftover variables.  If list is empty to begin with, then it returns",
+    "error.",
+    (char *)NULL
+};
+struct builtin pp_read_struct = {
+    "pp_read", pp_stack_builtin, BUILTIN_ENABLED, pp_read_doc,
+    "pp_read [-a array] name...",
+    (char *)NULL
+};
+
+
+char *pp_collapse_doc[] = {
+    "Remove empty (null) items, and re-index array starting at 0.",
+    (char *)NULL
+};
+struct builtin pp_collapse_struct = {
+    "pp_collapse", pp_stack_builtin, BUILTIN_ENABLED, pp_collapse_doc,
+    "pp_collapse [-a array]",
+    (char *)NULL
+};
+
+
+char *pp_prune_doc[] = {
+    "Remove empty (null) items, but preserve array index.",
+    (char *)NULL
+};
+struct builtin pp_prune_struct = {
+    "pp_prune", pp_stack_builtin, BUILTIN_ENABLED, pp_prune_doc,
+    "pp_prune [-a array]",
+    (char *)NULL
+};
--- bash-3.2_orig/examples/loadables/william/string.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/string.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,332 @@
+/*******************************************************************************
+ * strcat var < file		--> var += `< file`
+ * strcat var string		--> var += string
+ * strcat var string a:b	--> var += string[a:b]
+ *
+ * strcpy var < file		--> var = `< file`
+ * strcpy var string		--> var = string
+ * strcpy var string a:b	--> var = string[a:b]
+ * 
+ * strlen string...		--> strlen(string), ...
+ *
+ * strcmp string1 string2	--> string1 == string2
+ * strcmp string1 string2 a:b	--> string1[a:b] == string2[a:b]
+ *
+ * strstr string substring	--> strstr (string, substring)
+ * strspn string accept		--> strspn (string, accept)
+ * strcspn string reject	--> strcspn (string, reject)
+ */
+
+#include "loadables.h"
+
+static int strcpy_engine	__P((WORD_LIST *, int));
+
+ 
+static int
+strcpy_engine (list, o_append)
+    WORD_LIST *list;
+    int o_append;	/* 1=strcat, 0=strcpy */
+{
+    int argc, size, a, b, retval;
+    char *name, *string;
+
+    if (no_options (list))
+	return (EX_BADUSAGE);
+    list = loptend;		/* skip over possible `--' */
+
+    argc = list_length (list);
+    switch (argc) {
+    case 1:
+	name = list->word->word;	list = list->next;
+	string = slurp_fd_into_string (0);
+	break;
+    case 2:
+	name = list->word->word;	list = list->next;
+	string = list->word->word;	list = list->next;
+	break;
+    case 3:
+	name = list->word->word;	list = list->next;
+	string = list->word->word;	list = list->next;
+
+        size = strlen (string);
+	if (! valid_python_range (list->word->word, &a, &b, size))
+	    return (EXECUTION_FAILURE);
+	string[b] = '\0';		/* no need to make a copy */
+	string += a;
+	break;
+    default:
+	builtin_usage ();
+	return (EX_BADUSAGE);
+    }
+
+    /* 'string' is now ready to be copied. */
+
+    retval = EXECUTION_SUCCESS;
+    if (put_string_in (string, name, o_append) < 0) {
+	sh_notfound (name);
+	retval = EXECUTION_FAILURE;
+    }
+
+    if (argc == 1)
+	FREE (string);
+    return (retval);
+}
+
+
+int
+strcpy_builtin (list)
+    WORD_LIST *list;
+{
+    return strcpy_engine (list, 0 /* o_append */);
+}
+
+
+int
+strcat_builtin (list)
+    WORD_LIST *list;
+{
+    return strcpy_engine (list, 1 /* o_append */);
+}
+
+
+int
+strlen_builtin (list)
+    WORD_LIST *list;
+{
+    if (no_options (list))
+	return (EX_BADUSAGE);
+    list = loptend;		/* skip over possible `--' */
+
+    for ( ; list; list = list->next) {
+	printf ("%zd", strlen (list->word->word));	/* size_t */
+	putchar (list->next? ' ': '\n');
+    }
+
+    return (EXECUTION_SUCCESS);
+}
+
+
+int
+strcmp_builtin (list)
+    WORD_LIST *list;
+{
+    int opt, ignorecase, argc, size, a, b;
+    char *string1, *string2;
+
+    ignorecase = 0;
+
+    reset_internal_getopt ();
+    while ((opt = internal_getopt (list, "i")) != -1) {
+	switch (opt) {
+	case 'i': 
+	    ignorecase = 1;
+	    break;
+	default:
+	    builtin_usage ();
+	    return (EX_BADUSAGE);
+	}
+    }
+    list = loptend;		/* skip over possible `--' */
+
+    switch (list_length (list)) {
+    case 2:
+	string1 = list->word->word;	list = list->next;
+	string2 = list->word->word;	list = list->next;
+	break;
+    case 3:
+	string1 = list->word->word;	list = list->next;
+	string2 = list->word->word;	list = list->next;
+
+	size = strlen (string1);
+	if (! valid_python_range (list->word->word, &a, &b, size))
+	    return (EXECUTION_FAILURE);
+	string1[b] = '\0';		/* no need to make a copy */
+	string1 += a;
+
+	size = strlen (string2);
+	if (! valid_python_range (list->word->word, &a, &b, size))
+	    return (EXECUTION_FAILURE);
+	string2[b] = '\0';		/* no need to make a copy */
+	string2 += a;
+	break;
+    default:
+	builtin_usage ();
+	return (EX_BADUSAGE);
+    }
+
+    if (ignorecase)
+	return (strcasecmp (string1, string2) == 0 ? EXECUTION_SUCCESS : EXECUTION_FAILURE);
+    else
+	return (strcmp (string1, string2) == 0 ? EXECUTION_SUCCESS : EXECUTION_FAILURE);
+}
+
+
+int
+strstr_builtin (list)
+    WORD_LIST *list;
+{
+    if (no_options (list))
+	return (EX_BADUSAGE);
+    list = loptend;		/* skip over possible `--' */
+
+    switch (list_length (list)) {
+    case 2:
+	if (strstr (list->word->word, (list->next)->word->word))
+	    return EXECUTION_SUCCESS;
+	else
+	    return EXECUTION_FAILURE;
+    default:
+	builtin_usage ();
+	return (EX_BADUSAGE);
+    }
+}
+
+
+int
+strspn_builtin (list)
+    WORD_LIST *list;
+{
+    size_t n;
+
+    if (no_options (list))
+	return (EX_BADUSAGE);
+    list = loptend;		/* skip over possible `--' */
+
+    switch (list_length (list)) {
+    case 2:
+	n = strspn (list->word->word, (list->next)->word->word);
+	printf ("%zd\n", n);	/* size_t */
+	return (EXECUTION_SUCCESS);
+    default:
+	builtin_usage ();
+	return (EX_BADUSAGE);
+    }
+}
+
+
+int
+strcspn_builtin (list)
+    WORD_LIST *list;
+{
+    size_t n;
+
+    if (no_options (list))
+	return (EX_BADUSAGE);
+    list = loptend;		/* skip over possible `--' */
+
+    switch (list_length (list)) {
+    case 2:
+	n = strcspn (list->word->word, (list->next)->word->word);
+	printf ("%zd\n", n);	/* size_t */
+	return (EXECUTION_SUCCESS);
+    default:
+	builtin_usage ();
+	return (EX_BADUSAGE);
+    }
+}
+
+
+char *strcat_doc[] = {
+    "Shell version of strcat(3):",
+    "    strcat var < file           --> var += `< file`",
+    "    strcat var string           --> var += string",
+    "    strcat var string a:b       --> var += string[a:b]",
+    "",
+    "Append STRING to shell variable or array element VAR.  VAR is variable",
+    "reference, so don't use $.  If the variable doesn't exist, then it's the",
+    "same as assignment.  If VAR is an integer referring to already existing",
+    "positional parameter, then STRING is appended to $VAR.  ",
+    "",
+    "If STRING argument is missing, then stdin will be read for input.  If",
+    "Python-style A:B range is given, then use substring starting at A and",
+    "ending at B-1.  A or B can be negative or absent, with the usual meaning.",
+    (char *)NULL
+};
+struct builtin strcat_struct = {
+    "strcat", strcat_builtin, BUILTIN_ENABLED, strcat_doc,
+    "strcat var [string [a:b] | < file]",
+    (char *)NULL
+};
+
+
+char *strcpy_doc[] = {
+    "Shell version of strcpy(3):",
+    "    strcpy var < file           --> var = `< file`",
+    "    strcpy var string           --> var = string",
+    "    strcpy var string a:b       --> var = string[a:b]",
+    "",
+    "Assign STRING to shell variable or array element VAR.  VAR is variable",
+    "reference, so don't use $.  If VAR is an integer referring to already",
+    "existing positional parameter, then STRING is set to $VAR.",
+    "",
+    "If STRING argument is missing, then stdin will be read for input.  If",
+    "Python-style A:B range is given, then use substring starting at A and",
+    "ending at B-1.  A or B can be negative or absent, with the usual meaning.",
+    (char *)NULL
+};
+struct builtin strcpy_struct = {
+    "strcpy", strcpy_builtin, BUILTIN_ENABLED, strcpy_doc,
+    "strcpy var [string [a:b] | < file]",
+    (char *)NULL
+};
+
+
+char *strlen_doc[] = {
+    "Shell version of strlen(3).",
+    (char *)NULL
+};
+struct builtin strlen_struct = {
+    "strlen", strlen_builtin, BUILTIN_ENABLED, strlen_doc,
+    "strlen string...",
+    (char *)NULL
+};
+
+
+char *strcmp_doc[] = {
+    "Shell version of strcmp(3):",
+    "    strcmp string1 string2          --> string1 == string2",
+    "    strcmp string1 string2 a:b      --> string1[a:b] == string2[a:b]",
+    "",
+    "Compare STRING1 and STRING2, ignoring case if -i option is specified.  If",
+    "Python-style A:B range is given, then use substrings starting at A and",
+    "ending at B-1.  A or B can be negative or absent, with the usual meaning.",
+    (char *)NULL
+};
+struct builtin strcmp_struct = {
+    "strcmp", strcmp_builtin, BUILTIN_ENABLED, strcmp_doc,
+    "strcmp [-i] string1 string2 [a:b]",
+    (char *)NULL
+};
+
+
+char *strstr_doc[] = {
+    "Shell version of strstr(3).  Returns success (0) or failure (1).",
+    (char *)NULL
+};
+struct builtin strstr_struct = {
+    "strstr", strstr_builtin, BUILTIN_ENABLED, strstr_doc,
+    "strstr string substring",
+    (char *)NULL
+};
+
+
+char *strspn_doc[] = {
+    "Shell version of strspn(3).  Prints length to stdout.",
+    (char *)NULL
+};
+struct builtin strspn_struct = {
+    "strspn", strspn_builtin, BUILTIN_ENABLED, strspn_doc,
+    "strspn string accept",
+    (char *)NULL
+};
+
+
+char *strcspn_doc[] = {
+    "Shell version of strcspn(3).  Prints length to stdout.",
+    (char *)NULL
+};
+struct builtin strcspn_struct = {
+    "strcspn", strcspn_builtin, BUILTIN_ENABLED, strcspn_doc,
+    "strcspn string reject",
+    (char *)NULL
+};
--- bash-3.2_orig/examples/loadables/william/strinterval.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/strinterval.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,93 @@
+/*******************************************************************************
+ * Extract substring, delimited by BEGIN and END patterns.
+ */
+
+#include "loadables.h"
+
+
+int
+strinterval_builtin (list)
+     WORD_LIST *list;
+{
+    char *head, *begin, *end, *submatch;
+    int opt, flag;
+    SHELL_VAR *var;
+    WORD_LIST *p;
+
+    flag = 0;
+
+    reset_internal_getopt ();
+    while ((opt = internal_getopt (list, "r")) != -1) {
+	switch (opt) {
+#if defined (HAVE_POSIX_REGEXP)
+	case 'r':
+	    flag = opt;
+	    break;
+#endif
+	default:
+	    builtin_usage ();
+	    return (EX_BADUSAGE);
+	}
+    }
+    list = loptend;		/* skip over possible `--' */
+
+    switch (list_length (list)) {
+    case 3:
+        head = list->word->word;	list = list->next;
+        begin = list->word->word;	list = list->next;
+	end = list->word->word;		list = list->next;
+        submatch = (char *)NULL;
+	var = (SHELL_VAR *)NULL;
+        break;
+    case 4:
+        head = list->word->word;	list = list->next;
+        begin = list->word->word;	list = list->next;
+	end = list->word->word;		list = list->next;
+        submatch = list->word->word;
+#if defined (ARRAY_VARS)
+	var = force_name_to_arrayvar (submatch, 1);
+	if (var == 0)
+	    return (EXECUTION_FAILURE);
+#endif
+        break;
+    default:
+        builtin_usage ();
+        return (EX_BADUSAGE);
+    }
+
+    p = (WORD_LIST *)NULL;
+
+    if (flag == 'r') {
+#if defined (HAVE_POSIX_REGEXP)
+	p = regex_interval_match_list (head, begin, end);
+#endif
+    } else {
+	p = string_interval_match_list (head, begin, end);
+    }
+
+    if (p == 0)
+	return (EXECUTION_FAILURE);
+
+    for ( ; p && var; p = p->next)
+	arrayvar_append (var, p->word->word);
+    dispose_words (p);
+    return (EXECUTION_SUCCESS);
+}
+
+
+char *strinterval_doc[] = {
+    "Extract substring, delimited by non-overlapping BEGIN and END patterns.  By",
+    "default, the patterns are simple string, but regex(7) pattern can be used",
+    "with -r option.  Returns success (0) if patterns are found, or failure (1)",
+    "if patterns are not found.  When patterns are found, there are 5 segments",
+    "to consider:",
+    "    string  -->  submatch=( prefix BEGIN middle END suffix )",
+    "All 5 segments are returned in array variable SUBMATCH (if given) which is",
+    "always flushed first.",
+    (char *)NULL
+};
+struct builtin strinterval_struct = {
+    "strinterval", strinterval_builtin, BUILTIN_ENABLED, strinterval_doc,
+    "strinterval [-r] string begin end [submatch]",
+    (char *)NULL
+};
--- bash-3.2_orig/examples/loadables/william/subroutines.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/subroutines.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,2315 @@
+/*******************************************************************************
+ * Subroutines needed by my patch to main core and builtins.  These files are
+ * identical and should be hard linked:
+ *	builtins/subroutines.[ch]
+ *	examples/loadables/william/subroutines.[ch]
+ */
+
+#include <config.h>
+
+#if defined (HAVE_UNISTD_H)
+#  ifdef _MINIX
+#    include <sys/types.h>
+#  endif
+#  include <unistd.h>
+#endif
+
+#include <stdio.h>		/* puts(), printf(), BUFSIZ, ... */
+#include <errno.h>		/* legal_number_with_base() */
+
+#include "shell.h"		/* includes lots of headers */
+#include "bashansi.h"		/* string.h, strings.h, stdlib.h */
+#include "common.h"		/* builtin_error(), ... */
+#include "chartypes.h"		/* ISSPACE(), TOUPPER(), TOLOWER(), ... */
+#include "filecntl.h"		/* open() */
+#include "posixstat.h"		/* open() */
+
+#include "subroutines.h"
+
+
+/*******************************************************************************
+ * Variables */
+
+
+SHELL_VAR *
+bind_variable_if_legal (name, value)
+    char *name, *value;
+{
+    if (! legal_identifier (name)) {
+	sh_invalidid (name);
+	return (SHELL_VAR *)NULL;
+    }
+
+    return (bind_variable (name, value));
+}
+
+
+/* Return pointer to the content of string variables, ie. positional parameter,
+ * ordinary shell variable, array element.
+ */
+char *
+get_pointer_to (name)
+    char *name;
+{
+    char *t, **ref;
+    intmax_t i;
+
+    if (name == 0 || *name == 0)
+        return (char *)NULL;
+
+    t = (char *)NULL;
+
+    /* positional parameter */
+    if (legal_number (name, &i) && i >= 0 && (ref = get_parameter_reference (i))) {
+        t = *ref;
+    }
+    /* shell/array variable */
+    else if (legal_identifier (name)) {
+        t = get_string_value (name);
+    }
+    /* array element */
+    else if (valid_array_reference (name)) {
+        t = get_array_value (name, 0 /* allow_all */, (int *)NULL /* rtype */);
+    }
+
+    return (t);
+}
+
+
+/* Copy STRING into string variable, ie. positional parameter, ordinary shell
+ * variable, array element.   If APPEND is true, then append to the end of
+ * string, instead of replacing.  Return 0 on success, or -1 on error.
+ */
+int
+put_string_in (string, name, o_append)
+    char *string, *name;
+    int o_append;
+{
+    SHELL_VAR *var;
+    char *t, **ref;
+    intmax_t i;
+
+    if (name == 0 || *name == 0)
+        return (-1);
+
+    if (string == 0)
+	string = "";
+
+    var = (SHELL_VAR *)NULL;
+    ref = (char **)NULL;
+
+    /* positional parameter */
+    if (legal_number (name, &i) && i >= 0 && (ref = get_parameter_reference (i))) {
+        if (o_append) {
+            t = string_add (savestring (*ref), string);
+            FREE (*ref);
+            *ref = t;
+        } else {
+            FREE (*ref);
+            *ref = savestring (string);
+        }
+    }
+    /* shell/array variable */
+    else if (legal_identifier (name)) {
+        if (o_append) {
+            t = get_string_value (name);
+            if (t == 0)
+                t = "";
+            t = string_add (savestring (t), string);
+            var = bind_variable (name, t);
+            FREE (t);
+        } else {
+            var = bind_variable (name, string);
+        }
+    }
+    /* array element */
+    else if (valid_array_reference (name)) {
+        if (o_append) {
+            t = get_array_value (name, 0 /* allow_all */, (int *)NULL /* rtype */);
+            if (t == 0)
+                t = "";
+            t = string_add (savestring (t), string);
+            var = assign_array_element (name, t);
+            FREE (t);
+        } else {
+            var = assign_array_element (name, string);
+        }
+    }
+
+    if (var && readonly_p (var) == 0 && noassign_p (var) == 0) {
+        stupidly_hack_special_variables (name);
+    }
+
+    return (var || ref)? 0: -1;
+}
+
+
+/*******************************************************************************
+ * Numbers */
+
+
+/* Return success (1) if string or integer is 
+ *	- not NULL,
+ *	- not empty -- not really needed because legal_number() fails.
+ *	- positive (>= 0),
+ *	- within manageable size.
+ *
+ * The successfully converted integer is returned in N, if it's not NULL.  If
+ * tests fails, then return 0, and don't modify N even if it's not NULL.
+ */
+int
+legal_positive_integer (arg, n)
+    char *arg;
+    int *n;
+{
+    intmax_t x;
+
+    if (arg && *arg && legal_number (arg, &x) && x >= 0 && x == (int)x) {
+	if (n)
+	    *n = (int)x;
+	return (1);	/* success */
+    }
+    return (0);
+}
+
+
+/* Same as legal_positive_integer(), but can be negative.
+ */
+int
+legal_integer (arg, n)
+    char *arg;
+    int *n;
+{
+    intmax_t x;
+
+    if (arg && *arg && legal_number (arg, &x) && x == (int)x) {
+	if (n)
+	    *n = (int)x;
+	return (1);	/* success */
+    }
+    return (0);
+}
+
+
+/* Modified version of legal_number(), with option for base other than 10.
+ */
+int
+legal_number_with_base (string, result, base)
+    char *string;
+    intmax_t *result;
+    int base;
+{
+    intmax_t value;
+    char *ep;
+
+    if (result)
+	*result = 0;
+
+    errno = 0;
+    value = strtoimax (string, &ep, base /* was 10 */);
+    if (errno)
+	return 0;	/* errno is set on overflow or underflow */
+
+    /* Skip any trailing whitespace, since strtoimax does not. */
+    while (whitespace (*ep))
+	ep++;
+
+    /* If *string is not '\0' but *ep is '\0' on return, the entire string
+       is valid. */
+    if (string && *string && *ep == '\0')
+    {
+	if (result)
+	    *result = value;
+	/* The SunOS4 implementation of strtol() will happily ignore
+	   overflow conditions, so this cannot do overflow correctly
+	   on those systems. */
+	return 1;
+    }
+
+    return (0);
+}
+
+
+/* Modified version of legal_integer(), with option for base other than 10.
+ */
+int
+legal_integer_with_base (arg, n, base)
+    char *arg;
+    int *n, base;
+{
+    intmax_t x;
+
+    if (arg && *arg && legal_number_with_base (arg, &x, base) && x == (int)x) {
+	if (n)
+	    *n = (int)x;
+	return (1);	/* success */
+    }
+    return (0);
+}
+
+
+/* Integer version of fmax() and fmin().  Using function instead of #define,
+ * in case 'a' and 'b' need to be evaluated only once.
+ */
+int
+imax (a, b)
+    int a, b;
+{
+    return ((a > b) ? a : b);
+}
+int
+imin (a, b)
+    int a, b;
+{
+    return ((a < b) ? a : b);
+}
+
+
+/* Adjust Python-style [a:b] range to sensible values:
+ *	0 <= a <= b <= size
+ */
+void
+adjust_python_range (a, b, size)
+    int *a, *b, size;
+{
+    if (*a < 0) *a += size;
+    if (*a < 0) *a = 0;
+    if (*a > size) *a = size;
+
+    if (b) {
+	if (*b < 0) *b += size;
+	if (*b < 0) *b = 0;
+	if (*b > size) *b = size;
+	if (*b < *a) *b = *a;
+    }
+}
+
+
+/* Extract 'a' and 'b' from Python-style 'a:b' range.  Here, 'a' and 'b' must be
+ * integers, not arithmetic expressions as in parse_colon_range().  If you need
+ * arithmetic expression, then do something like
+ *	$((...)):$((...))
+ * If the range is well-formed, then return 1; otherwise, return 0.  If A and B
+ * are not NULL, then place the converted numbers there.
+ */
+int
+valid_python_range (range, pa, pb, size)
+    char *range;
+    int *pa, *pb, size;
+{
+    char *t;
+    int a, b;
+
+    t = xstrchr (range, ':');
+    if (t == 0) {
+	builtin_error ("`%s': expected a:b range", range);
+	return (0);
+    }
+
+    *t = '\0';
+    a = 0;
+    if (*range && ! legal_integer (range, &a)) {
+	sh_invalidnum (range);
+	return (0);
+    }
+
+    *t++ = ':';
+    b = size;
+    if (*t && ! legal_integer (t, &b)) {
+	sh_invalidnum (t);
+	return (0);
+    }
+
+    adjust_python_range (&a, &b, size);
+    if (pa) *pa = a;
+    if (pb) *pb = b;
+    return (1);		/* is valid */
+}
+
+
+/* Convert to cent, rounding any fractional cent.  Exactly 0.5 is rounded to the
+ * nearest even integer, like rint(3) or nearbyint(3).  Returns string
+ * representation of integer.  If there is error, it returns "0".
+ */
+char *
+convert_to_cent (val)
+    char *val;
+{
+    char *out, *t;
+    intmax_t x, y;
+    int sign;
+
+    x = y = 0;
+
+    out = strip_leading_trailing (val, STRIP_LR);
+    if (*out == '-') {
+	sign = -1;
+	*out = '0';	/* suppress +/- */
+    } else if (*out == '+') {
+	sign = 1;
+	*out = '0';	/* suppress +/- */
+    } else {
+	sign = 1;
+    }
+
+    t = strchr (out, '.');
+    if (t) {		/* out[].t[] --> dollar.cent */
+	*t++ = '\0';
+	if (all_digits (t) && (*out == '\0' || legal_number (out, &x))) {
+	    /* Got dollar 'x'.  Now, get cent 'y'. */
+	    if (t[0]) {
+		y = 10 * TODIGIT (t[0]);
+		if (t[1]) {	
+		    y += TODIGIT (t[1]);
+		    if (t[2]) {		/* see if cent needs to be rounded up */
+			if (t[2] >= '6' && t[2] <= '9') {
+			    y++;
+			} else if (t[2] == '5') {
+			    if (strpbrk (t + 3, "123456789"))
+				y++;	/* if greater than 0.5 */
+			    else if (TODIGIT (t[1]) % 2)
+				y++;	/* if 0.5 exactly, round up to next even integer */
+			}
+		    }
+		}
+	    }
+	} else {
+	    builtin_error ("`%s': invalid dollar amount", val);
+	}
+    } else {		/* already in cent.  Check for valid range. */
+	if (*out == '\0' || legal_number (out, &y)) {
+	} else {
+	    builtin_error ("`%s': invalid dollar amount", val);
+	}
+    }
+    FREE (out);
+    x = 100 * x + y;
+    if (sign < 0)
+	x = -x;
+    return (itos (x));
+}
+
+
+/* Convert to dollar.cent (%.2f) format.
+ */
+char *
+convert_to_dollar (val)
+    char *val;
+{
+    char *out;
+    int size;
+    intmax_t x, y;
+
+    out = convert_to_cent (val);	/* convert to cent, first */
+    size = strlen (out);
+
+    if (legal_number (out, &x)) {
+	out = (char *)xrealloc (out, size + 5);		/* minimum of "0.00" */
+	if (x < 0) {
+	    y = -x % 100;
+	    x = -x / 100;
+	    snprintf (out, size + 5, "-%jd.%02jd", x, y);
+	} else {
+	    y = x % 100;
+	    x = x / 100;
+	    snprintf (out, size + 5, "%jd.%02jd", x, y);
+	}
+	out[size + 4] = '\0';	/* just in case */
+    } else {
+	*out = '\0';
+	builtin_error ("`%s': invalid dollar amount", val);
+    }
+    return (out);
+}
+
+
+/* Convert from IN base to OUT base format, where IN base is 0 or [2,36] and OUT
+ * base is [2,36].
+ */
+char *
+convert_to_base36 (val, inbase, outbase)
+    char *val;
+    int inbase, outbase;
+{
+    uintmax_t xx;
+    int i, size;
+    char c, *t, *out;
+    char hex_map[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
+
+    if (inbase < 0 || inbase == 1 || inbase > 36 || outbase < 2 || outbase > 36)
+	return (char *)NULL;
+
+    if (! legal_number_with_base (val, &xx, inbase)) {
+	sh_invalidnum (val);
+	return (char *)NULL;
+    }
+
+    /* Read the bits from right to left.  Then, flip the pattern. */
+    t = out = (char *)xmalloc (8 * sizeof(uintmax_t) + 1);
+    do {
+	*t++ = hex_map[xx % outbase];
+	xx /= outbase;
+    } while (xx > 0);
+    *t = '\0';
+
+    size = t - out;
+    for (i = 0; i < size / 2; i++) {
+	c = out[i];
+	out[i] = out[size - 1 - i];
+	out[size - 1 - i] = c;
+    }
+    return (out);
+}
+
+
+/*******************************************************************************
+ * String */
+
+
+int
+count_in_string (c, s)		/* Count number of char in string. */
+    char c, *s;
+{
+    int n;
+
+    n = 0;
+    for ( ; *s; s++)
+	if (*s == c) 
+	    n++;
+    return (n);
+}
+
+
+/* Return string
+ *	command 'arg'
+ * which can be used as command substitution.  ARG is single quoted for another
+ * pass through shell, just like sh_single_quote(), but more conservative in
+ * memory allocation.  If ARG, is NULL, then empty string '' is used instead.
+ *
+ * It returns resized 'command' which is concatenated with the new ARG,
+ * separated by a space.  So, pass only a copy as 'command'.
+ */
+char *
+build_eval_string (command, arg)
+    char *command, *arg;
+{
+    char *eval_string, *t; 
+    size_t size, n;
+
+    if (arg == 0)
+	arg = "";
+
+    /* Each single quote (') becomes 4 chars ('\'').  Plus, two quotes at the
+     * beginning and the end.  So,
+     *	    ab'cd
+     * becomes 
+     *	    'ab'\''cd'
+     */
+    n = strlen(arg) + 3 * count_in_string ('\'', arg) + 2;
+    size = strlen (command);
+    eval_string = (char *)xrealloc (command, size + 1 + n + 1);
+
+    t = eval_string + size;
+    *t++ = ' ';
+    *t++ = '\'';
+    for ( ; *arg; arg++) {
+	*t++ = *arg;
+	if (*arg == '\'') {
+	    *t++ = '\\';
+	    *t++ = '\'';
+	    *t++ = '\'';	/* begin new quote */
+	}
+    }
+    *t++ = '\'';
+    *t = '\0';
+    return (eval_string);
+}
+
+
+/* Same as build_eval_string() above, but using substring(arg,a,b).
+ */
+char *
+build_eval_substring (command, arg, a, b)
+    char *command, *arg;
+    int a, b;
+{
+    char c, *out, *t;
+
+    t = substring (arg, a, b);
+    out = build_eval_string (command, t);
+    FREE (t);
+    return (out);
+}
+
+
+/* Run 
+ *	`command 'arg'`
+ * as command substitution, and return the output string which can be NULL.
+ * ARG is single quoted for another pass through shell.
+ */
+char *
+replace_string (command, arg)
+    char *command, *arg;
+{
+    char *out, *t; 
+
+    t = build_eval_string (savestring (command), arg);
+    out = command_substitute (t, 0);
+    FREE (t);
+    return (out);
+}
+
+
+/* Same as replace_string() above, but using substring(arg,a,b).
+ */
+char *
+replace_substring (command, arg, a, b)
+    char *command, *arg;
+    int a, b;
+{
+    char *out, *t; 
+
+    t = build_eval_substring (savestring (command), arg, a, b);
+    out = command_substitute (t, 0);
+    FREE (t);
+    return (out);
+}
+
+
+char *
+rotate_string (val, n)		/* +n=left, -n=right */
+    char *val;
+    int n;
+{
+    int i, size;
+    char *out;
+
+    size = strlen (val);
+    out = (char *)xmalloc (size + 1);
+
+    if (n >= 0) {
+	for (i = 0; i < size; i++)
+	    out[i] = val[(i + n) % size];
+    } else {
+	n = abs (n);
+	for (i = 0; i < size; i++)
+	    out[(i + n) % size] = val[i];
+    }
+    out[size] = '\0';
+    return (out);
+}
+
+
+/* Find comma in CSV string.  Skip over double quotes ("...").  Two
+ * consecutive double quotes ("") are quoted double-quote, but, for the purpose
+ * of splitting, it doesn't matter.  If no comma is found, then return NULL.
+ */
+char *
+next_comma_in_csv (csv)
+    char *csv;
+{
+    char *t;
+    int inside;
+
+    inside = 0;
+
+    for (t = csv; *t; t++) {
+	switch (*t) {
+	case '"':
+	    inside = (inside? 0: 1);	/* toggle */
+	    break;
+	case ',':
+	    if (! inside)	/* outside of "...", so return */
+		return (t);
+	    break;
+	}
+    }
+    return (char *)NULL;
+}
+
+
+/* Prepend substring(head, a, b) to WORD_LIST.
+ */
+WORD_LIST *
+prepend_substring_to_list (head, a, b, list)
+    char *head;
+    int a, b;		/* a <= b */
+    WORD_LIST *list;
+{
+    char c;
+
+    if (a <= b) {	/* if a > b, do nothing */
+	c = head[b];
+	head[b] = '\0';
+	list = make_word_list (make_bare_word (head + a), list);
+	head[b] = c;
+    }
+    return (list);
+}
+
+
+/* Split string on SEP separator, and return WORD_LIST.  If SEP is empty, then
+ * treat the string as CSV string, and split on unquoted comma.  It returns
+ * NULL, if string is NULL or empty (ie. nothing to split).
+ */
+WORD_LIST *
+string_minus_separator (head, sep)
+    char *head, *sep;
+{
+    char *body;
+    WORD_LIST *list;
+    int n;
+
+    if (head == 0 || *head == '\0' || sep == 0)
+	return (WORD_LIST *)NULL;
+
+    list = (WORD_LIST *)NULL;
+
+    n = strlen (sep);
+    if (n > 0) {
+	while (*head && (body = strstr (head, sep))) {
+	    list = prepend_substring_to_list (head, 0, body - head, list);
+	    head = body + n;
+	}
+    } else {		/* CSV string */
+	while (*head && (body = next_comma_in_csv (head))) {
+	    list = prepend_substring_to_list (head, 0, body - head, list);
+	    head = body + 1;
+	}
+    }
+    list = make_word_list (make_bare_word (head), list);
+    list = REVERSE_LIST (list, WORD_LIST *);
+    return (list);
+}
+
+
+/* Split string on BEGIN and END separators, and return WORD_LIST.  If separator
+ * is NULL or empty, then no splitting is done.  It returns NULL, if string is
+ * NULL or empty (ie. nothing to split).
+ */
+WORD_LIST *
+string_plusminus_begin_end (head, flag, begin, end)
+    char *head, *begin, *end;
+    char flag;		/* '+' or '-' */
+{
+    char *body, *tail;
+    WORD_LIST *list;
+    size_t a, b;
+
+    list = (WORD_LIST *)NULL;
+
+    if (head == 0 || *head == '\0')
+	return (list);
+    if (begin == 0 || *begin == '\0' || end == 0 || *end == '\0') {
+	if (flag != '+')
+	    list = make_word_list (make_bare_word (head), list);
+	return (list);
+    }
+
+    a = strlen (begin);
+    b = strlen (end);
+    while (*head && (body = strstr (head, begin))) {		/* found beginning */
+	body += a;
+	if (*body == '\0' || (tail = strstr (body, end)) == 0)	/* end not found */
+	    break;
+
+	/* ...BEGIN<body>...<tail>END... */
+
+	switch (flag) {
+	case '-':
+	    list = prepend_substring_to_list (head, 0, body - head - a, list);
+	    break;
+	case '+':
+	    list = prepend_substring_to_list (body, 0, tail - body, list);
+	    break;
+	default:		/* append both segments */
+	    list = prepend_substring_to_list (head, 0, body - head - a, list);
+	    list = prepend_substring_to_list (body, 0, tail - body, list);
+	    break;
+	}
+	head = body = tail + b;
+    }
+    if (flag != '+')
+	list = make_word_list (make_bare_word (head), list);
+    list = REVERSE_LIST (list, WORD_LIST *);
+    return (list);
+}
+
+
+/* Read the entire content of file descriptor FD, and return string.  Copied
+ * from read_comsub().  Buffer size of 128 shows up a lot in other places, but
+ * it's too small; use BUFSIZ from <stdio.h>, instead.  Return NULL if file
+ * descriptor is illegal.  Also, returns NULL if there is nothing to read (maybe
+ * should return empty string?).
+ */
+char *
+slurp_fd_into_string (fd)
+    int fd;
+{
+    char *out, buf[BUFSIZ];
+    ssize_t n;
+    int i, size;
+
+    if (sh_validfd (fd) == 0) {		/* taken from 'read' builtin */
+	builtin_error ("%d: invalid file descriptor", fd);
+	return (char *)NULL;
+    }
+
+    out = (char *)NULL;
+    size = i = 0;
+
+    while ((n = zread (fd, buf, sizeof(buf))) > 0) {
+	RESIZE_MALLOCED_BUFFER (out, i, n, size, BUFSIZ);
+	memcpy (out + i, buf, n);	/* don't stop at \0 */
+	i += n;
+    }
+    if (i > 0) {        /* if there is unterminated string */
+        RESIZE_MALLOCED_BUFFER (out, i, 1, size, BUFSIZ);
+        out[i] = '\0';
+    }
+
+    return (out);
+}
+
+
+/* Read the entire content of file FILENAME, and return string.  Copied from
+ * cat_file().  Return NULL if there is error in filename or file descriptor.
+ */
+char *
+slurp_filename_into_string (filename)
+    char *filename;
+{
+    int fd;
+    char *out;
+    struct stat finfo;
+
+    if (filename == 0 || *filename == '\0')
+	return (char *)NULL;
+
+    fd = open (filename, O_RDONLY);
+    if (fd < 0) {
+	file_error (filename);
+	return (char *)NULL;
+    }
+    if (fstat (fd, &finfo) == 0 && S_ISDIR (finfo.st_mode)) {
+        builtin_error ("`%s': trying to read from directory", filename);
+	close (fd);
+        return (char *)NULL;
+    }
+    out = slurp_fd_into_string (fd);
+    close (fd);
+    return (out);
+}
+
+
+/* Write string into file descriptor.  Return number of chars written, or -1 on
+ * error.
+ */
+int
+dump_string_into_fd (s, fd)
+    char *s;
+    int fd;
+{
+    if (s == 0)
+        return (-1);
+
+    if (sh_validfd (fd) == 0) {		/* taken from 'read' builtin */
+	builtin_error ("%d: invalid file descriptor", fd);
+	return (-1);
+    }
+    return (zwrite (fd, s, strlen(s)));
+}
+
+
+/* Write string into filename.  Return number of chars written, or -1 on error.
+ */
+int
+dump_string_into_filename (s, filename, o_append)
+    char *s, *filename;
+    int o_append;	/* 1=append, 0=trunc */
+{
+    int fd, count;
+
+    if (s == 0 || filename == 0 || *filename == '\0')
+	return (-1);
+
+    fd = open (filename, O_CREAT|O_WRONLY|(o_append? O_APPEND: O_TRUNC), 0666);
+    if (fd < 0) {
+	file_error (filename);
+	return (-1);
+    }
+    count = dump_string_into_fd (s, fd);
+    close (fd);
+    return (count);
+}
+
+
+/* Quote string into CSV format.  Essentially, " is doubled (""), and the entire
+ * string is put in "..." if it contains comma, CR, or LF.
+ */
+char *
+csv_quote (val)
+    char *val;
+{
+    char *out, *t;
+    int n, found;
+
+    n = strlen (val) + count_in_string ('"', val) + 2;
+    t = out = (char *)xmalloc (n + 1);
+
+    found = (strpbrk(val, ",\r\n") != (char *)NULL);
+    if (found)
+	*t++ = '"';
+    for ( ; *val; val++) {
+	*t++ = *val;
+	if (*val == '"')
+	    *t++ = '"';
+    }
+    if (found)
+	*t++ = '"';
+    *t = '\0';
+    return (out);
+}
+
+
+/* Dequote string from CSV format.  Essentially, "" is reduced to single ", and
+ * single " is removed.
+ */
+char *
+csv_dequote (val)
+    char *val;
+{
+    char *out, *t;
+
+    t = out = (char *)xmalloc (strlen (val) + 1);
+
+    for ( ; *val; val++) {
+	if (*val != '"')
+	    *t++ = *val;
+	else if (val[1] == '"')
+	    *t++ = *val++;
+    }
+    *t = '\0';
+    return (out);
+}
+
+
+/* Convert %xx to ASCII char, and '+' to space.
+ */
+char *
+url_dequote (val)
+    char *val;
+{
+    char *out, *t;
+
+    t = out = (char *)xmalloc (strlen (val) + 1);
+
+    for ( ; *val; val++) {
+	if (*val == '%' && ISXDIGIT (val[1]) && ISXDIGIT (val[2])) {
+	    *t++ = (HEXVALUE (val[1]) << 4) + HEXVALUE (val[2]);
+	    val += 2;
+	} else if (*val == '+')
+	    *t++ = ' ';
+	else 
+	    *t++ = *val;
+    }
+    *t = '\0';
+    return (out);
+}
+
+
+/* Escape HTML/XML special chars:
+ *	<	>	&	"	'
+ *	&lt;	&gt;	&amp;	&quot;	&apos;
+ */
+char *
+html_quote (val)
+    char *val;
+{
+    char *out, *t;
+    int n;
+
+    n = 0;
+    for (t = val; *t; t++) {
+	switch (*t) {
+	case '<': n += 4; break;
+	case '>': n += 4; break;
+	case '&': n += 5; break;
+	case '"': n += 6; break;
+	case '\'': n += 6; break;
+	default:  n++; break;
+	}
+    }
+    t = out = (char *)xmalloc (n + 1);
+    for ( ; *val; val++) {
+	switch (*val) {
+	case '<':  strcpy (t, "&lt;");    t += 4;  break;
+	case '>':  strcpy (t, "&gt;");    t += 4;  break;
+	case '&':  strcpy (t, "&amp;");   t += 5;  break;
+	case '"':  strcpy (t, "&quot;");  t += 6;  break;
+	case '\'': strcpy (t, "&apos;");  t += 6;  break;
+	default:
+	    *t++ = *val;
+	    break;
+	}
+    }
+    *t = '\0';
+    return (out);
+}
+
+
+/* Escape non-alphanumeric (plus '_') with backslash (\).
+ */
+char *
+regex_quote (val)
+    char *val;
+{
+    char *out, *t;
+    int n;
+
+    n = 0;
+    for (t = val; *t; t++) {
+	if (! ISWORD (*t))
+	    n++;
+	n++;
+    }
+    t = out = (char *)xmalloc (n + 1);
+    for ( ; *val; val++) {
+	if (! ISWORD (*val))
+            *t++ = '\\';
+        *t++ = *val;
+    }
+    *t = '\0';
+    return (out);
+}
+
+
+/* Strip leading/trailing whitespaces, and collapse multiple whitespaces to
+ * one space.  Same as `echo $var`.
+ */
+char *
+strip_leading_trailing (val, flag)
+    char *val;
+    int flag;
+{
+    char *out, *t;
+    int i, j, size;
+
+    size = strlen (val);
+
+    switch (flag) {
+    case STRIP_ALL:
+	for (i = 0; i < size && ISSPACE (val[i]); i++)
+	    ;
+	for (j = size - 1; i <= j && ISSPACE (val[j]); j--)
+	    ;
+	out = t = substring (val, i, j + 1);
+	for ( ; i < j + 1; i++) {
+	    if (! ISSPACE (val[i]))
+		*t++ = val[i];
+	    else if (! ISSPACE (val[i+1]))
+		*t++ = ' ';
+	}
+	*t = '\0';
+	return (out);
+
+    case STRIP_LR:
+	for (i = 0; i < size && ISSPACE (val[i]); i++)
+	    ;
+	for (j = size - 1; i <= j && ISSPACE (val[j]); j--)
+	    ;
+	out = substring (val, i, j + 1);
+	return (out);
+
+    case STRIP_L:
+	for (i = 0; i < size && ISSPACE (val[i]); i++)
+	    ;
+	j = size - 1;
+	out = substring (val, i, j + 1);
+	return (out);
+
+    case STRIP_R:
+	i = 0;
+	for (j = size - 1; i <= j && ISSPACE (val[j]); j--)
+	    ;
+	out = substring (val, i, j + 1);
+	return (out);
+
+    case STRIP_L0:	/* leading '0' and whitespaces */
+	while (*val && (ISSPACE (*val) || *val == '0'))
+	    val++;
+	return (savestring (val));
+    }
+}
+
+
+/* Remove trailing \r and \n, in-place.  Returns the string which was passed.
+ */
+char *
+strip_CRLF (s)
+    char *s;
+{
+    int size, i;
+
+    if (s && *s) {
+	size = strlen (s);
+	for (i = size - 1; i >= 0; i--)
+	    if (s[i] == '\r' || s[i] == '\n')
+		s[i] = '\0';
+	    else
+		break;
+    }
+    return (s);
+}
+
+
+char *
+string_add (old, new)		/* old += new */
+    char *old, *new;
+{
+    size_t i, n;
+
+    if (new && *new) {		/* something to add */
+	i = (old)? strlen (old): 0;
+	n = strlen (new);
+	old = (char *)xrealloc (old, i + n + 1);
+	strcpy (old + i, new);
+    }
+    return (old);
+}
+
+
+char *
+string_nadd (old, new, len)	/* old += new, and 'new' is not 0-terminated */
+    char *old, *new;
+    size_t len;
+{
+    size_t i;
+
+    if (new && *new && len) {		/* something to add */
+	i = (old)? strlen (old): 0;
+	old = (char *)xrealloc (old, i + len + 1);
+	strncpy (old + i, new, len);
+	old[i + len] = '\0';
+    }
+    return (old);
+}
+
+
+/* Returns 3-item list for "string matching", ie.
+ *      string  -->  prefix PATTERN suffix
+ */
+WORD_LIST *
+string_match_list (head, pattern)
+    char *head, *pattern;
+{
+    char *body, *tail;
+    WORD_LIST *list;
+
+    if (head == 0 || pattern == 0)
+        return (WORD_LIST *)NULL;
+
+    list = (WORD_LIST *)NULL;
+
+    if (*head && *pattern && (body = strstr (head, pattern))) {
+        tail = body + strlen (pattern);
+	list = prepend_substring_to_list (head, 0, body - head, list);
+	list = make_word_list (make_bare_word (pattern), list);
+	list = make_word_list (make_bare_word (tail), list);
+    }
+    list = REVERSE_LIST (list, WORD_LIST *);
+    return (list);
+}
+
+
+/* Returns 5-item list for "string interval matching", ie.
+ *      string  -->  prefix BEGIN middle END suffix
+ */
+WORD_LIST *
+string_interval_match_list (head, begin, end)
+    char *head, *begin, *end;
+{
+    char *body, *tail;
+    int a, b;
+    WORD_LIST *list;
+
+    if (head == 0 || begin == 0 || end == 0)
+        return (WORD_LIST *)NULL;
+
+    list = (WORD_LIST *)NULL;
+    a = strlen (begin);
+    b = strlen (end);
+
+    if (*head && *begin && (body = strstr (head, begin))) {	/* found beginning */
+	body += a;
+	if (*body && *end && (tail = strstr (body, end))) {	/* found end */
+	    /* ...BEGIN<body>...<tail>END... */
+	    list = prepend_substring_to_list (head, 0, body - head - a, list);
+	    list = make_word_list (make_bare_word (begin), list);
+	    list = prepend_substring_to_list (body, 0, tail - body, list);
+	    list = make_word_list (make_bare_word (end), list);
+	    list = make_word_list (make_bare_word (tail + b), list);
+	}
+    }
+    list = REVERSE_LIST (list, WORD_LIST *);
+    return (list);
+}
+
+
+/*******************************************************************************
+ * Positional parameters */
+
+
+/* Return pointer (ie. reference to, not a copy) to a positional parameter.
+ * Modified from get_dollar_var_value() which returns a copy.
+ */
+char **
+get_parameter_reference (i)
+    intmax_t i;
+{
+    char **out;
+    WORD_LIST *p;
+
+    if (i < 10) {
+        out = dollar_vars[i] ? &(dollar_vars[i]) : (char **)NULL;
+    } else {      /* We want something like ${11} */
+        i -= 10;
+        for (p = rest_of_args; p && i--; p = p->next)
+            ;
+        out = p ? &(p->word->word) : (char **)NULL;
+    }
+    return (out);
+}
+
+
+/* Assign list as positional parameters, flushing existing items.  Same as
+ * remember_args(list,1) without fluffs.
+ */
+void
+parameters_set_list (list)
+    WORD_LIST *list;		/* can be NULL, in which case just flush */
+{
+    int i;
+
+    for (i = 1; i < 10; i++) {
+	FREE (dollar_vars[i]);
+	dollar_vars[i] = (char *)NULL;
+	if (list) {
+	    dollar_vars[i] = savestring (list->word->word);
+	    list = list->next;
+	}
+    }
+    dispose_words (rest_of_args);
+    rest_of_args = copy_word_list (list);
+}
+
+
+/* Assign string vector as positional parameters, flushing existing items.
+ */
+void
+parameters_set_argv (v, alloc)
+    char **v;		/* can be NULL or empty, in which case just flush */
+    int alloc;
+{
+    int i, j, size;
+    WORD_DESC *w;
+    WORD_LIST *p;
+
+    j = 0;
+    for (i = 1; i < 10; i++) {		/* $1..$9 */
+	FREE (dollar_vars[i]);
+	dollar_vars[i] = (char *)NULL;
+	if (v && v[j]) {
+	    dollar_vars[i] = (alloc)? savestring (v[j]): v[j];
+	    j++;
+	}
+    }
+    dispose_words (rest_of_args);	/* $10, $11, ... */
+    rest_of_args = strvec_to_word_list (v, alloc, j);
+}
+
+
+/* Assign list to positional parameters, without flushing other items.  Can't
+ * use remember_args(), because it destroys existing content greater than $9.
+ * 'destructive=0' only works for $1..$9.
+ */
+void
+parameters_overwrite_list (list)
+    WORD_LIST *list;
+{
+    int i;
+    WORD_LIST *p, *a;
+
+    for (p = list, i = 1; i < 10 && p; i++, p = p->next) {
+	FREE (dollar_vars[i]);
+	dollar_vars[i] = savestring (p->word->word);
+    }
+    if (p) {		/* we got leftover for 'rest_of_args' */
+	list = copy_word_list (p);
+	if (rest_of_args) {
+	    a = rest_of_args;
+	    p = list;
+	    for ( ; a->next && p->next; a = a->next, p = p->next)
+		;
+	    if (a->next) {	/* old list is longer */
+		p->next = a->next;
+		a->next = (WORD_LIST *)NULL;
+	    }
+	    dispose_words (rest_of_args);
+	}
+	rest_of_args = list;
+    }
+}
+
+
+void
+parameters_append (arg)		/* append string to the end */
+    char *arg;
+{
+    int i;
+    WORD_LIST *p;
+
+    if (arg == 0)	/* required, because savestring() can't take NULL */
+	return;
+
+    for (i = 1; i < 10 && dollar_vars[i]; i++)
+	;
+    if (i < 10) {		/* one of $1..$9 */
+	dollar_vars[i] = savestring (arg);
+    } else {
+	p = make_word_list (make_bare_word (arg), (WORD_LIST *)NULL);
+	rest_of_args = (WORD_LIST *)list_append (rest_of_args, p);
+    }
+}
+
+
+void
+parameters_append_list (list)	/* append list to the end */
+    WORD_LIST *list;
+{
+    int i;
+    WORD_LIST *p;
+
+    for (i = 1; i < 10 && dollar_vars[i]; i++)
+	;
+    for (p = list; i < 10 && p; i++, p = p->next)	/* one of $1..$9 */
+	dollar_vars[i] = savestring (p->word->word);
+    if (p)
+	rest_of_args = (WORD_LIST *)list_append (rest_of_args, copy_word_list (p));
+}
+
+
+void
+parameters_push (arg)		/* push string to the front */
+    char *arg;
+{
+    int i;
+
+    if (arg == 0)	/* required, because savestring() can't take NULL */
+	return;
+
+    if (dollar_vars[9]) {
+	rest_of_args = make_word_list (make_bare_word (""), rest_of_args);
+	FREE (rest_of_args->word->word);
+	rest_of_args->word->word = dollar_vars[9];
+    }
+    for (i = 9; i > 1; i--)
+	dollar_vars[i] = dollar_vars[i - 1];
+    dollar_vars[1] = savestring (arg);
+}
+
+
+void
+parameters_push_list (list)	/* push list to the front */
+    WORD_LIST *list;
+{
+    WORD_LIST *p;
+
+    list = REVERSE_LIST (list, WORD_LIST *);
+    for (p = list; p; p = p->next)
+	parameters_push (p->word->word);
+    REVERSE_LIST (list, WORD_LIST *);
+}
+
+
+/*******************************************************************************
+ * List */
+
+
+/* Convert WORD_LIST to argv-style string vector (NULL terminated).  Same as
+ * strvec_from_word_list(), without fluffs.  Return NULL if list is empty,
+ * instead of returning an empty vector.  If PSIZE is non-zero, then size of
+ * list is returned.
+ */
+char **
+argv_from_list (list, alloc)
+     WORD_LIST *list;
+     int alloc;
+{
+    char **v, *t;
+    int i, size;
+
+    if (list == 0)
+	return (char **)NULL;
+
+    size = list_length (list);
+    v = strvec_create (size + 1);
+
+    for (i = 0; list; list = list->next, i++) {
+	t = list->word->word;
+	v[i] = (alloc)? savestring (t): t;
+    }
+    v[i] = (char *)NULL;
+    return (v);
+}
+
+
+/* Returns argv-style string vector containing positional parameter, without
+ * making copies of strings (if alloc=0).  Always returns valid pointer; if
+ * there is no parameter, then argv[0]=NULL.  If PSIZE is non-zero, then $# is
+ * returned.
+ */
+char **
+argv_from_parameters (alloc)
+    int alloc;
+{
+    char **v, *t;
+    int i, size;
+    WORD_LIST *p;
+
+    size = number_of_args ();
+    v = strvec_create (size + 1);
+
+    for (i = 0; i < 9 && i < size; i++) {
+	t = dollar_vars[i+1];
+	v[i] = (alloc)? savestring (t): t;
+    }
+    for (p = rest_of_args; p && i < size; i++, p = p->next) {
+	t = p->word->word;
+	v[i] = (alloc)? savestring (t): t;
+    }
+    v[i] = (char *)NULL;
+    return (v);
+}
+
+
+/* Remove one of $1..$9, then shift the higher ones down.  Taken from
+ * shift_builtin(), minus fluffs.
+ */
+void
+remove_dollar_var (i)
+    int i;
+{
+    WORD_LIST *p;
+
+    if (i < 1 || i > 9 || dollar_vars[i] == 0) 
+	return;
+
+    FREE (dollar_vars[i]);
+
+    for ( ; i < 9; i++)
+	dollar_vars[i] = dollar_vars[i + 1];
+
+    if (rest_of_args) {
+	p = rest_of_args;
+	dollar_vars[9] = savestring (p->word->word);
+	rest_of_args = p->next;
+	p->next = (WORD_LIST *)NULL;
+	dispose_words (p);
+    } else
+	dollar_vars[9] = (char *)NULL;
+}
+
+
+/* Remove the current list item.  If previous item is NULL, then it's the head
+ * of list, and return the new head.  If previous item is non-zero, then return
+ * the previous item.
+ */
+WORD_LIST *
+remove_list_item (oldp, p)
+    WORD_LIST *oldp, *p;
+{
+    WORD_LIST *newp;
+
+    if (oldp == 0 && p) {	/* 'p' is the head of list. */
+	newp = p->next;
+	p->next = (WORD_LIST *)NULL;
+	dispose_words (p);
+	return (newp);
+    } else if (oldp && p) {	/* 'p' is in the middle */
+	oldp->next = p->next;
+	p->next = (WORD_LIST *)NULL;
+	dispose_words (p);
+	return (oldp);
+    } else {
+	internal_error ("list item is already NULL");
+	return (oldp);
+    }
+}
+
+
+/* Read from file descriptor FD, where each string segment are terminated by \0
+ * (or SEP char).  Return WORD_LIST.  Similar to slurp_fd_into_string().
+ * If \0 or SEP char is found, then FOUNDSEP flag will be set to 1.  This is
+ * needed to determine if we're reading a string or list of string.
+ */
+WORD_LIST *
+slurp_fd_into_list (fd, sep, foundsep)
+    int fd, *foundsep;
+    char sep;
+{
+    char *out, buf[BUFSIZ];
+    ssize_t n;
+    int i, size, j, ichecked;
+    WORD_LIST *list;
+
+    if (sh_validfd (fd) == 0) {		/* taken from 'read' builtin */
+	builtin_error ("%d: invalid file descriptor", fd);
+	return (WORD_LIST *)NULL;
+    }
+
+    list = (WORD_LIST *)NULL;
+    ichecked = 0;
+    if (foundsep)
+        *foundsep = 0;
+
+    out = (char *)NULL;
+    size = i = 0;
+
+    while ((n = zread (fd, buf, sizeof(buf))) > 0) {
+	RESIZE_MALLOCED_BUFFER (out, i, n, size, BUFSIZ);
+	memcpy (out + i, buf, n);	/* don't stop at \0 */
+	i += n;
+
+        /* Search for \0.  If found, then copy the string into LIST, and shift
+         * the remaining input (next string) to the begining of OUT.
+         */
+        while (ichecked < i) {
+            while (ichecked < i && out[ichecked] != '\0' && out[ichecked] != sep) 
+                ichecked++;
+            if (ichecked < i && (out[ichecked] == '\0' || out[ichecked] == sep)) {
+                if (foundsep)
+                    *foundsep = 1;
+                list = prepend_substring_to_list (out, 0, ichecked, list);
+		ichecked++;	/* char after \0 */
+		memmove (out, out + ichecked, i - ichecked);
+                i -= ichecked;
+                ichecked = 0;
+            }
+        }
+    }
+    if (i > 0) {        /* if there is unterminated string */
+	list = prepend_substring_to_list (out, 0, i, list);
+    }
+
+    FREE (out);
+    list = REVERSE_LIST (list, WORD_LIST *);
+    return (list);
+}
+
+
+/* Read from file FILENAME, where each string segment are terminated by \0 (or
+ * SEP char).  Return WORD_LIST.  Similar to slurp_filename_into_string().
+ */
+WORD_LIST *
+slurp_filename_into_list (filename, sep, foundsep)
+    char *filename, sep;
+    int *foundsep;
+{
+    int fd;
+    struct stat finfo;
+    WORD_LIST *list;
+
+    if (filename == 0 || *filename == '\0')
+	return (WORD_LIST *)NULL;
+
+    fd = open (filename, O_RDONLY);
+    if (fd < 0) {
+	file_error (filename);
+	return (WORD_LIST *)NULL;
+    }
+    if (fstat (fd, &finfo) == 0 && S_ISDIR (finfo.st_mode)) {
+        builtin_error ("`%s': trying to read from directory", filename);
+	close (fd);
+        return (WORD_LIST *)NULL;
+    }
+    list = slurp_fd_into_list (fd, sep, foundsep);
+    close (fd);
+    return (list);
+}
+
+
+/* Write LIST into file descriptor.  Return the number of items successfully
+ * written, or -1 on error.
+ */
+int
+dump_list_into_fd (list, sep, fd)
+    WORD_LIST *list;
+    char sep;
+    int fd;
+{
+    char *s;
+    size_t size;
+    int count;
+
+    if (sh_validfd (fd) == 0) {		/* taken from 'read' builtin */
+	builtin_error ("%d: invalid file descriptor", fd);
+	return (-1);
+    }
+
+    count = 0;
+    for ( ; list; list = list->next) {
+	s = list->word->word;
+	size = strlen (s);
+	if (zwrite (fd, s, size) != size) {
+	    builtin_error ("failed to write a full string.");
+            return (-1);
+        }
+	if (zwrite (fd, &sep, 1) != 1) {
+	    builtin_error ("failed to write a terminator.");
+            return (-1);
+        }
+        count++;
+    }
+
+    return (count);
+}
+
+
+/* Write LIST into filename.  Return the number of items successfully written,
+ * or -1 on error.
+ */
+int
+dump_list_into_filename (list, sep, filename, o_append)
+    WORD_LIST *list;
+    char sep, *filename;
+    int o_append;	/* 1=append, 0=trunc */
+{
+    int fd, count;
+
+    if (filename == 0 || *filename == '\0')
+	return (-1);
+
+    fd = open (filename, O_CREAT|O_WRONLY|(o_append? O_APPEND: O_TRUNC), 0666);
+    if (fd < 0) {
+	file_error (filename);
+	return (-1);
+    }
+    count = dump_list_into_fd (list, sep, fd);
+    close (fd);
+    return (count);
+}
+
+
+/*******************************************************************************
+ * Array */
+
+
+#if defined (ARRAY_VARS)
+
+/* Convert array A to argv array of string (NULL terminated).  Same as
+ * array_to_argv(), but with option of not making copy of strings.
+ */
+char **
+argv_from_array (a, alloc)
+    ARRAY *a;
+    int alloc;
+{
+    char **v, *t;
+    int	i;
+    ARRAY_ELEMENT *ae;
+
+    if (a == 0 || array_empty (a))	 /* do nothing */
+	return (char **)NULL;
+
+    v = strvec_create (array_num_elements (a) + 1);
+    i = 0;
+    for (ae = element_forw (a->head); ae != a->head; ae = element_forw (ae)) {
+	t = element_value (ae);
+	v[i++] = (alloc)? savestring (t): t;
+    }
+    v[i] = (char *)NULL;
+    return (v);
+}
+
+
+/* Similar to name_to_arrayvar(), without error messages.
+ */
+SHELL_VAR *
+get_arrayvar (name, check_readonly)
+    char *name;
+    int check_readonly;
+{
+    SHELL_VAR *var;
+
+    if (! legal_identifier (name))
+	return (SHELL_VAR *)NULL;
+
+    var = find_variable (name);
+
+    if (var == 0 || invisible_p (var))
+	/* local variable can exist, but be invisible */
+	return (SHELL_VAR *)NULL;
+    else if (check_readonly && (readonly_p (var) || noassign_p (var)))
+	return (SHELL_VAR *)NULL;
+    else if (array_p (var) == 0 || array_cell (var) == 0)
+	return (SHELL_VAR *)NULL;
+
+    return (var);
+}
+
+
+/* Return array shell VAR corresponding to array string NAME.  Normally, it
+ * only checks for existence.  But, if CHECK_READONLY is set, then it checks if
+ * the array is readonly, in preparation for assignment.
+ *
+ * Modified from find_or_make_array_variable().  
+ */
+SHELL_VAR *
+name_to_arrayvar (name, check_readonly)
+    char *name;
+    int check_readonly;
+{
+    SHELL_VAR *var;
+
+    if (! legal_identifier (name)) {
+	sh_invalidid (name);
+	return (SHELL_VAR *)NULL;
+    }
+
+    var = find_variable (name);
+
+    if (var == 0 || invisible_p (var)) {
+	/* local variable can exist, but be invisible */
+	sh_notfound (name);
+	return (SHELL_VAR *)NULL;
+    }
+    else if (check_readonly && (readonly_p (var) || noassign_p (var))) {
+	sh_readonly (name);
+	return (SHELL_VAR *)NULL;
+    }
+    else if (array_p (var) == 0 || array_cell (var) == 0) {
+	builtin_error ("variable `%s' is not array", name);
+	return (SHELL_VAR *)NULL;
+    }
+
+    return (var);
+}
+
+
+/* Return array shell VAR corresponding to array string NAME.  Create new array
+ * variable, or convert existing variable to array.  If FLUSH is set, then flush
+ * it.  The returning array will be ready for "writing".
+ */
+SHELL_VAR *
+force_name_to_arrayvar (name, flush)
+    char *name;
+    int flush;		/* delete existing elements for clean start */
+{
+    SHELL_VAR *var;
+
+    if (! legal_identifier (name)) {
+	sh_invalidid (name);
+	return (SHELL_VAR *)NULL;
+    }
+
+    var = find_or_make_array_variable (name, 1 /* check for readonly */);
+    if (var && flush)
+	array_flush (array_cell (var));
+    return (var);
+}
+
+
+/* Copied from bind_array_variable().  Actually, array_insert() does the
+ * inserting "before" the head, which is effectively appending it because ARRAY
+ * is circular linked list.  If input string is NULL, use empty string ''
+ * instead.  Array element can have NULL as value, but it's not sensible.
+ */
+void
+arrayvar_insert (var, i, arg)
+    SHELL_VAR *var;
+    arrayind_t i;
+    char *arg;
+{
+    char *value;
+
+    if (arg == 0)
+	arg = "";
+
+    value = make_variable_value (var, arg);
+    if (var->assign_func)
+	(*var->assign_func) (var, value, i);
+    else
+	array_insert (array_cell (var), i, value);
+    FREE (value);
+}
+
+
+/* Like arrayvar_insert(), but using
+ *	substring (arg, a, b)
+ * without memory allocation and without checking [a,b] range.  This is usually
+ * okey, because [a,b] are generated in the same context and proximity as the
+ * string pointer.  WARNING
+ */
+void
+arrayvar_subinsert (var, i, arg, a, b)
+    SHELL_VAR *var;
+    arrayind_t i;
+    char *arg;
+    int a, b;
+{
+    char *t;
+
+    t = substring (arg, a, b);
+    arrayvar_insert (var, i, t);
+    FREE (t);
+}
+
+
+void
+arrayvar_append (var, arg)	/* append to the end */
+    SHELL_VAR *var;
+    char *arg;
+{
+    arrayind_t N;
+
+    N = array_max_index (array_cell (var));	/* -1 if empty */
+    arrayvar_insert (var, N+1, arg);
+}
+
+
+void
+arrayvar_subappend (var, arg, a, b)	/* append substring(arg,a,b) */
+    SHELL_VAR *var;
+    char *arg;
+    int a, b;
+{
+    arrayind_t N;
+
+    N = array_max_index (array_cell (var));	/* -1 if empty */
+    arrayvar_subinsert (var, N+1, arg, a, b);
+}
+
+
+/* Parse 'array[subscript]' expression, and return array name in NAME and the
+ * evaluated subscript in INDEX.  If both the name and the subscript are valid
+ * expression, then return success (1).  Otherwise, return error (0).  Whether
+ * the array name or index actually exists, is another matter.
+ *
+ * Copied from assign_array_element() which calls 
+ *	array_variable_name()	-- for array name
+ *	array_expand_index()	-- for array index
+ * It is designed to be used like
+ *	valid_array_reference()
+ * for testing array[subscript] expression, but with more info parsed out to the
+ * caller.
+ */
+int
+parse_array_subscript (string, name, index)
+    char *string, **name;
+    arrayind_t *index;
+{
+    char *sub;
+    int subend, flag;
+    arrayind_t i;
+    
+    sub = xstrchr (string, '[');
+    if (sub == 0) return (0);
+
+    *sub = '\0';
+    flag = legal_identifier (string);
+    *sub = '[';
+    if (flag == 0) return (0);
+    
+    subend = skipsubscript (sub, 0);	/* sub[0]='[', sub[subend]=']' */
+    if (sub[subend] != ']' || subend == 1 ||			/* [] */
+	    (ALL_ELEMENT_SUB (sub[1]) && sub[2] == ']'))	/* [@] [*] */
+	return (0);
+
+    i = array_expand_index (sub + 1, subend);
+    if (i < 0) return (0);
+
+    if (name)
+	*name = substring (string, 0, sub - string);
+    if (index)
+	*index = i;
+    return (1);
+}
+
+
+/* Cut out and return array element AE in array A.
+ */
+ARRAY_ELEMENT *
+cut_array_element (ae, a)
+    ARRAY_ELEMENT *ae;
+    ARRAY *a;
+{
+    if (a == 0 || array_empty (a))
+	return (ARRAY_ELEMENT *)NULL;
+
+    ae->next->prev = ae->prev;
+    ae->prev->next = ae->next;
+    a->num_elements--;
+    if (element_index (ae) == a->max_index)
+	a->max_index = element_index (ae->prev);
+
+    return (ae);
+}
+
+
+/* Cut out and remove array element AE in array A.
+ */
+void
+remove_array_element (ae, a)
+    ARRAY_ELEMENT *ae;
+    ARRAY *a;
+{
+    array_dispose_element (cut_array_element (ae, a));
+}
+
+
+/* Remove empty (null) elements.
+ */
+void
+array_prune (a)
+    ARRAY *a;
+{
+    int i;
+    ARRAY_ELEMENT *ae, *old;
+
+    for (ae = element_forw (a->head); ae != a->head; ae = element_forw (ae)) {
+	if (element_value (ae) && *(element_value (ae)) == '\0') {
+	    old = ae->prev;
+	    remove_array_element (ae, a);
+	    ae = old;
+	}
+    }
+}
+
+
+/* Set the index of array to i, i+1, i+2, ...
+ */
+void 
+re_index_array (a, i)
+    ARRAY *a;
+    arrayind_t i;
+{
+    ARRAY_ELEMENT *ae;
+
+    if (a == 0 || array_empty (a))	/* nothing to index */
+	return;
+
+    for (ae = element_forw (a->head); ae != a->head; ae = element_forw (ae))
+	element_index (ae) = i++;
+    a->max_index = i - 1;
+}
+
+
+/* Remove N elements from the front of array, then re-index.  So, pop'ing 0
+ * element will only adjust the indexes.
+ */
+void
+arrayvar_pop (var, n)
+    SHELL_VAR *var;
+    int n;
+{
+    ARRAY *a;
+
+    a = array_cell (var);
+
+    while (n-- > 0 && ! array_empty (a))
+	remove_array_element (element_forw (a->head), a);
+    re_index_array (a, 0);
+}
+
+
+/* Remove N elements from the end of array, then re-index.  So, triming 0
+ * element will only adjust the indexes.
+ */
+void
+arrayvar_trim (var, n)
+    SHELL_VAR *var;
+    int n;
+{
+    ARRAY *a;
+
+    a = array_cell (var);
+
+    while (n-- > 0 && ! array_empty (a))
+	remove_array_element (element_back (a->head), a);
+    re_index_array (a, 0);
+}
+
+
+/* Push string to the front of array, and re-index.
+ */
+void
+arrayvar_push (var, arg)
+    SHELL_VAR *var;
+    char *arg;
+{
+    if (arg == 0)
+	return;
+
+    re_index_array (array_cell (var), 1);	/* i=1,2,3,... */
+    arrayvar_insert (var, 0, arg);		/* i=0 */
+}
+
+
+/* Push list to the front of array, and re-index.  It's more efficient than
+ * pushing one by one, because indexes are adjusted only once.
+ */
+void
+arrayvar_push_list (var, list)
+    SHELL_VAR *var;
+    WORD_LIST *list;
+{
+    arrayind_t i;
+    ARRAY *a;
+
+    a = array_cell (var);
+    re_index_array (a, list_length (list));	/* i=n,n+1,... */
+    for (i = 0; list; list = list->next, i++)	/* i=0,1,...,n-1 */
+	arrayvar_insert (var, i, list->word->word);
+}
+
+
+/* Append list to the end of array.
+ */
+void
+arrayvar_append_list (var, list)
+    SHELL_VAR *var;
+    WORD_LIST *list;
+{
+    for (; list; list = list->next)
+	arrayvar_append (var, list->word->word);
+}
+
+
+/* Assign list into array, flushing existing array elements.
+ */
+void
+arrayvar_set_list (var, list)
+    SHELL_VAR *var;
+    WORD_LIST *list;
+{
+    ARRAY *a;
+
+    a = array_cell (var);
+    array_flush (a);
+    array_assign_list (a, list);
+}
+
+
+/* Serialize array (alternating index and value) and return WORD_LIST.
+ */
+WORD_LIST *
+serialize_arrayvar (var)
+    SHELL_VAR *var;
+{
+    ARRAY *a;
+    ARRAY_ELEMENT *ae;
+    char *t;
+    WORD_LIST *list;
+
+    list = (WORD_LIST *)NULL;
+    a = array_cell (var);
+
+    for (ae = element_forw (a->head); ae != a->head; ae = element_forw (ae)) {
+        t = itos (element_index (ae));
+        list = make_word_list (make_bare_word (t), list);
+        FREE (t);
+        t = element_value (ae);         /* not a copy */
+        list = make_word_list (make_bare_word (t), list);
+    }
+
+    list = REVERSE_LIST (list, WORD_LIST *);
+    return (list);
+}
+
+
+/* Populate array (alternating index and value) from WORD_LIST.  Returns the
+ * number of array elements populated, which should be 1/2 of list length.
+ * Return -1 on error.
+ */
+int
+deserialize_arrayvar (var, list)
+    SHELL_VAR *var;
+    WORD_LIST *list;
+{
+    int count;
+    intmax_t i;
+
+    count = 0;
+
+    for ( ; list; list = list->next) {
+        if (! legal_number (list->word->word, &i)) {
+            builtin_error ("`%s': invalid array index", list->word->word);
+            return (-1);
+        }
+        list = list->next;
+        if (list == 0) {
+            builtin_error ("odd number of list items");
+            return (-1);
+        }
+        arrayvar_insert (var, i, list->word->word);
+	count++;
+    }
+
+    return (count);
+}
+
+#endif	/* ARRAY_VARS */
+
+
+/*******************************************************************************
+ * Regex */
+
+
+#if defined (HAVE_POSIX_REGEXP)
+
+/* Both sys/types.h and regex.h (in that order) are specified in manpage.  But,
+ * sys/types.h is already included by sequence of
+ *	shell.h -> general.h -> bashtypes.h -> sys/types.h
+ *
+ * #include <sys/types.h>
+ */
+#include <regex.h>
+
+extern int glob_ignore_case;
+
+
+/* Split string on 'regex', and return list items.  If FLAG is '-', then remove
+ * 'regex' from the string and return non-matching segments.  If FLAG is '+',
+ * then extract 'regex' and return matching segments.  It returns NULL, if
+ * string is NULL or empty (ie. nothing to split).
+ */
+WORD_LIST *
+string_plusminus_regex (val, flag, regex)
+    char *val, *regex;
+    char flag;		/* '+' or '-' */
+{
+    regex_t preg;		/* size_t preg.re_nsub; */
+    regmatch_t *pmatch;
+    int cflags, eflags;
+    regoff_t a, b;
+
+    char *head, *body, *tail;
+    WORD_LIST *list;
+
+    if (val == 0 || *val == '\0' || regex == 0)
+	return (WORD_LIST *)NULL;
+
+    cflags = REG_EXTENDED;
+    if (glob_ignore_case) cflags |= REG_ICASE;
+
+    if (regcomp (&preg, regex, cflags)) {
+	builtin_error ("`%s': invalid regex", regex);
+	regfree (&preg);
+	return (WORD_LIST *)NULL;
+    }
+    pmatch = (regmatch_t *)xmalloc (1 * sizeof (regmatch_t));
+    eflags = 0;
+
+    list = (WORD_LIST *)NULL;
+    head = body = tail = val;
+
+    while (*body && regexec (&preg, body, 1, pmatch, eflags) == 0) {
+	body += pmatch[0].rm_so;
+	tail += pmatch[0].rm_eo;
+	if (body == tail) {	/* skip empty matches */
+	    body++;
+	    tail++;
+	} else {
+	    switch (flag) {
+	    case '-':
+		list = prepend_substring_to_list (head, 0, body - head, list);
+		break;
+	    case '+':
+		list = prepend_substring_to_list (body, 0, tail - body, list);
+		break;
+	    default:		/* append both segments */
+		list = prepend_substring_to_list (head, 0, body - head, list);
+		list = prepend_substring_to_list (body, 0, tail - body, list);
+		break;
+	    }
+	    head = body = tail;
+	}
+	eflags = REG_NOTBOL;
+    }
+    if (flag != '+')
+	list = make_word_list (make_bare_word (head), list);
+    list = REVERSE_LIST (list, WORD_LIST *);
+
+    FREE (pmatch);
+    regfree (&preg);
+    return (list);
+}
+
+
+/* Returns 3+ item list for "regex matching", ie.
+ *      string  -->  prefix SUBMATCH[0] SUBMATCH[1] ... SUBMATCH[n] suffix
+ * where SUBMATCH[0] is the entire regex string, and SUBMATCH[1..n] is
+ * parenthesized subgroups in regex pattern.
+ */
+WORD_LIST *
+regex_match_list (head, regex)
+    char *head, *regex;
+{
+    regex_t preg;		/* size_t preg.re_nsub; */
+    regmatch_t *pmatch;
+    int cflags, eflags;
+    regoff_t a, b;
+
+    WORD_LIST *list;
+    int i;
+
+    cflags = REG_EXTENDED;
+    if (glob_ignore_case) cflags |= REG_ICASE;
+
+    if (regcomp (&preg, regex, cflags)) {
+	builtin_error ("`%s': invalid regex", regex);
+	regfree (&preg);
+	return (WORD_LIST *)NULL;
+    }
+    pmatch = (regmatch_t *)xmalloc ((preg.re_nsub + 1) * sizeof (regmatch_t));
+    eflags = 0;
+
+    list = (WORD_LIST *)NULL;
+
+    if (regexec (&preg, head, preg.re_nsub + 1, pmatch, eflags) == 0) {
+	a = pmatch[0].rm_so;
+	list = prepend_substring_to_list (head, 0, a, list);
+	for (i = 0; i <= preg.re_nsub; i++) {
+	    a = pmatch[i].rm_so;
+	    b = pmatch[i].rm_eo;
+	    list = prepend_substring_to_list (head, a, b, list);
+	}
+	b = pmatch[0].rm_eo;
+	list = make_word_list (make_bare_word (head + b), list);
+    }
+
+    FREE (pmatch);
+    regfree (&preg);
+    list = REVERSE_LIST (list, WORD_LIST *);
+    return (list);
+}
+
+
+/* Returns 5-item list for "regex interval matching", ie.
+ *      string  -->  prefix BEGIN middle END suffix
+ */
+WORD_LIST *
+regex_interval_match_list (head, begin, end)
+    char *head, *begin, *end;
+{
+    regex_t preg, preg2;		/* size_t preg.re_nsub; */
+    regmatch_t *pmatch;
+    int cflags, eflags;
+    regoff_t a, b, a2, b2;
+
+    char *head2;
+    WORD_LIST *list;
+
+    cflags = REG_EXTENDED;
+    if (glob_ignore_case) cflags |= REG_ICASE;
+    cflags &= ~REG_NOSUB;	/* sub-index is needed to find the end pattern */
+
+    if (regcomp (&preg, begin, cflags)) {
+	builtin_error ("`%s': invalid regex", begin);
+	regfree (&preg);
+	return (WORD_LIST *)NULL;
+    }
+    if (regcomp (&preg2, end, cflags)) {
+	builtin_error ("`%s': invalid regex", end);
+	regfree (&preg);
+	regfree (&preg2);
+	return (WORD_LIST *)NULL;
+    }
+    pmatch = (regmatch_t *)xmalloc (1 * sizeof (regmatch_t));
+    eflags = 0;
+
+    list = (WORD_LIST *)NULL;
+
+    if (regexec (&preg, head, 1, pmatch, eflags) == 0) {
+	a = pmatch[0].rm_so;
+	b = pmatch[0].rm_eo;
+	head2 = head + b;
+	if (regexec (&preg2, head2, 1, pmatch, eflags) == 0) {
+	    a2 = pmatch[0].rm_so;
+	    b2 = pmatch[0].rm_eo;
+	    list = prepend_substring_to_list (head, 0, a, list);
+	    list = prepend_substring_to_list (head, a, b, list);
+	    list = prepend_substring_to_list (head2, 0, a2, list);
+	    list = prepend_substring_to_list (head2, a2, b2, list);
+	    list = make_word_list (make_bare_word (head2 + b2), list);
+	}
+    }
+    FREE (pmatch);
+    regfree (&preg);
+    regfree (&preg2);
+
+    list = REVERSE_LIST (list, WORD_LIST *);
+    return (list);
+}
+
+#endif	/* HAVE_POSIX_REGEXP */
+
+
+/*******************************************************************************
+ * Match */
+
+
+/* Returns
+ *      EXECUTION_SUCCESS (0)	-- pattern found
+ *      EXECUTION_FAILURE (1)	-- pattern not found
+ * 
+ * If SUBMATCH is specified, then it will contain
+ *	- prefix before regex match
+ *	- entire matching string (REGEX)
+ *	- parenthesized groups in regex pattern (group[1], group[2], ...)
+ *	- suffix after regex match
+ * ie.
+ *	submatch=( prefix REGEX group[1] group[2] ... group[n] suffix )
+ */
+/* Returns
+ *      EXECUTION_SUCCESS (0)	-- pattern found
+ *      EXECUTION_FAILURE (1)	-- pattern not found
+ *
+ * If SUBMATCH is specified, then 3 segments are returned.
+ *      submatch=( prefix PATTERN suffix )
+ */
+int
+match_engine (flag, string, pattern, submatch)
+    int flag;
+    char *string, *pattern, *submatch;
+{
+    SHELL_VAR *var;
+    WORD_LIST *list;
+
+    switch (flag) {
+#if defined (HAVE_POSIX_REGEXP)
+    case REGEX_MATCH:
+	list = regex_match_list (string, pattern);
+	break;
+#endif
+    case STRING_MATCH:
+    default:
+	list = string_match_list (string, pattern);
+	break;
+    }
+
+    if (submatch) {
+#if defined (ARRAY_VARS)
+	var = force_name_to_arrayvar (submatch, 1);
+	if (var == 0)
+	    return (EXECUTION_FAILURE);
+	array_assign_list (array_cell (var), list);
+#else
+	bind_variable_if_legal (submatch, (list)? (list->next)->word->word: "");
+#endif
+    }
+
+    dispose_words (list);
+    return (list)? EXECUTION_SUCCESS: EXECUTION_FAILURE;
+}
--- bash-3.2_orig/examples/loadables/william/subroutines.h	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/subroutines.h	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,126 @@
+/* Stuffs from "subroutines.c".  These files are identical and should be hard
+ * linked:
+ *	builtins/subroutines.[ch]
+ *	examples/loadables/william/subroutines.[ch]
+ */
+
+/* Variables */
+
+extern SHELL_VAR *bind_variable_if_legal	__P((char *, char *));
+extern char *get_pointer_to             __P((char *));
+extern int put_string_in                __P((char *, char *, int));
+
+/* Numbers */
+
+extern int legal_positive_integer	__P((char *, int *));
+extern int legal_integer		__P((char *, int *));
+extern int legal_number_with_base	__P((char *, intmax_t *, int));
+extern int legal_integer_with_base	__P((char *, int *, int));
+extern int imin				__P((int, int));
+extern int imax				__P((int, int));
+extern void adjust_python_range		__P((int *, int *, int));
+extern int valid_python_range		__P((char *, int *, int *, int));
+extern char *convert_to_cent		__P((char *));
+extern char *convert_to_dollar		__P((char *));
+extern char *convert_to_base36		__P((char *, int, int));
+
+/* String */
+
+extern int count_in_string		__P((char, char *));
+extern char *build_eval_string		__P((char *, char *));
+extern char *build_eval_substring	__P((char *, char *, int, int));
+extern char *replace_string		__P((char *, char *));
+extern char *replace_substring		__P((char *, char *, int, int));
+extern char *rotate_string		__P((char *, int));
+extern char *next_comma_in_csv		__P((char *));
+extern WORD_LIST *prepend_substring_to_list	__P((char *, int, int, WORD_LIST *));
+extern WORD_LIST *string_minus_separator	__P((char *, char *));
+extern WORD_LIST *string_plusminus_begin_end	__P((char *, int, char *, char *));
+extern char *slurp_fd_into_string	__P((int));
+extern char *slurp_filename_into_string	__P((char *));
+extern int dump_string_into_fd		__P((char *, int));
+extern int dump_string_into_filename	__P((char *, char *, int));
+extern char *csv_quote			__P((char *));
+extern char *csv_dequote		__P((char *));
+extern char *url_dequote		__P((char *));
+extern char *html_quote			__P((char *));
+extern char *regex_quote		__P((char *));
+
+#define STRIP_ALL	0	/* leading, inside, trailing */
+#define STRIP_LR	1	/* leading, trailing */
+#define STRIP_L		2	/* leading */
+#define STRIP_R		3	/* trailing */
+#define STRIP_L0	4	/* leading 0s */
+extern char *strip_leading_trailing	__P((char *, int));
+extern char *strip_CRLF			__P((char *));
+
+extern char *string_add			__P((char *, char *));
+extern char *string_nadd		__P((char *, char *, size_t));
+extern WORD_LIST *string_match_list	__P((char *, char *));
+extern WORD_LIST *string_interval_match_list	__P((char *, char *, char *));
+
+/* Positional parameter */
+
+extern char **get_parameter_reference   __P((intmax_t));
+extern void parameters_set_list		__P((WORD_LIST *));
+extern void parameters_set_argv		__P((char **, int));
+extern void parameters_overwrite_list	__P((WORD_LIST *));
+extern void parameters_append		__P((char *));
+extern void parameters_append_list	__P((WORD_LIST *));
+extern void parameters_push		__P((char *));
+extern void parameters_push_list	__P((WORD_LIST *));
+
+/* List */
+
+extern char **argv_from_list		__P((WORD_LIST *, int));
+extern char **argv_from_parameters	__P((int));
+extern void remove_dollar_var		__P((int));
+extern WORD_LIST *remove_list_item	__P((WORD_LIST *, WORD_LIST *));
+extern WORD_LIST *slurp_fd_into_list		__P((int, char, int *));
+extern WORD_LIST *slurp_filename_into_list	__P((char *, char, int *));
+extern int dump_list_into_fd			__P((WORD_LIST *, char, int));
+extern int dump_list_into_filename		__P((WORD_LIST *, char, char *, int));
+
+/* Array */
+
+#if defined (ARRAY_VARS)
+extern char **argv_from_array		__P((ARRAY *, int));
+extern SHELL_VAR *get_arrayvar			__P((char *, int));
+extern SHELL_VAR *name_to_arrayvar		__P((char *, int));
+extern SHELL_VAR *force_name_to_arrayvar	__P((char *, int));
+extern void arrayvar_insert		__P((SHELL_VAR *, arrayind_t, char *));
+extern void arrayvar_subinsert		__P((SHELL_VAR *, arrayind_t, char *, int, int));
+extern void arrayvar_append		__P((SHELL_VAR *, char *));
+extern void arrayvar_subappend		__P((SHELL_VAR *, char *, int, int));
+extern int parse_array_subscript	__P((char *, char **, arrayind_t *));
+extern ARRAY_ELEMENT *cut_array_element __P((ARRAY_ELEMENT *, ARRAY *));
+extern void remove_array_element	__P((ARRAY_ELEMENT *, ARRAY *));
+extern void array_prune			__P((ARRAY *));
+extern void re_index_array		__P((ARRAY *, arrayind_t));
+extern void arrayvar_pop		__P((SHELL_VAR *, int));
+extern void arrayvar_trim		__P((SHELL_VAR *, int));
+extern void arrayvar_push		__P((SHELL_VAR *, char *));
+extern void arrayvar_push_list		__P((SHELL_VAR *, WORD_LIST *));
+extern void arrayvar_append_list	__P((SHELL_VAR *, WORD_LIST *));
+extern void arrayvar_set_list		__P((SHELL_VAR *, WORD_LIST *));
+extern WORD_LIST *serialize_arrayvar	__P((SHELL_VAR *));
+extern int deserialize_arrayvar		__P((SHELL_VAR *, WORD_LIST *));
+#endif
+
+/* Regex */
+
+#if defined (HAVE_POSIX_REGEXP)
+extern WORD_LIST *string_plusminus_regex	__P((char *, char, char *));
+extern WORD_LIST *regex_match_list		__P((char *, char *));
+extern WORD_LIST *regex_interval_match_list	__P((char *, char *, char *));
+#endif
+
+/* Match */
+
+#define REGEX_MATCH	0x1
+#define STRING_MATCH	0x2
+extern int match_engine		__P((int, char *, char *, char *));
+
+#define regex_match(s, pat, submatch)	match_engine (REGEX_MATCH, (s), (pat), (submatch))
+#define string_match(s, pat, submatch)	match_engine (STRING_MATCH, (s), (pat), (submatch))
+
--- bash-3.2_orig/examples/loadables/william/tonumber.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/tonumber.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,52 @@
+/*******************************************************************************
+ * tonumber ABC		--> 65 66 67
+ */
+
+#include "loadables.h"
+
+
+int
+tonumber_builtin (list)
+    WORD_LIST *list;
+{
+    char *t, buf[BUFSIZ];
+    ssize_t n, i;
+
+    if (no_options (list))
+	return (EX_BADUSAGE);
+    list = loptend;		/* skip over possible `--' */
+
+    if (list == 0) {		/* 0 argument */
+	if (sh_validfd (0 /* fd */) == 0) {
+	    builtin_error ("%d: invalid file descriptor", 0 /* fd */);
+	    return (EXECUTION_FAILURE);
+	}
+	while ((n = zread (0 /* fd */, buf, sizeof(buf))) > 0) {
+	    for (i = 0; i < n; i++)
+		printf ("%u\n", (unsigned char)(buf[i]));
+	}
+    } else {
+	for ( ; list; list = list->next) {
+	    for (t = list->word->word; *t; t++)
+		printf (t[1] ? "%u " : "%u\n", (unsigned char)(*t));
+	}
+    }
+
+    return (EXECUTION_SUCCESS);
+}
+
+
+char *tonumber_doc[] = {
+    "Inverse of 'tostring'.  Print ASCII number (decimal) of each char in",
+    "STRING, one string per line.",
+    "    tonumber ABC       -->  65 66 67",
+    "If command line arguments are missing, then stdin is read, in which case",
+    "it's equivalent to",
+    "    od -An -tuC < file",
+    (char *)NULL
+};
+struct builtin tonumber_struct = {
+    "tonumber", tonumber_builtin, BUILTIN_ENABLED, tonumber_doc,
+    "tonumber [string... | < file]",
+    (char *)NULL
+};
--- bash-3.2_orig/examples/loadables/william/tostring.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/tostring.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,59 @@
+/*******************************************************************************
+ * tostring 65 66 67	--> ABC
+ */
+
+#include "loadables.h"
+
+
+int
+tostring_builtin (list)
+    WORD_LIST *list;
+{
+    int i, retval;
+    char *t;
+    WORD_LIST *headlist;
+
+    if (no_options (list))
+	return (EX_BADUSAGE);
+    list = loptend;		/* skip over possible `--' */
+
+    headlist = (WORD_LIST *)NULL;
+    retval = EXECUTION_SUCCESS;
+
+    if (list == 0) {		/* 0 argument */
+	t = slurp_fd_into_string (0);	/* stdin */
+	if (t == 0)
+	    return (EXECUTION_FAILURE);
+	list = headlist = list_string (t, ifs_value, 0);
+	FREE (t);
+    }
+
+    for ( ; list; list = list->next) {
+	if (legal_integer (list->word->word, &i)) {
+	    putchar (i);	/* this can print \0 */
+	} else {
+	    sh_invalidnum (list->word->word);
+	    retval = EXECUTION_FAILURE;
+	    break;
+	}
+    }
+
+    dispose_words (headlist);
+    fflush (stdout);
+    return (retval);
+}
+
+
+char *tostring_doc[] = {
+    "Inverse of 'tonumber'.  Print ASCII char corresponding to each number",
+    "(decimal).  If command line arguments are missing, then stdin is read.",
+    "    tostring 65 66 67       --> ABC",
+    "and is equivalent to ",
+    "    printf `printf '\\\\%o' ...",
+    (char *)NULL
+};
+struct builtin tostring_struct = {
+    "tostring", tostring_builtin, BUILTIN_ENABLED, tostring_doc,
+    "tostring [number... | < file]",
+    (char *)NULL
+};
--- bash-3.2_orig/examples/loadables/william/vcat.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/vcat.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,114 @@
+/*******************************************************************************
+ * Write positional parameter, shell variable, or array variable to stdout.
+ * Hence, "variable cat" as opposed to "file cat".
+ */
+
+#include "loadables.h"
+
+
+int
+vcat_engine (name, vcat_flag, fd)
+    char *name;
+    int vcat_flag, fd;
+{
+    char *t;
+    SHELL_VAR *var;
+    WORD_LIST *p;
+    struct stat finfo;
+
+    if (sh_validfd (fd) == 0) {
+	builtin_error ("%d: invalid file descriptor", fd);
+	return (EXECUTION_FAILURE);
+    } else if (fstat (fd, &finfo) == 0 && S_ISDIR (finfo.st_mode)) {
+	builtin_error ("%d: trying to write to directory", fd);
+	return (EXECUTION_FAILURE);
+    }
+
+    if (name == 0) {
+	p = list_rest_of_args ();
+	dump_list_into_fd (p, '\0', fd);
+	dispose_words (p);
+    }
+#if defined (ARRAY_VARS)
+    else if (var = get_arrayvar (name, 0)) {
+	if (vcat_flag & VCAT_FULLARRAY)
+	    p = serialize_arrayvar (var);
+	else
+	    p = array_to_word_list (array_cell (var));
+	dump_list_into_fd (p, '\0', fd);
+	dispose_words (p);
+    }
+#endif
+    else if (t = get_pointer_to (name)) {
+	if (vcat_flag & VCAT_PRINT0)
+	    zwrite (fd, t, strlen (t) + 1);		/* include '\0' */
+	else
+	    zwrite (fd, t, strlen (t));
+    }
+    else {
+	/* Not sure if it should fail with error message.  You can 'echo'
+	 * non-existent variable, so you can should be able to 'vcat' it too.
+	 * Problem is that file is already created by shell.  To be inverse of
+	 * 'vset' in strict sense, it should success only if both variable and
+	 * file are valid.  For now, return error.
+	 */
+	sh_notfound (name);
+	return (EXECUTION_FAILURE);
+    }
+
+    fdatasync (fd);
+    return (EXECUTION_SUCCESS);
+}
+
+
+int
+vcat_builtin (list)
+    WORD_LIST *list;
+{
+    int opt, vcat_flag;
+
+    vcat_flag = 0;
+
+    reset_internal_getopt ();
+    while ((opt = internal_getopt (list, "0A")) != -1) {
+	switch (opt) {
+#if defined (ARRAY_VARS)
+	case 'A':
+	    vcat_flag |= VCAT_FULLARRAY;
+	    break;
+#endif
+	case '0':
+	    vcat_flag |= VCAT_PRINT0;
+	    break;
+	default:
+	    builtin_usage ();
+	    return (EX_BADUSAGE);
+	}
+    }
+    list = loptend;		/* skip over possible `--' */
+
+    if (list == 0)		/* 0 argument means positional parameters */
+	return (vcat_engine ((char *)NULL, vcat_flag, 1));
+    else if (list->next == 0)	/* 1 argument */
+	return (vcat_engine (list->word->word, vcat_flag, 1));
+    else {
+	builtin_usage ();
+	return (EX_BADUSAGE);
+    }
+}
+
+
+char *vcat_doc[] = {
+    "Writes a shell variable NAME to stdout (inverse of 'vset').  If NAME is",
+    "missing, then positional parameters are printed.  Each value of array",
+    "elements and positional parameters is terminated by '\\0', whereas ordinary",
+    "shell variable is not \\0-terminated unless option -0 is given.  By default,",
+    "only the array values are printed, but option -A will print the array index",
+    "as well.",
+    (char *)NULL
+};
+struct builtin vcat_struct = {
+    "vcat", vcat_builtin, BUILTIN_ENABLED, vcat_doc,
+    "vcat [-0A] [name] > file",
+    (char *)NULL
+};
--- bash-3.2_orig/examples/loadables/william/vfile.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/vfile.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,139 @@
+/*******************************************************************************
+ * Read/write the content of variables from/to files of the same name.
+ */
+
+#include "loadables.h"
+#include <errno.h>		/* strerror (errno) */
+
+
+int
+vfile_builtin (list)
+    WORD_LIST *list;
+{
+    char *name, *newdir;
+    int fd, retval, opt, rw_flag, oldfd, newfd, vcat_flag;
+    struct stat finfo;
+
+    vcat_flag = rw_flag = 0;
+    newdir = (char *)NULL;
+
+    reset_internal_getopt ();
+    while ((opt = internal_getopt (list, "rwd:0A")) != -1) {
+	switch (opt) {
+	case 'r':
+	case 'w':
+	    rw_flag = opt;	/* -[rw] is mandatory */
+	    break;
+	case 'd': 
+	    newdir = list_optarg;
+	    break;
+#if defined (ARRAY_VARS)
+	case 'A':
+	    vcat_flag |= VCAT_FULLARRAY;
+	    break;
+#endif
+	case '0':
+	    vcat_flag |= VCAT_PRINT0;
+	    break;
+	default:
+	    builtin_usage ();
+	    return (EX_BADUSAGE);
+	}
+    }
+    list = loptend;		/* skip over possible `--' */
+
+    if (list == 0 || rw_flag == 0) {	/* -[rw] option and NAME... are mandatory */
+	builtin_usage ();
+	return (EX_BADUSAGE);
+    }
+    if (newdir) {
+	oldfd = open (".", O_DIRECTORY);
+	newfd = open (newdir, O_DIRECTORY);
+
+	/* If changing directory fails, then return immediately to prevent
+	 * overwriting files on current directory.  Even if directory is not
+	 * writeable, it means you can't create new file, but you can still
+	 * overwrite existing files.
+	 */
+	if (newfd < 0 || fchdir (newfd) < 0) {
+	    builtin_error ("cannot change directory to `%s': %s", newdir, strerror (errno));
+	    if (newfd >= 0) close (newfd);
+	    if (oldfd >= 0) close (oldfd);
+	    return (EXECUTION_FAILURE);
+	}
+    }
+
+    retval = EXECUTION_SUCCESS;
+
+    for ( ; list; list = list->next) {
+	name = list->word->word;
+
+	switch (rw_flag) {
+	case 'r':
+	    fd = open (name, O_RDONLY);
+	    if (fd < 0) {
+		file_error (name);
+		retval = EXECUTION_FAILURE;
+	    } else if (fstat (fd, &finfo) == 0 && S_ISDIR (finfo.st_mode)) {
+		builtin_error ("`%s': trying to read from directory", name);
+		retval = EXECUTION_FAILURE;
+	    }
+	    break;
+	case 'w':
+	    fd = creat (name, /* O_CREAT|O_WRONLY|O_TRUNC, */ 0666);
+	    if (fd < 0) {
+		file_error (name);
+		retval = EXECUTION_FAILURE;
+	    } else if (fstat (fd, &finfo) == 0 && S_ISDIR (finfo.st_mode)) {
+		builtin_error ("`%s': trying to write to directory", name);
+		retval = EXECUTION_FAILURE;
+	    }
+	    break;
+	}
+
+	if (retval == EXECUTION_FAILURE)
+	    break;
+
+	switch (rw_flag) {
+	case 'r':
+	    retval = vset_engine (name, vcat_flag, fd);
+	    break;
+	case 'w':
+	    retval = vcat_engine (name, vcat_flag, fd);
+	    break;
+	}
+
+	if (fd >= 0)
+	    close (fd);
+
+	if (retval == EXECUTION_FAILURE)
+	    break;
+    }
+
+    if (newdir) {	/* Return to old directory, and clean up */
+	if (newfd >= 0)
+	    close (newfd);
+	if (oldfd >= 0) {
+	    fchdir (oldfd);
+	    close (oldfd);
+	}
+    }
+    return (retval);
+}
+
+
+char *vfile_doc[] = {
+    "Read (-r) or write (-w) shell variables from/to files of the same name.",
+    "Internally, it uses 'vcat' and 'vset', so full array content is preserved.",
+    "    vcat [-0A] name > name",
+    "    vset [-0A] name < name",
+    "Files are assumed to be in the current directory.  If DIR is specified, then",
+    "chdir(2) is done first; if this fails, it returns (1) immediately.  If all files",
+    "are read/written successfully, then it returns (0).",
+    (char *)NULL
+};
+struct builtin vfile_struct = {
+    "vfile", vfile_builtin, BUILTIN_ENABLED, vfile_doc,
+    "vfile -[rw] [-d dir] [-0A] name...",
+    (char *)NULL
+};
--- bash-3.2_orig/examples/loadables/william/vplot.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/vplot.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,346 @@
+/*******************************************************************************
+ * Print x-y character plot on the terminal.  Screen is continuous string from
+ * upper-left 'home' position to lower-right corner.  As usual on terminal
+ * screen,
+ *	x-axis	-- moving right horizontally 
+ *	y-axis	-- moving down vertically
+ *
+ *    9	+---------+
+ *	| * *   * |
+ *	|  *   *  |
+ *    0	+---------+
+ *	0  title  9
+ */
+
+#include "loadables.h"
+
+
+enum go_flag { go_right, go_left, go_up, go_down };
+
+static char *screen;
+static int columns;		/* set from COLUMNS environment variable */
+static int lines;		/* set from LINES environment variable */
+
+#define XMIN	2		/* add 1 space after y-axis label */
+#define XMAX	(columns - 1)
+#define YMIN	0
+#define YMAX	(lines - 2)	/* reserve last line for x-axis label */
+
+
+static void screen_putc		__P((int, int, char));
+static void screen_putc_to_x	__P((int, int, char, int));
+static void screen_putc_to_y	__P((int, int, char, int));
+static void screen_putbox	__P((int, int, int, int));
+static void screen_puts		__P((int, int, char *, enum go_flag));
+
+
+static void
+screen_putc (x, y, c)
+    int x, y;
+    char c;
+{
+    if (x >= 0 && x <= columns - 1 && y >= 0 && y <= lines - 1)
+	screen[y * columns + x] = c;
+}
+
+
+static void
+screen_putc_to_x (x, y, c, end)
+    int x, y, end;
+    char c;
+{
+    if (x < end)
+	for ( ; x <= end; x++) screen_putc (x, y, c);
+    else if (x > end)
+	for ( ; x >= end; x--) screen_putc (x, y, c);
+    else
+	screen_putc (x, y, c);
+}
+
+
+static void
+screen_putc_to_y (x, y, c, end)
+    int x, y, end;
+    char c;
+{
+    if (y < end)
+	for ( ; y <= end; y++) screen_putc (x, y, c);
+    else if (y > end)
+	for ( ; y >= end; y--) screen_putc (x, y, c);
+    else
+	screen_putc (x, y, c);
+}
+
+
+static void
+screen_putbox (x1, y1, x2, y2)
+    int x1, y1, x2, y2;
+{
+    screen_putc_to_x (x1, y1, '-', x2);
+    screen_putc_to_x (x1, y2, '-', x2);
+    screen_putc_to_y (x1, y1, '|', y2);
+    screen_putc_to_y (x2, y1, '|', y2);
+
+    screen_putc (x1, y1, '+');
+    screen_putc (x1, y2, '+');
+    screen_putc (x2, y2, '+');
+    screen_putc (x2, y1, '+');
+}
+
+
+static void
+screen_puts (x, y, label, flag)
+    int x, y;
+    char *label;
+    enum go_flag flag;
+{
+    int i, size;
+
+    size = strlen (label);
+
+    switch (flag) {
+    case go_right:
+	for (i = 0; i < size; i++) screen_putc (x + i, y, label[i]);
+	break;
+    case go_left:
+	for (i = 0; i < size; i++) screen_putc (x - i, y, label[size-1 - i]);
+	break;
+    case go_down:
+	for (i = 0; i < size; i++) screen_putc (x, y + i, label[i]);
+	break;
+    case go_up:
+	for (i = 0; i < size; i++) screen_putc (x, y - i, label[size-1 - i]);
+	break;
+    }
+}
+
+
+int
+vplot_builtin (list)
+    WORD_LIST *list;
+{
+    int opt, i, x, y, drawaxis, size, h_aspect, v_aspect;
+    double ymin, ymax, xmin, xmax, fx, fy;
+    char *t, label[80], *xtitle, *ytitle;
+    SHELL_VAR *var, *var1, *var2;
+    char **v, **vec, **vec1, **vec2;
+    ARRAY *a1, *a2;
+    WORD_LIST *headlist;
+
+    drawaxis = h_aspect = v_aspect = 0;
+    xtitle = ytitle = (char *)NULL;
+
+    t = get_string_value ("COLUMNS");		/* not a copy */
+    legal_positive_integer (t, &columns);
+
+    t = get_string_value ("LINES");		/* not a copy */
+    if (legal_positive_integer (t, &lines) && lines > 0)
+	lines--;	/* last line is for prompt */
+
+    reset_internal_getopt ();
+    while ((opt = internal_getopt (list, "0x#y#X:Y:hv")) != -1) {
+	switch (opt) {
+	case '0':
+	    drawaxis = 1;
+	    break;
+	case 'x':
+	    if (! legal_positive_integer (list_optarg, &columns)) {
+		sh_invalidnum (list_optarg);
+		return (EXECUTION_FAILURE);
+	    }
+	    break;
+	case 'y':
+	    if (! legal_positive_integer (list_optarg, &lines)) {
+		sh_invalidnum (list_optarg);
+		return (EXECUTION_FAILURE);
+	    }
+	    break;
+	case 'X':
+	    xtitle = list_optarg;
+	    break;
+	case 'Y':
+	    ytitle = list_optarg;
+	    break;
+	case 'h':
+	    h_aspect = 1;
+	    break;
+	case 'v':
+	    v_aspect = 1;
+	    break;
+	default:
+	    builtin_usage ();
+	    return (EX_BADUSAGE);
+	}
+    }
+    list = loptend;		/* skip over possible `--' */
+
+    vec = (char **)NULL;
+    headlist = (WORD_LIST *)NULL;
+
+    switch (list_length (list)) {
+    case 0:
+	t = slurp_fd_into_string (0);	/* stdin */
+	if (t == 0)
+	    return (EXECUTION_FAILURE);
+	list = headlist = list_string (t, ifs_value, 0);
+	FREE (t);
+	vec = argv_from_list (list, 0);
+	break;
+
+    case 1:		/* 1 argument: vplot xy */
+	var = name_to_arrayvar (list->word->word, 0);
+	if (var == 0)
+	    return (EXECUTION_FAILURE);
+	vec = argv_from_array (array_cell (var), 0);
+	break;
+
+    case 2:		/* 2 arguments: vplot x y */
+	var1 = name_to_arrayvar (list->word->word, 0);
+	var2 = name_to_arrayvar (list->next->word->word, 0);
+	if (var1 == 0 || var2 == 0)
+	    return (EXECUTION_FAILURE);
+	a1 = array_cell (var1);
+	a2 = array_cell (var2);
+	if (array_num_elements (a1) != array_num_elements (a2)) {
+	    builtin_error ("mismatch between x and y data");
+	    return (EXECUTION_FAILURE);
+	}
+	vec1 = argv_from_array (a1, 0);
+	vec2 = argv_from_array (a2, 0);
+	size = array_num_elements (a1);
+	v = vec = strvec_create (2 * size + 1);
+	for (i = 0; i < size; i++) {
+	    *(v++) = vec1[i];
+	    *(v++) = vec2[i];
+	}
+	*v = (char *)NULL;
+	FREE (vec1);
+	FREE (vec2);
+	break;
+	
+    case 3:
+	builtin_usage ();
+	return (EX_BADUSAGE);
+
+    default:		/* 4 or more arguments: vplot x1 y1 x2 y2 ... */
+	vec = argv_from_list (list, 0);
+	break;
+    }
+
+    if (vec)
+	size = strvec_len (vec);
+    if (vec == 0 || size % 2 != 0 || size < 4) {
+	builtin_error ("need more data points");
+	dispose_words (headlist);
+	FREE (vec);
+	return (EXECUTION_FAILURE);
+    }
+
+    xmin = xmax = atof (vec[0]);	/* min, max */
+    ymin = ymax = atof (vec[1]);
+    for (i = 2; i <= size - 2; i += 2) {
+	fx = atof (vec[i]);
+	fy = atof (vec[i + 1]);
+	if (fx > xmax) xmax = fx;
+	if (fx < xmin) xmin = fx;
+	if (fy > ymax) ymax = fy;
+	if (fy < ymin) ymin = fy;
+    }
+
+    /* If aspect ratio is to be preserved, then recalculate 'ymax' or 'xmax', so
+     * that it "looks" the same when drawn on 'columns' x 'lines' graph.
+     */
+    if (h_aspect || v_aspect) {
+	double m, a, b;
+
+	m = (double)(YMAX - YMIN) / (double)(XMAX - XMIN);	/* slope */
+	a = xmax - xmin;
+	b = ymax - ymin;
+	
+	if (b < m * a && v_aspect) {	/* too short, so expand to new "y" */
+	    b = m * a;
+	    ymax = b + ymin;
+	}
+	if (a < b / m && h_aspect) {	/* too narrow, so expand to new "x" */
+	    a = b / m;
+	    xmax = a + xmin;
+	}
+    }
+
+    /* create screen, draw the square boundary */
+
+    screen = (char *)xmalloc (columns * lines);
+    memset (screen, ' ', columns * lines);
+
+    screen_putbox (XMIN, YMIN, XMAX, YMAX);
+
+/* Convert (double)[xmin,xmax] to (int)[XMIN,XMAX]
+ * Convert (double)[ymin,ymax] to (int)[YMAX,YMIN]
+ */
+#define INSIDE_X(x)	(0.5 + XMIN + (XMAX-XMIN) * ((x)-xmin) / (xmax-xmin))
+#define INSIDE_Y(y)	(0.5 + YMIN + (YMAX-YMIN) * (ymax-(y)) / (ymax-ymin))
+
+    /* plot data */
+
+    if (drawaxis) {	/* draw x-axis (y=0) and y-axis (x=0) */
+	x = INSIDE_X (0);
+	y = INSIDE_Y (0);
+	screen_putc_to_x (XMIN + 1, y, '-', XMAX - 1);
+	screen_putc_to_y (x, YMIN + 1, '|', YMAX - 1);
+	screen_putc (x, y, '+');	/* (0,0) */
+    }
+    for (i = 0; i < size - 1; i += 2) {
+	x = INSIDE_X (atof (vec[i]));
+	y = INSIDE_Y (atof (vec[i + 1]));
+	screen_putc (x, y, '*');
+    }
+
+    /* label the end points of x and y axis, and title if given */
+
+    snprintf(label, sizeof(label), "%.4g", ymin);
+    screen_puts (0, YMAX, label, go_up);
+
+    snprintf(label, sizeof(label), "%.4g", ymax);
+    screen_puts (0, YMIN, label, go_down);
+
+    snprintf(label, sizeof(label), "%.4g", xmin);
+    screen_puts (XMIN, YMAX + 1, label, go_right);
+
+    snprintf(label, sizeof(label), "%.4g", xmax);
+    screen_puts (XMAX, YMAX + 1, label, go_left);
+
+    if (xtitle)
+	screen_puts ((XMIN+XMAX)/2 - strlen(xtitle)/2, YMAX + 1, xtitle, go_right);
+    if (ytitle)
+	screen_puts (0, (YMIN+YMAX)/2 - strlen(ytitle)/2, ytitle, go_down);
+
+    for (y = 0; y < lines; y++) {
+	for (x = 0; x < columns; x++)
+	    putchar (screen[y * columns + x]);
+	putchar ('\n');
+    }
+
+    dispose_words (headlist);
+    FREE (screen);
+    FREE (vec);
+    return (EXECUTION_SUCCESS);
+}
+
+
+char *vplot_doc[] = {
+    "Print x-y character plot to stdout.  If 'columns' and 'lines' are not",
+    "given, then COLUMNS and LINES environment variables are used instead.",
+    "Option -0 will draw x-axis and y-axis, if possible.  And, option -[hv] will",
+    "preserve horizonal and vertical aspect ratio, respectively.",
+    "",
+    "One can specify single array XY, two arrays X and Y, or simply list x-y",
+    "pairs on command line.  Arrays XY, X, and Y are variable references, so",
+    "don't use '$'.  If command line arguments are missing, then the numbers are",
+    "read from stdin.",
+    (char *)NULL
+};
+struct builtin vplot_struct = {
+    "vplot", vplot_builtin, BUILTIN_ENABLED, vplot_doc,
+    "vplot [-0hv] [-x columns -y lines -X xtitle -Y ytitle] [xy | x y | x1 y1 x2 y2... | < file]",
+    (char *)NULL
+};
--- bash-3.2_orig/examples/loadables/william/vset.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/vset.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,114 @@
+/*******************************************************************************
+ * Read positional parameter, shell variable, or array variable from stdin.
+ */
+
+#include "loadables.h"
+
+
+int
+vset_engine (name, vcat_flag, fd)
+    char *name;
+    int vcat_flag, fd;
+{
+    char *t;
+    SHELL_VAR *var;
+    WORD_LIST *p;
+    int retval, foundsep;
+    struct stat finfo;
+
+    if (sh_validfd (fd) == 0) {
+	builtin_error ("%d: invalid file descriptor", fd);
+	return (EXECUTION_FAILURE);
+    } else if (fstat (fd, &finfo) == 0 && S_ISDIR (finfo.st_mode)) {
+	builtin_error ("%d: trying to read from directory", fd);
+	return (EXECUTION_FAILURE);
+    }
+
+    foundsep = 0;
+    retval = EXECUTION_SUCCESS;
+
+    p = slurp_fd_into_list (fd, '\0', &foundsep);
+
+    if (name == 0) {
+	parameters_set_list (p);
+    }
+    else if (! foundsep || foundsep && p->next == 0 && vcat_flag & VCAT_PRINT0) {
+        unbind_variable (name);
+        t = p? p->word->word: "";
+	if (put_string_in (t, name, 0 /* o_append */) < 0) {
+	    sh_notfound (name);
+	    retval = EXECUTION_FAILURE;
+	}
+    }
+#if defined (ARRAY_VARS)
+    else {
+	var = force_name_to_arrayvar (name, 1);
+	if (var == 0) {
+	    retval = EXECUTION_FAILURE;
+	} else {
+	    if (vcat_flag & VCAT_FULLARRAY) {
+		if (deserialize_arrayvar (var, p) < 0)
+		    retval = EXECUTION_FAILURE;
+	    } else {
+		array_assign_list (array_cell (var), p);
+	    }
+	}
+    }
+#endif
+
+    dispose_words (p);
+    return (retval);
+}
+
+
+int
+vset_builtin (list)
+    WORD_LIST *list;
+{
+    int opt, vcat_flag;
+
+    vcat_flag = 0;
+
+    reset_internal_getopt ();
+    while ((opt = internal_getopt (list, "0A")) != -1) {
+	switch (opt) {
+#if defined (ARRAY_VARS)
+	case 'A':
+	    vcat_flag |= VCAT_FULLARRAY;
+	    break;
+#endif
+	case '0':
+	    vcat_flag |= VCAT_PRINT0;
+	    break;
+	default:
+	    builtin_usage ();
+	    return (EX_BADUSAGE);
+	}
+    }
+    list = loptend;		/* skip over possible `--' */
+
+    if (list == 0)		/* 0 argument means positional parameters */
+	return (vset_engine ((char *)NULL, vcat_flag, 0));
+    else if (list->next == 0)	/* 1 argument */
+	return (vset_engine (list->word->word, vcat_flag, 0));
+    else {
+	builtin_usage ();
+	return (EX_BADUSAGE);
+    }
+}
+
+
+char *vset_doc[] = {
+    "Assigns a shell variable NAME from stdin (inverse of 'vcat').  If NAME is",
+    "missing, then positional parameters are set.  If input data contains '\\0',",
+    "then it is considered array, and NAME will be converted to array variable.",
+    "By default, only array values are set, but option -A will set the array",
+    "index as well.  If there is only one string with trailing '\\0', then option",
+    "-0 will set it to regular shell variable.",
+    (char *)NULL
+};
+struct builtin vset_struct = {
+    "vset", vset_builtin, BUILTIN_ENABLED, vset_doc,
+    "vset [-0A] [name] < file",
+    (char *)NULL
+};
--- bash-3.2_orig/examples/loadables/william/webserver.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/examples/loadables/william/webserver.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,557 @@
+/*******************************************************************************
+ * Shell interface to libwebserver-0.6.0-19.  Shell builtins provide wrappers to
+ * internal C routines.  Added libwebserver-0.5.3 support.
+ */
+
+#include "loadables.h"
+
+
+#if defined (HAVE_LIBWEBSERVER)
+
+#include <fnmatch.h>
+#include <web_server.h>	
+
+#define THIS_IS_NEW_VERSION	0	/* up to 0.5.3 */
+#ifdef LWS_VERSION_CODE
+#   if LWS_VERSION_CODE >= LWS_VERSION(0,6,0)
+#	undef THIS_IS_NEW_VERSION
+#	define THIS_IS_NEW_VERSION	1	/* 0.6.0 and later */
+#   endif
+#endif
+
+
+#if THIS_IS_NEW_VERSION
+extern char *__ILWS_web_client_getreq (struct web_client *); /* method + uri */
+#else
+extern char *__ILWS_web_client_getreq ();	/* method + uri */
+#endif
+
+static WORD_LIST *commandlist;
+static int inside_callback;
+#if THIS_IS_NEW_VERSION
+static struct ClientInfo *ClientInfo;
+#endif
+
+
+#if THIS_IS_NEW_VERSION
+static int callback	__P((struct ClientInfo *));
+#else
+static void callback	__P((void));
+static char *make_new_key	__P((char *));
+#endif
+static int test_or_bind		__P((char *, char *));
+static int test_or_bind_array	__P((char *, char *(*FuncArray)(), char *, int));
+static int test_or_bind_array2 	__P((char *, char *(*FuncArray)(), char *, char *, int));
+
+
+
+/* The first thing that callback() does is setup ClientInfo for the other
+ * functions in this file.  The execution goes back to the server only after
+ * callback() ends, and not before.  In between, other commands or functions
+ * will be called.  But, the only other function which accesses ClientInfo is
+ * 'ClientInfo' builtin, and it's located here; so, it's okey to use global
+ * variable.
+ *
+ * Then, find out which glob pattern triggered this callback.  Libwebserver uses
+ * its own fnmatch() with flag=5 (ie. FNM_PERIOD | FNM_NOESCAPE), so use the
+ * same macros here.  The glob is matched against string returned by
+ * __ILWS_web_client_getreq(), which is method + uri.  Eg.
+ *	GET /index.html
+ * will be matched by glob pattern
+ *	* /in*
+ */
+#if THIS_IS_NEW_VERSION
+static int
+callback (cinfo)
+    struct ClientInfo *cinfo;
+#else
+static void
+callback ()
+#endif
+{
+    char *req, *glob, *command;
+    WORD_LIST *p;
+
+    inside_callback = 1;
+#if THIS_IS_NEW_VERSION
+    ClientInfo = cinfo;
+#endif
+
+    /* For convenience, setup some global variables. */
+    unbind_variable ("inetname");
+    unbind_variable ("request");
+    unbind_variable ("method");
+    unbind_variable ("user");
+    unbind_variable ("pass");
+#if THIS_IS_NEW_VERSION
+    unbind_variable ("alias_request");
+#endif
+    bind_variable ("inetname", ClientInfo->inetname);
+    bind_variable ("request", ClientInfo->request);
+    bind_variable ("method", ClientInfo->method);
+    bind_variable ("user", ClientInfo->user);
+    bind_variable ("pass", ClientInfo->pass);
+#if THIS_IS_NEW_VERSION
+    bind_variable ("alias_request", ClientInfo->alias_request);
+#endif
+
+#if THIS_IS_NEW_VERSION
+    req = __ILWS_web_client_getreq (ClientInfo->client);
+#else
+    req = __ILWS_web_client_getreq();
+#endif
+    for (p = commandlist; p && p->next; p = p->next->next) {
+	glob = p->word->word;
+	command = p->next->word->word;
+	if (fnmatch (glob, req, FNM_NOESCAPE | FNM_PERIOD) != FNM_NOMATCH) {
+	    parse_and_execute (command, "libwebserver", SEVAL_NOHIST | SEVAL_NONINT | SEVAL_NOFREE);
+	    break;	/* first match only */
+	}
+    }
+    FREE (req);
+
+    inside_callback = 0;
+#if THIS_IS_NEW_VERSION
+    ClientInfo = (struct ClientInfo *)NULL;
+    return (WH_OK);
+#endif
+}
+
+
+int
+webserver_builtin (list)
+     WORD_LIST *list;
+{
+    int opt, size;
+    WORD_LIST *p;
+
+    struct web_server server;
+    int port, ws_flags;
+    char *logfile, *glob, *command;
+
+    ws_flags = 0;
+    port = 80;	
+    logfile = (char *)NULL;
+
+    reset_internal_getopt ();
+    while ((opt = internal_getopt (list, "p:l:c:L")) != -1) {
+	switch (opt) {
+	case 'p':
+	    if (legal_positive_integer (list_optarg, &port) == 0) {
+		builtin_error ("expected positive integer");
+		return (EXECUTION_FAILURE);
+	    }
+	    break;
+	case 'l':
+	    logfile = list_optarg;
+	    break;
+	case 'c':
+	    logfile = list_optarg;
+	    ws_flags |= WS_USEEXTCONF;
+	    break;
+	case 'L':
+	    ws_flags |= WS_LOCAL;
+	    break;
+	default:
+	    builtin_usage ();
+	    return (EX_BADUSAGE);
+	}
+    }
+    list = loptend;		/* skip over possible `--' */
+
+    size = list_length (list);
+    if (size == 0 || size % 2 != 0) {	/* 0 or odd argument */
+	builtin_usage ();
+	return (EX_BADUSAGE);
+    }
+
+    /* 2, 4, 6, ... arguments */
+
+    if (! web_server_init (&server, port, logfile, ws_flags)) {
+	builtin_error ("cannot open listen socket on port %d", port);
+	return (EXECUTION_FAILURE);
+    };
+
+    for (p = list; p && p->next; p = p->next->next) {
+	glob = p->word->word;
+	command = p->next->word->word;
+#if 0		/* may be too strict */
+	if (! legal_identifier (command)) {	/* check for abuse */
+	    sh_invalidid (command);
+	    return (EXECUTION_FAILURE);
+	}
+#endif
+	if (! web_server_addhandler (&server, glob, callback, ws_flags)) {
+	    builtin_error ("cannot register `%s' as callback", glob);
+	    return (EXECUTION_FAILURE);
+	}
+    }
+
+    commandlist = list;
+    while (web_server_run (&server))
+	;
+    return (EXECUTION_FAILURE);		/* loop terminates on some error */
+}
+
+
+/*******************************************************************************
+ * Only for 'ClientInfo' builtin
+ */
+static int want_all, want_test;
+
+
+/* If want_test=1, compare strings 'value' and 's' (ie. value == s), and return
+ * success (0) if equal, or failure (1).  If want_test=0, then assign string 's'
+ * to shell variable 'value' (ie. value = s), and return success (0) or failure
+ * (1) of assignment.  The returned value is interpreted by shell, so it's
+ * opposite of usual C.
+ */
+static int
+test_or_bind (value, s)
+    char *value, *s;
+{
+    if (want_test)
+	return (STREQ (value, s))? EXECUTION_SUCCESS: EXECUTION_FAILURE;
+    else if (bind_variable_if_legal (value, s))
+	return (EXECUTION_SUCCESS);
+    else
+	return (EXECUTION_FAILURE);
+}
+
+
+#if THIS_IS_NEW_VERSION
+    /* not needed for new version */
+#else
+static char *
+make_new_key (key)	/* newkey = '#' + key */
+    char *key;
+{
+    char *newkey;
+
+    newkey = (char *)xmalloc (strlen (key) + 2);
+    newkey[0] = '#';
+    strcpy (newkey + 1, key);
+    return (newkey);
+}
+#endif
+
+
+/* Similar to test_or_bind() above, except for key with multiple values, which
+ * makes up array.
+ */
+static int
+test_or_bind_array (value, FuncArray, key, n)
+    char *value, *key;
+#if THIS_IS_NEW_VERSION
+    char *(*FuncArray)(struct ClientInfo *, char *, int);
+#else
+    char *(*FuncArray)(char *);
+#endif
+    int n;	/* size of array */
+{
+    SHELL_VAR *var;
+    char *s;
+
+    if (want_test) {
+	while (n-- > 0) {
+#if THIS_IS_NEW_VERSION
+	    s = FuncArray (ClientInfo, key, n);
+#else
+	    s = FuncArray (key);
+#endif
+	    if (STREQ (value, s))
+		return (EXECUTION_SUCCESS);
+	}
+    }
+#if defined (ARRAY_VARS)
+    else {
+	var = force_name_to_arrayvar (value, 1 /* flush */);
+	if (var) {
+	    while (n-- > 0) {
+#if THIS_IS_NEW_VERSION
+		s = FuncArray (ClientInfo, key, n);
+#else
+		s = FuncArray (key);
+#endif
+		arrayvar_append (var, s);
+	    }
+	    return (EXECUTION_SUCCESS);
+	}
+    }
+#endif
+    return (EXECUTION_FAILURE);
+}
+
+
+/* Similar to test_or_bind() above, except for key with multiple values, which
+ * makes up array.
+ */
+static int
+test_or_bind_array2 (value, FuncArray, topic, key, n)
+    char *value, *topic, *key;
+#if THIS_IS_NEW_VERSION
+    char *(*FuncArray)(struct ClientInfo *, char *, char *, int);
+#else
+    char *(*FuncArray)(char *, char *);
+#endif
+    int n;	/* size of array */
+{
+    SHELL_VAR *var;
+    char *s;
+
+    if (want_test) {
+	while (n-- > 0) {
+#if THIS_IS_NEW_VERSION
+	    s = FuncArray (ClientInfo, topic, key, n);
+#else
+	    s = FuncArray (topic, key);
+#endif
+	    if (STREQ (value, s))
+		return (EXECUTION_SUCCESS);
+	}
+    }
+#if defined (ARRAY_VARS)
+    else {
+	var = force_name_to_arrayvar (value, 1 /* flush */);
+	if (var) {
+	    while (n-- > 0) {
+#if THIS_IS_NEW_VERSION
+		s = FuncArray (ClientInfo, topic, key, n);
+#else
+		s = FuncArray (topic, key);
+#endif
+		arrayvar_append (var, s);
+	    }
+	    return (EXECUTION_SUCCESS);
+	}
+    }
+#endif
+    return (EXECUTION_FAILURE);
+}
+
+
+char *webserver_doc[] = {
+#if THIS_IS_NEW_VERSION
+    "Interface to libwebserver-0.6.0-22 (libwebserver.sourceforge.net).  It will",
+#else
+    "Interface to libwebserver-0.5.3 (libwebserver.sourceforge.net).  It will",
+#endif
+    "run web server in an infinite loop, so run it in subshell or another script",
+    "if you need to kill it.",
+    "    -p          port to listen on",
+    "    -L          accept only local connections",
+    "    -l logfile  log file (mutually exclusive with -c)",
+    "    -c config   configuration file (mutually exclusive with -l)",
+    "",
+    "Arguments are sequence of glob/command pairs, where 'command' is anything",
+    "you can type on command line.  When the server receives request (method +",
+    "uri) that matches 'glob', it will execute the associated command, which",
+    "will run at the same level as the server.",
+    (char *)NULL
+};
+struct builtin webserver_struct = {
+    "webserver", webserver_builtin, BUILTIN_ENABLED, webserver_doc,
+    "webserver [-p port -[cl] logfile -L] glob command ...",
+    (char *)NULL
+};
+
+
+/*******************************************************************************
+ * This builtin gives access to ClientInfo which is what callback() got from the
+ * web server.  So, it is meaningful only inside callback().
+ */
+int
+ClientInfo_builtin (list)
+    WORD_LIST *list;
+{
+    int opt, n;
+    char *t, *topic, *key, *value, *s; 
+
+#if THIS_IS_NEW_VERSION
+    if (! inside_callback || ClientInfo == 0) {
+#else
+    if (! inside_callback) {
+#endif
+	builtin_error ("meaningful only inside callback");
+	return (EXECUTION_FAILURE);
+    }
+
+    want_test = want_all = 0;
+
+    reset_internal_getopt ();
+    while ((opt = internal_getopt (list, "ea")) != -1) {
+	switch (opt) {
+	case 'e':
+	    want_test = 1;
+	    break;
+	case 'a':
+	    want_all = 1;
+	    break;
+	default:
+	    builtin_usage ();
+	    return (EX_BADUSAGE);
+	}
+    }
+    list = loptend;		/* skip over possible `--' */
+
+    switch (list_length (list)) {
+    case 2:
+	t =	list->word->word;
+	value = list->next->word->word;
+	if (STREQ (t, "inetname"))
+	    return test_or_bind (value, ClientInfo->inetname);
+	else if (STREQ (t, "request"))
+	    return test_or_bind (value, ClientInfo->request);
+	else if (STREQ (t, "method"))
+	    return test_or_bind (value, ClientInfo->method);
+	else if (STREQ (t, "user"))
+	    return test_or_bind (value, ClientInfo->user);
+	else if (STREQ (t, "pass"))
+	    return test_or_bind (value, ClientInfo->pass);
+#if THIS_IS_NEW_VERSION
+	else if (STREQ (t, "alias_request"))
+	    return test_or_bind (value, ClientInfo->alias_request);
+#endif
+	break;
+
+    case 3:
+	t =	list->word->word;
+	key =   list->next->word->word;
+	value = list->next->next->word->word;
+	if (*key == '\0')
+	    key = (char *)NULL;
+
+#if THIS_IS_NEW_VERSION
+	if (STREQ (t, "Header")) {
+	    return test_or_bind (value, LWS_Header (ClientInfo, key));
+	} else if (STREQ (t, "Cookie")) {
+	    return test_or_bind (value, LWS_Cookie (ClientInfo, key));
+	} else if (STREQ (t, "Query")) {
+	    if (key && want_all) {
+		n = LWS_QueryArraySize (ClientInfo, key);
+		return test_or_bind_array (value, LWS_QueryArray, key, n);
+	    } else
+		return test_or_bind (value, LWS_Query (ClientInfo, key));
+	} else if (STREQ (t, "Post")) {
+	    if (key && want_all) {
+		n = LWS_PostArraySize (ClientInfo, key);
+		return test_or_bind_array (value, LWS_PostArray, key, n);
+	    } else
+		return test_or_bind (value, LWS_Post (ClientInfo, key));
+	}
+#else
+	else if (*key == '#') {
+	    builtin_error ("found '#' as first char.  Use -a option instead.");
+	    return (EXECUTION_FAILURE);
+	}
+	if (STREQ (t, "Header")) {
+	    return test_or_bind (value, ClientInfo->Header (key));
+	} else if (STREQ (t, "Cookie")) {
+	    return test_or_bind (value, ClientInfo->Cookie (key));
+	} else if (STREQ (t, "Query")) {
+	    if (key && want_all) {
+		t = make_new_key (key);
+		n = (int)ClientInfo->Query (t);
+		FREE (t);
+		return test_or_bind_array (value, ClientInfo->Query, key, n);
+	    } else
+		return test_or_bind (value, ClientInfo->Query (key));
+	} else if (STREQ (t, "Post")) {
+	    if (key && want_all) {
+		t = make_new_key (key);
+		n = (int)ClientInfo->Post (t);
+		FREE (t);
+		return test_or_bind_array (value, ClientInfo->Post, key, n);
+	    } else
+		return test_or_bind (value, ClientInfo->Post (key));
+	}
+#endif
+	break;
+
+    case 4:
+	t =	list->word->word;
+	topic = list->next->word->word;
+	key =   list->next->next->word->word;
+	value = list->next->next->next->word->word;
+	if (*key == '\0')
+	    key = (char *)NULL;
+
+#if THIS_IS_NEW_VERSION
+	if (STREQ (t, "Conf")) {
+	    if (key && want_all) {
+		n = LWS_ConfArraySize (ClientInfo, topic, key);
+		return test_or_bind_array2 (value, LWS_ConfArray, topic, key, n);
+	    } else
+		return test_or_bind (value, LWS_Conf (ClientInfo, topic, key));
+	}
+#else
+	else if (*key == '#') {
+	    builtin_error ("found '#' as first char.  Use -a option instead.");
+	    return (EXECUTION_FAILURE);
+	}
+	if (STREQ (t, "Conf")) {
+	    if (key && want_all) {
+		t = make_new_key (key);
+		n = (int)ClientInfo->Conf (topic, t);
+		FREE (t);
+		return test_or_bind_array2 (value, ClientInfo->Conf, topic, key, n);
+	    } else
+		return test_or_bind (value, ClientInfo->Conf (topic, key));
+	}
+#endif
+	break;
+    }
+
+    builtin_usage ();
+    return (EX_BADUSAGE);
+}
+
+
+char *ClientInfo_doc[] = {
+    "Interface to internal ClientInfo data structure of libwebserver.  It's",
+    "meaningful only in command which has been called by web server.  There are",
+    "3 general forms:",
+    "",
+#if THIS_IS_NEW_VERSION
+    "ClientInfo [-e] {inetname|request|alias_request|method|user|pass} value",
+    "    By default, shell variable 'value' is assigned the 'inetname',",
+    "    'request', 'alias_request', 'method', 'user', or 'pass' data from",
+#else
+    "ClientInfo [-e] {inetname|request|method|user|pass} value",
+    "    By default, shell variable 'value' is assigned the 'inetname',",
+    "    'request', 'method', 'user', or 'pass' data from",
+#endif
+    "    internal ClientInfo structure.  For convenience, these data have",
+    "    already been setup in variables of same name.  With -e option, it will",
+    "    compare string 'value' with the internal data, and return success (0)",
+    "    if equal.",
+    "",
+    "ClientInfo [-ea] {Header|Query|Post|Cookie} key value",
+    "    By default, shell variable 'value' is assigned Header(key), Query(key),",
+    "    Post(key), or Cookie(key) data from internal ClientInfo structure.  If",
+    "    'key' is empty (null), then entire string is returned.  If -a is",
+    "    specified, then array variable 'value' is returned with all values",
+    "    associated with 'key'.  With -e option, string 'value' is compared with",
+    "    the internal data, and returns success (0) is equal.  For multiple",
+    "    values (-a), success is returned if string 'value' matches any item.",
+    "",
+    "ClientInfo [-ea] Conf topic key value",
+    "    By default, shell variable 'value' is assigned Conf(topic,key) data",
+    "    from internal ClientInfo structure.  If -a is specified, then array",
+    "    variable 'value' is returned with all values associated with 'key'.",
+    "    With -e option, string 'value' is compared with the internal data, and",
+    "    returns success (0) is equal.  For multiple values (-a), success is",
+    "    returned if string 'value' matches any item.",
+    (char *)NULL
+};
+struct builtin ClientInfo_struct = {
+    "ClientInfo", ClientInfo_builtin, BUILTIN_ENABLED, ClientInfo_doc,
+#if THIS_IS_NEW_VERSION
+    "ClientInfo [-ea] {{inetname|request|alias_request|method|user|pass} value | {Header|Query|Post|Cookie} key value | Conf topic key value}",
+#else
+    "ClientInfo [-ea] {{inetname|request|method|user|pass} value | {Header|Query|Post|Cookie} key value | Conf topic key value}",
+#endif
+    (char *)NULL
+};
+
+#endif	/* HAVE_LIBWEBSERVER */
--- bash-3.2_orig/execute_cmd.2.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/execute_cmd.2.c	2008-04-05 08:43:09.000000000 +0000
@@ -0,0 +1,79 @@
+/*******************************************************************************
+ * try-block with string exception.  New builtin 'raise' is used to raise an
+ * exception.  Once exception is raised, it will break out of all loops and skip
+ * all commands, until the exception is "caught" in case-like statement or until
+ * there is no more try-block.
+ *
+ *	TRY 
+ *	    commands
+ *	DONE
+ *  or 
+ *	TRY 
+ *	    commands
+ *	DONE IN
+ *	    glob) ... ;;
+ *	    regex)) ... ;;
+ *	ESAC
+ *
+ * So, the try-block is like while-loop running only once, and case-like
+ * statement is handled exactly like the normal case statement, where the
+ * exception is now the string to test for.
+ *
+ * --William
+ */
+
+static int
+execute_try_command (try_command)
+    TRY_COM *try_command;
+{
+    int out, ignore_return;
+
+    ignore_return = try_command->flags & CMD_IGNORE_RETURN;
+    if (ignore_return)
+	try_command->action->flags |= CMD_IGNORE_RETURN;
+
+    out = EXECUTION_SUCCESS;
+
+    try_level++;
+    do {
+	REAP ();
+	QUIT;
+	out = execute_command (try_command->action);
+	QUIT;
+    } while (0);	/* run only once */
+    try_level--;
+   
+    if (exception) {
+	CASE_COM *catch;
+	char *old;
+
+	catch = (CASE_COM *)xmalloc (sizeof (CASE_COM));	/* free this */
+	catch->flags = try_command->flags;
+	catch->line = line_number;
+	catch->word = make_bare_word (exception);	/* free this */
+	catch->clauses = try_command->clauses;
+	catch->true_case = (COMMAND *)NULL;
+	catch->false_case = (COMMAND *)NULL;
+	catch->total_match = 0;
+
+	old = exception; 
+	exception = (char *)NULL;	/* so that 'case' statement will run */
+
+	execute_case_command (catch);
+
+	if (exception)		/* new exception raised from 'case' statement */
+	    FREE (old);
+	else if (catch->total_match)	/* exception was caught */
+	    FREE (old);
+	else if (try_level == 0)	/* we reached top level */
+	    FREE (old);
+	else			/* retore exception, to go further up */
+	    exception = old;
+
+	dispose_word (catch->word);
+	FREE (catch);
+    }
+
+    return (out);
+}
+/******************************************************************************/
--- bash-3.2_orig/execute_cmd.c	2008-04-05 08:42:57.000000000 +0000
+++ bash-3.2/execute_cmd.c	2008-04-05 08:48:22.000000000 +0000
@@ -95,6 +95,14 @@
 #  include "bashhist.h"
 #endif
 
+
+/* --William */
+#include "builtins/subroutines.h"
+extern char *exception;
+extern int try_level;
+static int execute_try_command __P((TRY_COM *));
+
+
 extern int posixly_correct;
 extern int breaking, continuing, loop_level;
 extern int expand_aliases;
@@ -387,6 +395,7 @@
     case cm_case:
     case cm_while:
     case cm_until:
+    case cm_try:		/* --William */
     case cm_if:
     case cm_for:
     case cm_group:
@@ -501,7 +510,7 @@
   volatile int last_pid;
   volatile int save_line_number;
 
-  if (command == 0 || breaking || continuing || read_but_dont_execute)
+  if (command == 0 || breaking || continuing || read_but_dont_execute || exception /* --William */)
     return (EXECUTION_SUCCESS);
 
   QUIT;
@@ -769,6 +778,12 @@
       exec_result = execute_until_command (command->value.While);
       break;
 
+    case cm_try:			/* --William */
+      if (ignore_return)
+	command->value.Try->flags |= CMD_IGNORE_RETURN;
+      exec_result = execute_try_command (command->value.Try);
+      break;
+
     case cm_if:
       if (ignore_return)
 	command->value.If->flags |= CMD_IGNORE_RETURN;
@@ -1624,9 +1639,38 @@
   SHELL_VAR *old_value = (SHELL_VAR *)NULL; /* Remember the old value of x. */
 #endif
 
+  WORD_LIST *multi_variables, *mv;		/* --William */
+
   save_line_number = line_number;
+
+  /*****************************************************************************
+   * Enable multiple loop variables in for-loop, with syntax
+   *	for  a,b,c,...  in list; do
+   *	    ...
+   *	done
+   * where no space is allowed around ',' (comma) because only one word is
+   * parsed.  List items are sequentially assigned to the loop variables 'a',
+   * 'b', 'c', etc.  If there is shortage of item, then the last iteration will
+   * run with '' (null) assigned to leftover variables.
+   *
+   * --William Park
+   */
+  multi_variables = (WORD_LIST *)NULL;
+
+  if (xstrchr (for_command->name->word, ',') != NULL) {		/* split 'a,b,c,...' */
+      /* word_split() breaks up word, only if it's not quoted.  It's front-end
+       * to list_string() for WORD_DESC variable. */
+      multi_variables = word_split (for_command->name, ",");
+
+      for (mv = multi_variables; mv; mv = mv->next)
+	  if (check_identifier (mv->word, 1) == 0) {
+	      dispose_words (multi_variables);
+	      goto Exit_by_Original_Code;
+	  }
+  } else {			/* original code */
   if (check_identifier (for_command->name, 1) == 0)
     {
+    Exit_by_Original_Code:			/* --William */
       if (posixly_correct && interactive_shell == 0)
 	{
 	  last_command_exit_value = EX_USAGE;
@@ -1634,6 +1678,8 @@
 	}
       return (EXECUTION_FAILURE);
     }
+  }
+  /****************************************************************************/
 
   loop_level++;
   identifier = for_command->name->word;
@@ -1689,9 +1735,35 @@
 #endif
 
       this_command_name = (char *)NULL;
+
+      /*************************************************************************
+       * Assign list items into a, b, c, ...   --William
+       */
+      if (multi_variables) {
+    for (mv = multi_variables; mv; mv = mv->next) {
+        identifier = mv->word->word;
+        if (list) {
+      /* Goto the next item in the list, only if there are more
+       * variables to assign.  If finished assigning, then leave the
+       * incrementing for the next iteration.
+       */
+      v = bind_variable (identifier, list->word->word);
+      if (mv->next)
+          list = list->next;
+        } else      /* no more items */
+      v = bind_variable (identifier, "");
+
+        if (readonly_p (v) || noassign_p (v)) {
+      dispose_words (multi_variables);
+      goto Exit_by_Original_Code_2;
+        }
+    }
+      } else {      /* original code */
+      /************************************************************************/
       v = bind_variable (identifier, list->word->word, 0);
       if (readonly_p (v) || noassign_p (v))
 	{
+Exit_by_Original_Code_2:      /* --William */
 	  line_number = save_line_number;
 	  if (readonly_p (v) && interactive_shell == 0 && posixly_correct)
 	    {
@@ -1706,6 +1778,8 @@
 	      return (EXECUTION_FAILURE);
 	    }
 	}
+      }
+
       retval = execute_command (for_command->action);
       REAP ();
       QUIT;
@@ -1722,6 +1796,9 @@
 	  if (continuing)
 	    break;
 	}
+
+      if (list == 0 || exception) 	/* --William */
+	  break;
     }
 
   loop_level--;
@@ -1743,6 +1820,26 @@
     }
 #endif
 
+  /*****************************************************************************
+   * Run THEN commands if for-loop exits normally, and run ELSE commands if
+   * break is used.
+   * --William
+   */
+  if (list == 0 && for_command->then_action) {
+      if (for_command->flags & CMD_IGNORE_RETURN)
+	  for_command->then_action->flags |= CMD_IGNORE_RETURN;
+      retval = execute_command (for_command->then_action);
+  }
+  if (list && for_command->else_action) {
+      if (for_command->flags & CMD_IGNORE_RETURN)
+	  for_command->else_action->flags |= CMD_IGNORE_RETURN;
+      retval = execute_command (for_command->else_action);
+  }
+
+  if (multi_variables)
+      dispose_words (multi_variables);
+  /****************************************************************************/
+
   dispose_words (releaser);
   discard_unwind_frame ("for");
   return (retval);
@@ -1880,6 +1977,9 @@
 	    break;
 	}
 
+      if (exception)		/* --William */
+	  break;
+
       /* Evaluate the step expression. */
       line_number = arith_lineno;
       expresult = eval_arith_for_expr (arith_for_command->step, &expok);
@@ -2189,6 +2289,9 @@
 	    break;
 	}
 
+      if (exception)		/* --William */
+	  break;
+
 #if defined (KSH_COMPATIBLE_SELECT)
       show_menu = 0;
       selection = get_string_value ("REPLY");
@@ -2220,6 +2323,8 @@
   char *word, *pattern;
   int retval, match, ignore_return, save_line_number;
 
+  case_command->total_match = 0;		/* --William */
+
   save_line_number = line_number;
   line_number = case_command->line;
 
@@ -2267,6 +2372,38 @@
       QUIT;
       for (list = clauses->patterns; list; list = list->next)
 	{
+
+#if defined (HAVE_POSIX_REGEXP)
+    /*********************************************************************
+     * If pattern list is terminated by '))', it is regex.  And, if it's
+     * terminated by the usual single ')', it's glob.
+     *  case ... in
+     *      glob ) action ;;
+     *      regex )) action ;;
+     *  esac
+     *
+     * For glob pattern, shell expansions (parameter expansion, command
+     * substitution, arithmetic expansion) are performed, and word
+     * splitting and quote removal are not done.  For regex pattern,
+     * quotes are removed and only word splitting is not done.  Otherwise,
+     * you can't use shell metacharacters.
+     *
+     * If there is a match, SUBMATCH will contain prefix, matching string
+     * and any parenthesized subgroup in regex pattern, and suffix, just
+     * like 'match' builtin.
+     *
+     * --William
+     */
+    if (clauses->glob_or_regex == 1) {    /* 0=glob, 1=regex */
+        es = expand_word_unsplit (list->word, 0);
+        if (es && es->word && es->word->word && *(es->word->word))
+      pattern = savestring (es->word->word);
+        else
+      pattern = savestring ("");
+
+        match = regex_match (word, pattern, "SUBMATCH") == EXECUTION_SUCCESS;
+    } else {    /* original code */
+#endif  /* HAVE_POSIX_REGEXP*/
 	  es = expand_word_leave_quoted (list->word, 0);
 
 	  if (es && es->word && es->word->word && *(es->word->word))
@@ -2281,6 +2418,8 @@
 	     Posix.2, section 3.9.4.3), the strmatch () call must be able
 	     to recognize backslashes as escape characters. */
 	  match = strmatch (pattern, word, FNMATCH_EXTFLAG|FNMATCH_IGNCASE) != FNM_NOMATCH;
+          }
+          /****************************************************************************************/
 	  free (pattern);
 
 	  dispose_words (es);
@@ -2290,6 +2429,31 @@
 	      if (clauses->action && ignore_return)
 		clauses->action->flags |= CMD_IGNORE_RETURN;
 	      retval = execute_command (clauses->action);
+
+	      /*****************************************************************
+	       * If ';;&', continue on with the next pattern test, instead of
+	       * terminating.  --William
+	       */
+	      case_command->total_match++;
+
+	      if (clauses->goto_next == 2)
+		  break;
+
+	      /* If ';&', then execute the next commands.  --William
+	       */
+	      if (clauses->goto_next == 1) {
+		  PATTERN_LIST *c;
+
+		  for (c = clauses->next; c; c = c->next) {
+		      if (c->action && ignore_return)
+			  c->action->flags |= CMD_IGNORE_RETURN;
+		      retval = execute_command (c->action);
+		      if (c->goto_next != 1)
+			  break;
+		  }
+	      }
+	      /****************************************************************/
+
 	      EXIT_CASE ();
 	    }
 
@@ -2298,6 +2462,23 @@
     }
 
 exit_case_command:
+
+  /*****************************************************************************
+   * Run THEN or ELSE commands if it's specified.
+   * --William
+   */
+  if (case_command->total_match && case_command->true_case) {
+      if (ignore_return)
+	  case_command->true_case->flags |= CMD_IGNORE_RETURN;
+      retval = execute_command (case_command->true_case);
+  }
+  if (! case_command->total_match && case_command->false_case) {
+      if (ignore_return)
+	  case_command->false_case->flags |= CMD_IGNORE_RETURN;
+      retval = execute_command (case_command->false_case);
+  }
+  /****************************************************************************/
+
   free (word);
   discard_unwind_frame ("case");
   line_number = save_line_number;
@@ -2367,6 +2548,9 @@
 	  break;
 	}
 
+      if (exception)		/* --William */
+	  break;
+
       QUIT;
       body_status = execute_command (while_command->action);
       QUIT;
@@ -2383,12 +2567,38 @@
 	  if (continuing)
 	    break;
 	}
+
+      if (exception)		/* --William */
+	  break;
     }
   loop_level--;
 
+  /*****************************************************************************
+   * Run THEN commands if while-loop or until-loop exits normally, and run ELSE
+   * commands if break is used.
+   * --William
+   */
+  if ((type == CMD_WHILE && return_value != EXECUTION_SUCCESS && while_command->then_action)
+    || (type == CMD_UNTIL && return_value == EXECUTION_SUCCESS && while_command->then_action)) {
+      if (while_command->flags & CMD_IGNORE_RETURN)
+	  while_command->then_action->flags |= CMD_IGNORE_RETURN;
+      body_status = execute_command (while_command->then_action);
+  }
+  if ((type == CMD_WHILE && return_value == EXECUTION_SUCCESS && while_command->else_action)
+    || (type == CMD_UNTIL && return_value != EXECUTION_SUCCESS && while_command->else_action)) {
+      if (while_command->flags & CMD_IGNORE_RETURN)
+	  while_command->else_action->flags |= CMD_IGNORE_RETURN;
+      body_status = execute_command (while_command->else_action);
+  }
+  /****************************************************************************/
+
   return (body_status);
 }
 
+
+#include "execute_cmd.2.c"		/* try-block  --William */
+
+
 /* IF test THEN command [ELSE command].
    IF also allows ELIF in the place of ELSE IF, but
    the parser makes *that* stupidity transparent. */
--- bash-3.2_orig/expr.c	2008-04-05 08:42:57.000000000 +0000
+++ bash-3.2/expr.c	2008-04-05 08:43:09.000000000 +0000
@@ -1096,7 +1096,13 @@
       lasttok = curtok;
       curtok = STR;
     }
+#if 1
   else if (DIGIT(c))
+#else
+  else if (DIGIT(c) || (c == '.' && cp && (c = *cp) && DIGIT(c)))
+    /* Since Bash doesn't have floating point support, use period (.) to start
+     * base64 number [0-9a-zA-Z@_].  So, '64#nnn' becomes '.nnn'. --William */
+#endif
     {
       while (ISALNUM (c) || c == '#' || c == '@' || c == '_')
 	c = *cp++;
--- bash-3.2_orig/lib/readline/Makefile.in	2008-04-05 08:42:57.000000000 +0000
+++ bash-3.2/lib/readline/Makefile.in	2008-04-05 08:43:09.000000000 +0000
@@ -115,7 +115,13 @@
 
 ##########################################################################
 
-all: libreadline.a libhistory.a
+# all: libreadline.a libhistory.a
+# Prevent libreadline.a and libhistory compiling in parallel.  Otherwise, they
+# overwrite each other, and 'make -j3' fails.  (from Bash mailing list).
+# --William
+all:
+	$(MAKE) libreadline.a
+	$(MAKE) libhistory.a
 
 libreadline.a: $(OBJECTS)
 	$(RM) $@
--- bash-3.2_orig/make_cmd.c	2008-04-05 08:42:57.000000000 +0000
+++ bash-3.2/make_cmd.c	2008-04-05 08:53:18.000000000 +0000
@@ -220,6 +220,10 @@
   temp->line = lineno;
   temp->map_list = map_list;
   temp->action = action;
+
+  temp->then_action = (COMMAND *)NULL;		/* --William */
+  temp->else_action = (COMMAND *)NULL;		/* --William */
+
   return (make_command (type, (SIMPLE_COM *)temp));
 }
 
@@ -368,6 +372,11 @@
   temp->line = lineno;
   temp->word = word;
   temp->clauses = REVERSE_LIST (clauses, PATTERN_LIST *);
+
+  temp->true_case = (COMMAND *)NULL;		/* --William */
+  temp->false_case = (COMMAND *)NULL;		/* --William */
+  temp->total_match = 0;			/* --William */
+
   return (make_command (cm_case, (SIMPLE_COM *)temp));
 }
 
@@ -381,7 +390,11 @@
   temp = (PATTERN_LIST *)xmalloc (sizeof (PATTERN_LIST));
   temp->patterns = REVERSE_LIST (patterns, WORD_LIST *);
   temp->action = action;
-  temp->next = NULL;
+
+  temp->next = (PATTERN_LIST *)NULL;  /* Fix: was just NULL  --William */
+  temp->glob_or_regex = 0;    /* --William */
+  temp->goto_next = 0;      /* --William */
+
   temp->flags = 0;
   return (temp);
 }
@@ -400,6 +413,26 @@
   return (make_command (cm_if, (SIMPLE_COM *)temp));
 }
 
+
+/*******************************************************************************
+ * --William
+ */
+COMMAND *
+make_try_command (action, clauses)
+    COMMAND *action;
+    PATTERN_LIST *clauses;
+{
+    TRY_COM *temp;
+
+    temp = (TRY_COM *)xmalloc (sizeof (TRY_COM));
+    temp->flags = 0;
+    temp->action = action;
+    temp->clauses = REVERSE_LIST (clauses, PATTERN_LIST *);
+    return (make_command (cm_try, (SIMPLE_COM *)temp));
+}
+/******************************************************************************/
+
+
 static COMMAND *
 make_until_or_while (which, test, action)
      enum command_type which;
@@ -411,6 +444,10 @@
   temp->flags = 0;
   temp->test = test;
   temp->action = action;
+
+  temp->then_action = (COMMAND *)NULL;		/* --William */
+  temp->else_action = (COMMAND *)NULL;		/* --William */
+
   return (make_command (which, (SIMPLE_COM *)temp));
 }
 
@@ -560,14 +597,18 @@
   char *redir_word, *document, *full_line;
   int document_index, document_size, delim_unquoted;
 
+  int i, j, first_indentation = -1;		/* <<+  --William */
+
   if (temp->instruction != r_deblank_reading_until &&
+      temp->instruction != r_deblank_reading_until_using_firstline &&	/* <<+  --William */
       temp->instruction != r_reading_until)
     {
       internal_error (_("make_here_document: bad instruction type %d"), temp->instruction);
       return;
     }
 
-  kill_leading = temp->instruction == r_deblank_reading_until;
+  kill_leading = (temp->instruction == r_deblank_reading_until || 
+	  temp->instruction == r_deblank_reading_until_using_firstline); /* <<+  --William */
 
   document = (char *)NULL;
   document_index = document_size = 0;
@@ -623,8 +664,48 @@
 	  if (STREQN (line, redir_word, redir_len) && line[redir_len] == '\n')
 	    goto document_done;
 
+	  /*********************************************************************
+	   * Remove leading indentation (spaces and tabs) on the first line.
+	   * And, remove the same indentation from the rest of lines.  Tab is
+	   * taken as 8 spaces.  So, the last line with delimiter must not have
+	   * more indentation than the first line.  --William
+	   */
+	  if (temp->instruction == r_deblank_reading_until_using_firstline) {
+	      if (first_indentation == -1) {
+		  first_indentation = 0;
+		  for ( ; whitespace (*line); line++) {
+		      if (*line == ' ')
+			  first_indentation += 1;
+		      else	/* <Tab> */
+			  first_indentation += (8 - first_indentation % 8);
+		  }
+	      } else {
+		  /* strip the leading whitespaces first, then put back
+		   * tabs/spaces. */
+		  i = 0;
+		  for ( ; whitespace (*line); line++) {
+		      if (*line == ' ')
+			  i += 1;
+		      else	/* <Tab> */
+			  i += (8 - i % 8);
+		  }
+		  if (i > first_indentation) {
+		      j = i - first_indentation;
+		      document_size = (document_size)? 2 * (document_size + j) : j + 2;
+		      document = (char *)xrealloc (document, document_size);
+		      j = (i - first_indentation) / 8;
+		      while (j-- > 0)
+			  document[document_index++] = '\t';
+		      j = (i - first_indentation) % 8;
+		      while (j-- > 0)
+			  document[document_index++] = ' ';
+		      document[document_index] = '\0';
+		  }
+	      }
+	  } else			/* original code */
 	  while (*line == '\t')
 	    line++;
+	  /********************************************************************/
 	}
 
       if (*line == 0)
@@ -703,8 +784,10 @@
       break;
 
     case r_deblank_reading_until: 	/* <<-foo */
+    case r_deblank_reading_until_using_firstline: 	/* <<+ file  --William */
     case r_reading_until:		/* << foo */
     case r_reading_string:		/* <<< foo */
+    case r_reading_herefile:				/* <<<< file  --William */
     case r_close_this:			/* <&- */
     case r_duplicating_input:		/* 1<&2 */
     case r_duplicating_output:		/* 1>&2 */
--- bash-3.2_orig/make_cmd.h	2008-04-05 08:42:57.000000000 +0000
+++ bash-3.2/make_cmd.h	2008-04-05 08:43:09.000000000 +0000
@@ -38,6 +38,7 @@
 extern COMMAND *make_command __P((enum command_type, SIMPLE_COM *));
 extern COMMAND *command_connect __P((COMMAND *, COMMAND *, int));
 extern COMMAND *make_for_command __P((WORD_DESC *, WORD_LIST *, COMMAND *, int));
+extern COMMAND *make_try_command __P((COMMAND *, PATTERN_LIST *));	/* --William */
 extern COMMAND *make_group_command __P((COMMAND *));
 extern COMMAND *make_case_command __P((WORD_DESC *, PATTERN_LIST *, int));
 extern PATTERN_LIST *make_pattern_list __P((WORD_LIST *, COMMAND *));
--- bash-3.2_orig/parse.y	2008-04-05 08:42:57.000000000 +0000
+++ bash-3.2/parse.y	2008-04-05 08:49:38.000000000 +0000
@@ -306,7 +306,9 @@
    in the case that they are preceded by a list_terminator.  Members
    of the second group are for [[...]] commands.  Members of the
    third group are recognized only under special circumstances. */
-%token IF THEN ELSE ELIF FI CASE ESAC FOR SELECT WHILE UNTIL DO DONE FUNCTION
+
+/* add TRY  --William */
+%token IF THEN ELSE ELIF FI CASE ESAC FOR TRY SELECT WHILE UNTIL DO DONE FUNCTION
 %token COND_START COND_END COND_ERROR
 %token IN BANG TIME TIMEOPT
 
@@ -318,6 +320,8 @@
 %token AND_AND OR_OR GREATER_GREATER LESS_LESS LESS_AND LESS_LESS_LESS
 %token GREATER_AND SEMI_SEMI LESS_LESS_MINUS AND_GREATER LESS_GREATER
 %token GREATER_BAR
+%token PAREN_CLOSE_CLOSE SEMI_AND SEMI_SEMI_AND		/* --William */
+%token LESS_LESS_PLUS LESS_LESS_LESS_LESS	/* <<+  <<<<  --William */
 
 /* The types that the various syntactical units return. */
 
@@ -325,6 +329,9 @@
 %type <command> list list0 list1 compound_list simple_list simple_list1
 %type <command> simple_command shell_command
 %type <command> for_command select_command case_command group_command
+
+%type <command> while_command until_command try_command		/* --William */
+
 %type <command> arith_command
 %type <command> cond_command
 %type <command> arith_for_command
@@ -442,6 +449,22 @@
 			  redir.filename = $3;
 			  $$ = make_redirection ($1, r_reading_string, redir);
 			}
+
+	/***********************************************************************
+	 * here-file:  [n]<<<<file  --William
+	 */
+	|	LESS_LESS_LESS_LESS WORD
+			{
+			  redir.filename = $2;
+			  $$ = make_redirection (0, r_reading_herefile, redir);
+			}
+	|	NUMBER LESS_LESS_LESS_LESS WORD
+			{
+			  redir.filename = $3;
+			  $$ = make_redirection ($1, r_reading_herefile, redir);
+			}
+	/**********************************************************************/
+
 	|	LESS_AND NUMBER
 			{
 			  redir.dest = $2;
@@ -496,6 +519,27 @@
 			    ($1, r_deblank_reading_until, redir);
 			  redir_stack[need_here_doc++] = $$;
 			}
+
+	/***********************************************************************
+	 * First input line will determine how many tabs to delete from the rest
+	 * of lines.  For <<+ redirection.  --William
+	 */
+	|	LESS_LESS_PLUS WORD
+			{
+			  redir.filename = $2;
+			  $$ = make_redirection
+			    (0, r_deblank_reading_until_using_firstline, redir);
+			  redir_stack[need_here_doc++] = $$;
+			}
+	|	NUMBER LESS_LESS_PLUS WORD
+			{
+			  redir.filename = $3;
+			  $$ = make_redirection
+			    ($1, r_deblank_reading_until_using_firstline, redir);
+			  redir_stack[need_here_doc++] = $$;
+			}
+	/**********************************************************************/
+
 	|	GREATER_AND '-'
 			{
 			  redir.dest = 0;
@@ -600,10 +644,14 @@
 			{ $$ = $1; }
 	|	case_command
 			{ $$ = $1; }
- 	|	WHILE compound_list DO compound_list DONE
-			{ $$ = make_while_command ($2, $4); }
-	|	UNTIL compound_list DO compound_list DONE
-			{ $$ = make_until_command ($2, $4); }
+
+	|	while_command
+			{ $$ = $1; }		/* Moved to below  --William */
+	|	until_command
+			{ $$ = $1; }		/* Moved to below  --William */
+	|	try_command
+			{ $$ = $1; }		/* Added  --William */
+
 	|	select_command
 			{ $$ = $1; }
 	|	if_command
@@ -660,6 +708,21 @@
 			  $$ = make_for_command ($2, (WORD_LIST *)NULL, $8, word_lineno[word_top]);
 			  if (word_top > 0) word_top--;
 			}
+
+	/***********************************************************************
+	 * Added then-else-fi construct.  --William
+	 */
+	|	for_command THEN compound_list FI
+			{ $$ = $1;
+			  $$->value.For->then_action = $3; }
+	|	for_command ELSE compound_list FI
+			{ $$ = $1;
+			  $$->value.For->else_action = $3; }
+	|	for_command THEN compound_list ELSE compound_list FI
+			{ $$ = $1;
+			  $$->value.For->then_action = $3;
+			  $$->value.For->else_action = $5; }
+	/**********************************************************************/
 	;
 
 arith_for_command:	FOR ARITH_FOR_EXPRS list_terminator newline_list DO compound_list DONE
@@ -731,7 +794,65 @@
 			  $$ = make_case_command ($2, $5, word_lineno[word_top]);
 			  if (word_top > 0) word_top--;
 			}
+
+	/***********************************************************************
+	 * Added then-else-fi construct.  --William
+	 */
+	|	case_command THEN compound_list FI
+			{ $$ = $1;
+			  $$->value.Case->true_case = $3; }
+	|	case_command ELSE compound_list FI
+			{ $$ = $1;
+			  $$->value.Case->false_case = $3; }
+	|	case_command THEN compound_list ELSE compound_list FI
+			{ $$ = $1;
+			  $$->value.Case->true_case = $3;
+			  $$->value.Case->false_case = $5; }
+	/**********************************************************************/
+	;
+
+
+/*******************************************************************************
+ * Moved 'while' and 'until' from above, and added then-else-fi contruct.  Also,
+ * new try-block for raising/catching exception.  --William
+ */
+while_command:	WHILE compound_list DO compound_list DONE
+			{ $$ = make_while_command ($2, $4); }
+ 	|	while_command THEN compound_list FI
+			{ $$ = $1; 
+			  $$->value.While->then_action = $3; }
+ 	|	while_command ELSE compound_list FI
+			{ $$ = $1;
+			  $$->value.While->else_action = $3; }
+ 	|	while_command THEN compound_list ELSE compound_list FI
+			{ $$ = $1;
+			  $$->value.While->then_action = $3;
+			  $$->value.While->else_action = $5; }
+	;
+
+until_command:	UNTIL compound_list DO compound_list DONE
+			{ $$ = make_until_command ($2, $4); }
+	|	until_command THEN compound_list FI
+			{ $$ = $1;
+			  $$->value.While->then_action = $3; }
+	|	until_command ELSE compound_list FI
+			{ $$ = $1;
+			  $$->value.While->else_action = $3; }
+	|	until_command THEN compound_list ELSE compound_list FI
+			{ $$ = $1;
+			  $$->value.While->then_action = $3;
+			  $$->value.While->else_action = $5; }
+	;
+
+try_command:	TRY compound_list DONE
+			{ $$ = make_try_command ($2, (PATTERN_LIST *)NULL); }
+	|	TRY compound_list DONE IN case_clause_sequence newline_list ESAC
+			{ $$ = make_try_command ($2, $5); }
+	|	TRY compound_list DONE IN case_clause ESAC
+			{ $$ = make_try_command ($2, $5); }
 	;
+/******************************************************************************/
+
 
 function_def:	WORD '(' ')' newline_list function_body
 			{ $$ = make_function_def ($1, $5, function_dstart, function_bstart); }
@@ -826,11 +947,52 @@
 			{ $$ = make_pattern_list ($3, $5); }
 	|	newline_list '(' pattern ')' newline_list
 			{ $$ = make_pattern_list ($3, (COMMAND *)NULL); }
+
+	/***********************************************************************
+	 * Use '))' to denote regex pattern in 'case' statement:
+	 *	case ... in
+	 *	    glob ) ... ;;
+	 *	    regex )) ... ;;
+	 *	esac
+	 * For the sake of simplicity, there is no optional '((' like glob
+	 * counterpart.  --William
+	 */
+	|	newline_list pattern PAREN_CLOSE_CLOSE compound_list
+			{ $$ = make_pattern_list ($2, $4);
+			  $$->glob_or_regex = 1; }
+	|	newline_list pattern PAREN_CLOSE_CLOSE newline_list
+			{ $$ = make_pattern_list ($2, (COMMAND *)NULL);
+			  $$->glob_or_regex = 1; }
+	/**********************************************************************/
 	;
 
 case_clause_sequence:  pattern_list SEMI_SEMI
 	|	case_clause_sequence pattern_list SEMI_SEMI
 			{ $2->next = $1; $$ = $2; }
+
+	/***********************************************************************
+	 * Add ';&' (from Ksh/Zsh) and ';;&' for falling through to the next
+	 * action:
+	 *	case ... in
+	 *	    pattern1) action1 ;&
+	 *	    pattern2) action2 ;;
+	 *	esac
+	 * If 'pattern1' matches, then 'action1' will be run, and then followed
+	 * by 'action2'.  This resembles C 'switch' when 'break' is missing.
+	 * For ';;&', test next pattern case, instead of terminating the case
+	 * statement.  --William
+	 */
+	|	pattern_list SEMI_AND
+			{ $$->goto_next = 1; }
+	|	case_clause_sequence pattern_list SEMI_AND
+			{ $2->next = $1; $$ = $2;
+			  $$->goto_next = 1; }
+	|	pattern_list SEMI_SEMI_AND
+			{ $$->goto_next = 2; }
+	|	case_clause_sequence pattern_list SEMI_SEMI_AND
+			{ $2->next = $1; $$ = $2;
+			  $$->goto_next = 2; }
+	/**********************************************************************/
 	;
 
 pattern:	WORD
@@ -1768,6 +1930,7 @@
   { "select", SELECT },
 #endif
   { "while", WHILE },
+  { "try", TRY },		/* --William */
   { "until", UNTIL },
   { "do", DO },
   { "done", DONE },
@@ -1797,8 +1960,13 @@
   { "<&", LESS_AND },
   { ">&", GREATER_AND },
   { ";;", SEMI_SEMI },
+  { ";&", SEMI_AND },			/* --William */
+  { ";;&", SEMI_SEMI_AND },		/* --William */
+  { "))", PAREN_CLOSE_CLOSE },		/* --William */
+  { "<<+", LESS_LESS_PLUS },		/* <<+  --William */
   { "<<-", LESS_LESS_MINUS },
   { "<<<", LESS_LESS_LESS },
+  { "<<<<", LESS_LESS_LESS_LESS },	/* <<<<  --William */
   { "&>", AND_GREATER },
   { "<>", LESS_GREATER },
   { ">|", GREATER_BAR },
@@ -2230,7 +2398,8 @@
 
 #define command_token_position(token) \
   (((token) == ASSIGNMENT_WORD) || \
-   ((token) != SEMI_SEMI && reserved_word_acceptable(token)))
+   ((token) != SEMI_SEMI && reserved_word_acceptable(token) && \
+    (token) != SEMI_AND && (token) != SEMI_SEMI_AND))		/* --William */
 
 #define assignment_acceptable(token) \
   (command_token_position(token) && ((parser_state & PST_CASEPAT) == 0))
@@ -2618,8 +2787,19 @@
 	      peek_char = shell_getc (1);
 	      if (peek_char == '-')
 		return (LESS_LESS_MINUS);
-	      else if (peek_char == '<')
-		return (LESS_LESS_LESS);
+
+	      else if (peek_char == '+')		/* <<+  --William */
+		return (LESS_LESS_PLUS);
+
+	      else if (peek_char == '<') {		/* <<<<  --William */
+		  peek_char = shell_getc (1);
+		  if (peek_char == '<')	
+		      return (LESS_LESS_LESS_LESS);
+		  else {
+		      shell_ungetc (peek_char);
+		      return (LESS_LESS_LESS);		/* original code */
+		  }
+	      }
 	      else
 		{
 		  shell_ungetc (peek_char);
@@ -2637,6 +2817,22 @@
 
 	      return (SEMI_SEMI);
 
+        /*****************************************************************
+         * It could be either ';;' or ';;&'.  --William
+         */
+        peek_char = shell_getc (1);
+        if (peek_char == '&')
+      return (SEMI_SEMI_AND);
+        else {
+      shell_ungetc (peek_char);
+      return (SEMI_SEMI);   /* original code */
+        }
+        /****************************************************************/
+
+      case ')':   /* '))' in case statement  --William */
+    parser_state &= ~PST_CASEPAT; /* end of pattern list */
+    return (PAREN_CLOSE_CLOSE);
+
 	    case '&':
 	      return (AND_AND);
 
@@ -2664,6 +2860,14 @@
       else if MBTEST(peek_char == '>' && character == '&')
 	return (AND_GREATER);
 
+      else if MBTEST(character == ';' && peek_char == '&') {	/* --William */
+	  parser_state |= PST_CASEPAT;
+#if defined (ALIAS)
+	  parser_state &= ~PST_ALEXPNEXT;
+#endif /* ALIAS */
+	  return (SEMI_AND);
+      }
+
       shell_ungetc (peek_char);
 
       /* If we look like we are reading the start of a function
@@ -3803,6 +4007,10 @@
     case IF:
     case OR_OR:
     case SEMI_SEMI:
+    case SEMI_AND:		/* --William */
+    case SEMI_SEMI_AND:		/* --William */
+    case PAREN_CLOSE_CLOSE:	/* --William */
+    case TRY:			/* --William */
     case THEN:
     case TIME:
     case TIMEOPT:
@@ -3864,6 +4072,7 @@
 static int no_semi_successors[] = {
   '\n', '{', '(', ')', ';', '&', '|',
   CASE, DO, ELSE, IF, SEMI_SEMI, THEN, UNTIL, WHILE, AND_AND, OR_OR, IN,
+  PAREN_CLOSE_CLOSE, SEMI_AND, SEMI_SEMI_AND, TRY,	/* --William */
   0
 };
 
--- bash-3.2_orig/print_cmd.c	2008-04-05 08:42:57.000000000 +0000
+++ bash-3.2/print_cmd.c	2008-04-05 08:43:10.000000000 +0000
@@ -91,6 +91,7 @@
 static void print_while_command __P((WHILE_COM *));
 static void print_until_command __P((WHILE_COM *));
 static void print_until_or_while __P((WHILE_COM *, char *));
+static void print_try_command __P((TRY_COM *));		/* --William */
 static void print_if_command __P((IF_COM *));
 #if defined (COND_COMMAND)
 static void print_cond_node __P((COND_COM *));
@@ -192,6 +193,10 @@
 	  print_until_command (command->value.While);
 	  break;
 
+	case cm_try:			/* --William */
+	  print_try_command (command->value.Try);
+	  break;
+
 	case cm_if:
 	  print_if_command (command->value.If);
 	  break;
@@ -318,6 +323,40 @@
   _print_word_list (list, separator, xprintf);
 }
 
+
+/*******************************************************************************
+ * Print THEN and ELSE sections, if present, in FOR, WHILE, UNTIL, and CASE
+ * statements.  Copied from print_if_command() below.
+ * --William
+ */
+static void
+print_then_else (then_action, else_action)
+    COMMAND *then_action, *else_action;
+{
+    if (then_action || else_action) {
+	if (then_action) {
+	    cprintf (" then\n");
+	    indentation += indentation_amount;
+	    make_command_string_internal (then_action);
+	    indentation -= indentation_amount;
+	    semicolon ();
+	}
+	if (else_action) {
+	    if (then_action)
+		newline ("else\n");
+	    else
+		cprintf (" else\n");
+	    indentation += indentation_amount;
+	    make_command_string_internal (else_action);
+	    indentation -= indentation_amount;
+	    semicolon ();
+	}
+	newline ("fi");
+    }
+}
+/******************************************************************************/
+
+
 /* Return a string denoting what our indirection level is. */
 
 char *
@@ -476,6 +515,9 @@
   semicolon ();
   indentation -= indentation_amount;
   newline ("done");
+
+  /* then-else-fi  --William */
+  print_then_else (for_command->then_action, for_command->else_action);
 }
 
 #if defined (ARITH_FOR_COMMAND)
@@ -594,6 +636,9 @@
   if (case_command->clauses)
     print_case_clauses (case_command->clauses);
   newline ("esac");
+
+  /* then-else-fi  --William */
+  print_then_else (case_command->true_case, case_command->false_case);
 }
 
 static void
@@ -605,11 +650,23 @@
     {
       newline ("");
       command_print_word_list (clauses->patterns, " | ");
-      cprintf (")\n");
+
+      if (clauses->glob_or_regex == 0)
+	  cprintf (")\n");		/* original code */
+      else
+	  cprintf ("))\n");		/* --William */
+
       indentation += indentation_amount;
       make_command_string_internal (clauses->action);
       indentation -= indentation_amount;
-      newline (";;");
+
+      if (clauses->goto_next == 0)
+	  newline (";;");			/* original code */
+      else if (clauses->goto_next == 1)
+	  newline (";&");			/* --William */
+      else if (clauses->goto_next == 2)
+	  newline (";&&");			/* --William */
+
       clauses = clauses->next;
     }
   indentation -= indentation_amount;
@@ -644,8 +701,33 @@
   indentation -= indentation_amount;
   semicolon ();
   newline ("done");
+
+  /* then-else-fi  --William */
+  print_then_else (while_command->then_action, while_command->else_action);
 }
 
+
+/*******************************************************************************
+ * try-block  --William
+ */
+static void
+print_try_command (try_command)
+    TRY_COM *try_command;
+{
+    cprintf ("try ");
+    indentation += indentation_amount;
+    make_command_string_internal (try_command->action);
+    indentation -= indentation_amount;
+    semicolon ();
+    newline ("done");
+
+    if (try_command->clauses)
+	print_case_clauses (try_command->clauses);
+    newline ("esac");
+}
+/******************************************************************************/
+
+
 static void
 print_if_command (if_command)
      IF_COM *if_command;
@@ -820,7 +902,9 @@
     {
       /* Defer printing the here documents until we've printed the
 	 rest of the redirections. */
-      if (redirects->instruction == r_reading_until || redirects->instruction == r_deblank_reading_until)
+      if (redirects->instruction == r_reading_until || 
+	  redirects->instruction == r_deblank_reading_until ||
+	  redirects->instruction == r_deblank_reading_until_using_firstline)	/* <<+  --William */
 	{
 	  newredir = copy_redirect (redirects);
 	  newredir->next = (REDIRECT *)NULL;
@@ -899,6 +983,7 @@
       break;
 
     case r_deblank_reading_until:
+    case r_deblank_reading_until_using_firstline:	/* <<+  --William */
       kill_leading++;
       /* ... */
     case r_reading_until:
@@ -909,27 +994,44 @@
 	{
 	  char *x;
 	  x = sh_single_quote (redirect->here_doc_eof);
+
+	  if (redirect->instruction == r_deblank_reading_until_using_firstline)	/* --William */
+	      cprintf ("<<%s%s\n", kill_leading? "+" : "", x);
+	  else			/* original code */
 	  cprintf ("<<%s%s\n", kill_leading? "-" : "", x);
 	  free (x);
 	}
       else
+	  if (redirect->instruction == r_deblank_reading_until_using_firstline)	/* --William */
+	      cprintf ("<<%s%s\n", kill_leading? "+" : "", redirect->here_doc_eof);
+	  else			/* original code */
 	cprintf ("<<%s%s\n", kill_leading? "-" : "", redirect->here_doc_eof);
+
       cprintf ("%s%s",
 	       redirect->redirectee.filename->word, redirect->here_doc_eof);
       break;
 
     case r_reading_string:
+    case r_reading_herefile:		/* <<<<  --William */
       if (redirector != 0)
 	cprintf ("%d", redirector);
       if (ansic_shouldquote (redirect->redirectee.filename->word))
 	{
 	  char *x;
 	  x = ansic_quote (redirect->redirectee.filename->word, 0, (int *)0);
+	  if (redirect->instruction == r_reading_herefile)	/* --William */
+	      cprintf ("<<<< %s", x);
+	  else		/* original code */
 	  cprintf ("<<< %s", x);
 	  free (x);
 	}
       else
+      {
+	  if (redirect->instruction == r_reading_herefile)	/* --William */
+	      cprintf ("<<<< %s", redirect->redirectee.filename->word);
+	  else		/* original code */
 	cprintf ("<<< %s", redirect->redirectee.filename->word);
+      }
       break;
 
     case r_duplicating_input:
--- bash-3.2_orig/redir.c	2008-04-05 08:42:57.000000000 +0000
+++ bash-3.2/redir.c	2008-04-05 08:43:10.000000000 +0000
@@ -54,6 +54,8 @@
 #  include "input.h"
 #endif
 
+#include "builtins/subroutines.h"		/* for slurp_filename_into_string()  --William */
+
 int expanding_redir;
 
 extern int posixly_correct;
@@ -713,6 +715,32 @@
       dispose_redirects (new_redirect);
     }
 
+
+  /*****************************************************************************
+   * Expand WORD just like <WORD, then masquerade as here-document.  As long as
+   * it's not here-string, it will default to here-document below.
+   * --William
+   */
+  if (ri == r_reading_herefile) {
+      if (posixly_correct && interactive_shell == 0) {
+	  oflags = redirectee->flags;
+	  redirectee->flags |= W_NOGLOB;
+	  redirectee_word = redirection_expand (redirectee);
+	  redirectee->flags = oflags;
+      } else
+	  redirectee_word = redirection_expand (redirectee);
+
+      if (redirectee_word == 0)
+	return (AMBIGUOUS_REDIRECT);
+
+      FREE (redirectee->word);
+      redirectee->word = slurp_filename_into_string (redirectee_word);
+      redirectee->flags = 0;
+      FREE (redirectee_word);
+  }
+  /****************************************************************************/
+
+
   switch (ri)
     {
     case r_output_direction:
@@ -817,7 +845,9 @@
 
     case r_reading_until:
     case r_deblank_reading_until:
+    case r_deblank_reading_until_using_firstline:	/* <<+  --William */
     case r_reading_string:
+    case r_reading_herefile:		/* <<<<  --William */
       /* REDIRECTEE is a pointer to a WORD_DESC containing the text of
 	 the new input.  Place it in a temporary file. */
       if (redirectee)
@@ -1054,7 +1084,9 @@
     case r_input_output:
     case r_reading_until:
     case r_deblank_reading_until:
+    case r_deblank_reading_until_using_firstline:	/* <<+  --William */
     case r_reading_string:
+    case r_reading_herefile:		/* <<<<  --William */
       return (1);
     case r_duplicating_input:
     case r_duplicating_input_word:
--- bash-3.2_orig/subst.2.c	1970-01-01 00:00:00.000000000 +0000
+++ bash-3.2/subst.2.c	2008-04-05 08:43:10.000000000 +0000
@@ -0,0 +1,937 @@
+/*******************************************************************************
+ * ${var|command}
+ *	Run `command var`.  If it returns something, then use it instead of the
+ *	original content in parameter expansion.  If it doesn't return anything
+ *	(ie. returns NULL), then skip.  This is shell version of Python list
+ *	comprehension.
+ *
+ * ${var|?command}
+ *	Run 'command var'.  If it returns success (0), then copy the content in
+ *	parameter expansion.
+ *
+ * ${var|[a:b]}
+ *	Return Python-style [a:b] range.  For string, extract string[a:b].  For
+ *	array or positional parameters, extract list[a:b].  For arrays, it's
+ *	referenced by storage order, not by index.  If ':b' is missing, then
+ *	string[a] or list[a] will be returned.  If index are outside the range,
+ *	then it will be removed from expansion.  This is different from
+ *	returning '' (null) string.
+ *
+ * ${var|/regex}
+ * ${var|=glob}
+ *	Return string that match 'regex' or 'glob' pattern, which are handled
+ *	like 'case' statement pattern.
+ * ${var|~regex}
+ * ${var|!glob}
+ *	Complement of '/' or '='.  Return string that do not match 'regex' or
+ *	'glob' pattern, which are handled like 'case' statement pattern.
+ *
+ * ${var|,sep}
+ *	Split string on 'sep', and return list items.  If it's in double quotes,
+ *	then "$@" behaviour is followed.  If the variable is list, then join
+ *	items into single string using 'sep' as separator.  One is inverse of
+ *	the other.  If 'sep' is null, then the string is treated as CSV (comma
+ *	separated values), and splitted on comma occurring outside of "...".
+ * ${var|-regex}
+ *	Split string on 'regex'.  That is, remove 'regex' from the string, and
+ *	return non-matching segments as list items.  If it's in double quotes,
+ *	then "$@" behaviour is followed.  If variable is list, then apply
+ *	splitting for each string in the list.
+ * ${var|+regex}
+ *	Split string on non-'regex'.  That is, extract 'regex' from the string,
+ *	and return matching segments as list items.  If it's in double quotes,
+ *	then "$@" behaviour is followed.  If variable is list, then apply
+ *	splitting for each string in the list.
+ * ${var|regex}
+ *	Both '-regex' and '+regex'.  That is, split string on 'regex', and
+ *	return both matching and non-matching segments.  Char '' is 177, 0261,
+ *	or 0xb1.
+ *	
+ * ${var|.strip}
+ *	Strip leading/trailing whitespaces, and collapse multiple whitespaces to
+ *	one space.  Same as `echo $var`.
+ * ${var|.lstrip}
+ * ${var|.rstrip}
+ * ${var|.lrstrip}
+ *	Strip leading, trailing, or both leading/trailing whitespaces.
+ * ${var|.strip0}
+ *	Strip leading '0' and whitespaces.
+ * ${var|.upper}
+ * ${var|.lower}
+ * ${var|.swapcase}
+ *	Convert to uppercase, lowercase, or toggle the case.
+ * ${var|.capitalize}
+ *	Capitalize the first char, and the rest to lowercase.
+ * ${var|.capwords}
+ *	Capitalize all whitespace-delimited words.
+ * ${var|.title}
+ *	Capitalize all alphabet words.
+ * ${var|.ascii}
+ *	Convert to 7-bit ASCII by clearing the high bit (mask 0x7f).
+ * ${var|.rev}
+ *	Flip string, like rev(1).
+ * ${var|.strfry}
+ *	Return random ordering of chars using strfry(3), ie. anagram.
+ * ${var|.singlequote}
+ * ${var|.doublequote}
+ * ${var|.backslashquote}
+ * ${var|.ansicquote}
+ *	Quote string using '...', "...", \, or $'...' mechanism.
+ * ${var|.csvquote}
+ *	Quote string for CSV format.  Essentially, " is doubled (""), and the
+ *	entire string is put in "..." if it contains comma, CR, or LF.
+ * ${var|.csvdequote}
+ *	Dequote string from CSV format.  Essentially, "" is reduced to single ",
+ *	and single " is removed.
+ * ${var|.htmlquote}
+ *	Convert < > & " ' chars to HTML/XML entities &lt; &gt; &amp; &quot;
+ *	&apos;
+ * ${var|.urldequote}
+ *	Convert %xx to ASCII char, and '+' to space.
+ * ${var|.regexquote}
+ *	Escape non-alphanumeric (plus '_') with backslash (\).
+ * ${var|.cent}
+ * ${var|.dollar}
+ *	Needed to handle "implied decimal".  If there is a decimal, then the
+ *	amount is in dollar.cent format; otherwise, it's in cent.  Convert one
+ *	format to another.  Return "0" or "0.00" on error.
+ *
+ * ${var|>n}
+ * ${var|<n}
+ *	Rotate right or left n chars.  Opposite direction if n is negative.
+ * ${var|*n}
+ *	Copy string or list 'n' times.
+ * ${var|%n.m}
+ *	Print string using '%n.ms' format of sprintf(3).
+ *
+ * ${var|@key}
+ *	Quick and cheap emulation of associative array.  Given array with linear
+ *	sequence of key/value pairs, ie.
+ *	    var=(key value key value ...)
+ *	for each matching 'key' string, return the next item as 'value'.  If
+ *	it's in double quotes, then "$@" behaviour is followed.  If the array
+ *	name is specified without subscript, then var[@] is assumed.
+ *
+ *	If key is omitted, then array index and value are serialized.  This is
+ *	equivalent to "zipping" ${!var[@]} and ${var[@]}.
+ *
+ * ${var|.base36}
+ *	Convert oct/dec/hex to base36 number [0-9A-Z].
+ *
+ * --William
+ */
+#include "builtins/subroutines.h"
+
+
+enum dot_method {
+    strip_method,		/* ${var|.strip}	*/
+    lrstrip_method,		/* ${var|.lrstrip}	*/
+    lstrip_method,		/* ${var|.lstrip}	*/
+    rstrip_method,		/* ${var|.rstrip}	*/
+    strip0_method,		/* ${var|.strip0}	*/
+    upper_method,		/* ${var|.upper}	*/
+    lower_method,		/* ${var|.lower}	*/
+    swapcase_method,		/* ${var|.swapcase}	*/
+    capitalize_method,		/* ${var|.capitalize}	*/
+    capwords_method,		/* ${var|.capwords}	*/
+    title_method,		/* ${var|.title}	*/
+    ascii_method,		/* ${var|.ascii}	*/
+    rev_method,			/* ${var|.rev}		*/
+    strfry_method,		/* ${var|.strfry}	*/
+    singlequote_method,		/* ${var|.singlequote}	*/
+    doublequote_method,		/* ${var|.doublequote}	*/
+    backslashquote_method,	/* ${var|.backslashquote} */
+    ansicquote_method,		/* ${var|.ansicquote}	*/
+    csvquote_method,		/* ${var|.csvquote}	*/
+    csvdequote_method,		/* ${var|.csvdequote}	*/
+    htmlquote_method,		/* ${var|.htmlquote}	*/
+    urldequote_method,		/* ${var|.urldequote}	*/
+    regexquote_method,		/* ${var|.regexquote}	*/
+    cent_method,		/* ${var|.cent}		*/
+    dollar_method,		/* ${var|.dollar}	*/
+    base36_method,		/* ${var|.base36}	*/
+};
+
+
+static int parse_colon_range		__P((char *, char, int *, int *, int));
+static char *python_string_method	__P((char *, enum dot_method));
+static char *string_pipe_operator	__P((char *, char *, enum dot_method, int));
+static char *vector_pipe_operator	__P((char **, char *, enum dot_method, int, int));
+static char *parameter_brace_commandsub	__P((char *, char *, char *, int, int *, int *));
+
+
+/* Parse 'a:b' range expression, in which 'a' and 'b' are full shell arithmetic
+ * expression.  Returns
+ *	0   -- error
+ *	1   -- 'a' is valid expressions, ':b' is missing
+ *	2   -- 'a' and 'b' are valid expressions
+ *
+ * Copied from verify_substring_values() which is called to handle subrange
+ * expression in
+ *	${var:a:n}
+ * by parameter_brace_substring().  I just need the 2 integers, without all the
+ * fluffs.
+ */
+static int
+parse_colon_range (range, sep, a, b, size)
+    char *range, sep;		/* usually 'a:b', but can be 'n.m' */
+    int *a, *b, size;
+{
+    char *t, *temp;
+    intmax_t x, y;
+    int expok;
+
+    t = skiparith (range, sep);		/* duplicate behavior of strchr(3) */
+    if (*t == sep)
+	*t = '\0';
+    else
+	t = (char *)NULL;
+
+    x = 0;
+    if (*range) {
+	temp = expand_string_if_necessary (range, Q_DOUBLE_QUOTES, expand_string);
+	x = evalexp (temp, &expok);
+	FREE (temp);
+	if (expok == 0 || x != (int)x) {
+	    if (t)
+		*t = sep;		/* restore the original string */
+	    return (0);
+	}
+    }
+    if (t == 0) {
+	if (a)
+	    *a = (int)x;
+	return (1);		/* only 'a' */
+    }
+
+    *t++ = sep;
+    y = size;
+    if (*t) {
+	temp = expand_string_if_necessary (t, Q_DOUBLE_QUOTES, expand_string);
+	y = evalexp (temp, &expok);
+	FREE (temp);
+	if (expok == 0 || y != (int)y)
+	    return (0);
+    }
+    if (a) *a = (int)x;
+    if (b) *b = (int)y;
+    return (2);			/* both 'a' and 'b' */
+}
+
+
+/* Bunch of string operations, like Python string method.  Return new string.
+ */
+char *
+python_string_method (val, method)
+    char *val;
+    enum dot_method method;
+{
+    char *out, *t;
+    int i, size;
+    intmax_t x, y;
+
+    size = strlen (val);
+    out = (char *)NULL;
+
+    switch (method) {
+    /* Quote string using '...', "...", \, or $'...' mechanism. */
+    case singlequote_method:
+	out = sh_single_quote (val);
+	break;
+    case doublequote_method:
+	out = sh_double_quote (val);
+	break;
+    case backslashquote_method:
+	out = sh_backslash_quote (val);
+	break;
+    case ansicquote_method:
+	out = ansic_quote (val, 0, (int *)NULL /* rlen */);
+	break;
+
+    case csvquote_method:
+	out = csv_quote (val);
+	break;
+    case csvdequote_method:
+	out = csv_dequote (val);
+	break;
+
+    case urldequote_method:
+	out = url_dequote (val);
+	break;
+	
+    case htmlquote_method:
+	out = html_quote (val);
+	break;
+    case regexquote_method:
+	out = regex_quote (val);
+	break;
+
+    case strip_method:
+	out = strip_leading_trailing (val, STRIP_ALL);
+	break;
+    case lrstrip_method:
+	out = strip_leading_trailing (val, STRIP_LR);
+	break;
+    case lstrip_method:
+	out = strip_leading_trailing (val, STRIP_L);
+	break;
+    case rstrip_method:
+	out = strip_leading_trailing (val, STRIP_R);
+	break;
+    case strip0_method:
+	out = strip_leading_trailing (val, STRIP_L0);
+	break;
+
+    /* Convert to uppercase, lowercase, or toggle the case.  */
+    case upper_method:
+	out = savestring (val);
+	for (t = out; *t; t++)
+	    *t = TOUPPER (*t);
+	break;
+    case lower_method:
+	out = savestring (val);
+	for (t = out; *t; t++)
+	    *t = TOLOWER (*t);
+	break;
+    case swapcase_method:
+	out = savestring (val);
+	for (t = out; *t; t++) {
+	    if (ISLOWER (*t))
+		*t = TOUPPER (*t);
+	    else if (ISUPPER (*t))
+		*t = TOLOWER (*t);
+	}
+	break;
+
+    /* Capitalize the first char, and the rest to lowercase. */
+    case capitalize_method:
+	out = savestring (val);
+	if (out[0]) {
+	    for (t = out; *t; t++)
+		*t = TOLOWER (*t);
+	    out[0] = TOUPPER (out[0]);
+	}
+	break;
+
+    /* Capitalize all whitespace-delimited words. */
+    case capwords_method:
+	out = savestring (val);
+	if (out[0]) {
+	    for (t = out + 1; *t; t++)
+		if (ISSPACE (t[-1]) && ISLETTER (*t))
+		    *t = TOUPPER (*t);
+		else 
+		    *t = TOLOWER (*t);
+	    out[0] = TOUPPER (out[0]);
+	}
+	break;
+
+    /* Capitalize all alphabet words. */
+    case title_method:
+	out = savestring (val);
+	if (out[0]) {
+	    for (t = out + 1; *t; t++)
+		if (! ISLETTER (t[-1]) && ISLETTER (*t))
+		    *t = TOUPPER (*t);
+		else 
+		    *t = TOLOWER (*t);
+	    out[0] = TOUPPER (out[0]);
+	}
+	break;
+
+    /* Convert to 7-bit ASCII by clearing the high bit (mask 0x7f). */
+    case ascii_method:
+	out = savestring (val);
+	for (t = out; *t; t++)
+	    *t = toascii (*t);
+	break;
+
+    /* Flip string, like rev(1). */
+    case rev_method:
+	out = savestring (val);
+	for (i = 0; i < size; i++)
+	    out[i] = val[size - 1 - i];
+	break;
+
+    /* Convert between dollar.cent "%.2f" and cent "%d" format. */
+    case cent_method:
+	out = convert_to_cent (val);
+	break;
+    case dollar_method:
+	out = convert_to_dollar (val);
+	break;
+
+    /* Convert to base36 number [0-9A-Z] */
+    case base36_method:
+	out = convert_to_base36 (val, 0, 36);
+	break;
+#if 0
+    /* Return random ordering of chars using strfry(3), ie. anagram.  strfry(3)
+     * is causing segfault in Slackware-10.2 (glibc-2.3.5).  So, comment it out.
+     */
+    case strfry_method:
+	out = savestring (val);
+	strfry (out);
+	break;
+#endif
+    }
+    return (out);
+}
+
+
+/* ${string|...}
+ */
+static char *
+string_pipe_operator (val, command, method, mflags)
+    char *val, *command;
+    enum dot_method method;
+    int mflags;
+{
+    int a, b, size, i, n;
+    char *out, *t, *regex, *glob;
+    WORD_LIST *es, *list;
+    WORD_DESC *w;
+
+    if (val == 0)
+	return (char *)NULL;
+
+    size = strlen (val);
+
+    switch (command[0]) {
+    case '.':
+	return (python_string_method (val, method));
+
+    case ',':
+#if defined (HAVE_POSIX_REGEXP)
+    case '-':
+    case '+':
+    case '\261':	/*  (177, 0261, 0xb1) */
+#endif
+	regex = expand_string_unsplit_to_string (command + 1, 0);
+	if (regex == 0)
+	    regex = savestring ("");
+	if (command[0] == ',')
+	    list = string_minus_separator (val, regex);
+#if defined (HAVE_POSIX_REGEXP)
+	else
+	    list = string_plusminus_regex (val, command[0], regex);
+#endif
+	FREE (regex);
+
+	if (list == 0)		/* empty result to be removed */
+	    return (char *)NULL;
+
+	/* Split operation converts string into $@.  When inside double quotes,
+	 * they must generate separate arguments, like "$@"; so, quote the list,
+	 * and join with ' ' (one space).
+	 */
+	if (mflags & MATCH_QUOTED)
+	    list = quote_list (list);
+	out = string_list (list);	/* join with ' ', like $@ */
+
+	dispose_words (list);
+	return (out);
+
+    case '<':
+	parse_colon_range (command + 1, ':', &n, (int *)NULL, 0);
+	return (rotate_string (val, n));
+
+    case '>':
+	parse_colon_range (command + 1, ':', &n, (int *)NULL, 0);
+	return (rotate_string (val, -n));
+
+    case '[':		/* [a:b] */
+	if (parse_colon_range (command + 1, ':', &a, &b, size) == 1) {
+	    b = a + 1;
+	    if (b == 0)
+		b = size;
+	}
+	adjust_python_range (&a, &b, size);
+	if (a < b)
+	    return (substring (val, a, b));
+	else
+	    return (char *)NULL;
+
+    case '*':		/* string * n */
+	parse_colon_range (command + 1, ':', &n, (int *)NULL, 0);
+	b = abs(n) * size;	/* output size */
+	out = (char *)xmalloc (b + 1);
+	for (a = 0; a < b; a += size)
+	    strcpy (out + a, val);
+	out[a] = '\0';		/* in case n=0 */
+	if (n < 0) {
+	    char c;
+	    for (a = 0; a < b/2; a++) {
+		c = out[a];
+		out[a] = out[b-1 - a];
+		out[b-1 - a] = c;
+	    }
+	}
+	return (out);
+
+    case '%':		/* %n.m */
+	switch (parse_colon_range (command + 1, '.', &a, &b, 0)) {
+	case 1:
+	    n = imax(abs(a), size);
+	    out = (char *)xmalloc (n + 1);
+	    sprintf (out, "%*s", a, val);
+	    return (out);
+	case 2:
+	    n = imax(abs(a), size);
+	    out = (char *)xmalloc (n + 1);
+	    sprintf (out, "%*.*s", a, b, val);
+	    return (out);
+	}
+
+#if defined (HAVE_POSIX_REGEXP)
+    case '/':		/* regex -- same as 'case' statement */
+    case '~':
+	w = make_word (command + 1);
+	es = expand_word_unsplit (w, 0);
+	if (es && es->word && es->word->word && *(es->word->word))
+	    regex = savestring (es->word->word);
+	else
+	    regex = savestring ("");
+	dispose_words (es);
+	dispose_word (w);
+	switch (command[0]) {
+	case '/':
+	    if (regex_match (val, regex, (char *)NULL) == EXECUTION_SUCCESS)
+		out = savestring (val);
+	    else
+		out = (char *)NULL;
+	    break;
+	case '~':
+	    if (regex_match (val, regex, (char *)NULL) == EXECUTION_SUCCESS)
+		out = (char *)NULL;
+	    else
+		out = savestring (val);
+	    break;
+	}
+	FREE (regex);
+	return (out);
+#endif
+
+    case '=':		/* glob -- same as 'case' statement */
+    case '!':
+	w = make_word (command + 1);
+	es = expand_word_leave_quoted (w, 0);
+	if (es && es->word && es->word->word && *(es->word->word))
+	    glob = quote_string_for_globbing (es->word->word, QGLOB_CVTNULL);
+	else
+	    glob = savestring ("");
+	dispose_words (es);
+	dispose_word (w);
+	switch (command[0]) {
+	case '=':
+	    if (strmatch (glob, val, FNMATCH_EXTFLAG) != FNM_NOMATCH)
+		out = savestring (val);
+	    else
+		out = (char *)NULL;
+	    break;
+	case '!':
+	    if (strmatch (glob, val, FNMATCH_EXTFLAG) != FNM_NOMATCH)
+		out = (char *)NULL;
+	    else
+		out = savestring (val);
+	    break;
+	}
+	FREE (glob);
+	return (out);
+
+    case '?':
+	out = savestring (command + 1);
+	out = build_eval_string (out, val);
+	    /* 'out' is freed */
+	if (parse_and_execute (out, "list comprehension", SEVAL_NOHIST | SEVAL_NONINT) == EXECUTION_SUCCESS)
+	    return (savestring (val));
+	else 
+	    return (char *)NULL;
+
+    default:
+	return (replace_string (command, val));
+    }
+}
+
+
+/* ${var[*]|...}, ${var[@]|...}, ${*|...}, ${@|...}
+ * Copied from pos_params_pat_subst().
+ */
+static char *
+vector_pipe_operator (vec, command, method, mflags, vtype)
+    char **vec, *command;
+    enum dot_method method;
+    int mflags, vtype;
+{
+    int a, b, size, i, n;
+    char *out, *regex, *sep;
+    WORD_LIST *list, *p;
+
+    if (vec == 0 || *vec == 0)
+	return (char *)NULL;
+
+    size = strvec_len (vec);
+    list = (WORD_LIST *)NULL;
+
+    switch (command[0]) {
+    case '@':		/* key/value pairs */
+	for (i = 0; i < size; i += 2)
+	    if (STREQ (command + 1, vec[i]) && vec[i+1])
+		list = make_word_list (make_bare_word (vec[i+1]), list);
+	break;
+
+    /* Special case: join operation produces a single string.  So, generate list
+     * with only one item.
+     */
+    case ',':
+	p = strvec_to_word_list (vec, 1 /* alloc */, 0);
+	sep = expand_string_unsplit_to_string (command + 1, 0);
+	out = string_list_internal (p, sep);
+	dispose_words (p);
+	FREE (sep);
+	list = make_word_list (make_bare_word (out), (WORD_LIST *)NULL);
+	FREE (out);
+	break;
+
+#if defined (HAVE_POSIX_REGEXP)
+    case '-':		/* recursive split on 'regex' */
+    case '+':
+    case '\261':	/*  (177, 0261, 0xb1) */
+	regex = expand_string_unsplit_to_string (command + 1, 0);
+	for (i = 0; i < size; i++) {
+	    p = string_plusminus_regex (vec[i], command[0], regex);
+	    if (p)	/* p is being used.  Don't free. */
+		list = (WORD_LIST *)list_append (list, p);
+	}
+	list = REVERSE_LIST (list, WORD_LIST *);
+	FREE (regex);
+	break;
+#endif
+
+    case '[':		/* [a:b] */
+	switch (vtype) {
+	case VT_ARRAYVAR:
+	    if (parse_colon_range (command + 1, ':', &a, &b, size) == 1) {
+		b = a + 1;
+		if (b == 0)
+		    b = size;
+	    }
+	    adjust_python_range (&a, &b, size);
+	    for (i = a; i < b; i++)
+		list = make_word_list (make_bare_word (vec[i]), list);
+	    break;
+	case VT_POSPARMS:
+	    if (parse_colon_range (command + 1, ':', &a, &b, size + 1) == 1) {
+		b = a + 1;
+		if (b == 0)
+		    b = size + 1;
+	    }
+	    adjust_python_range (&a, &b, size + 1);
+	    if (--a < 0) a = 0;
+	    if (--b < 0) b = 0;
+	    for (i = a; i < b; i++)
+		list = make_word_list (make_bare_word (vec[i]), list);
+	    break;
+	}
+	break;
+
+    case '*':		/* string * n */
+	parse_colon_range (command + 1, ':', &n, (int *)NULL, 0);
+	b = abs(n) * size;	/* output size */
+	for (a = 0; a < b; a += size)
+	    for (i = 0; i < size; i++)
+		list = make_word_list (make_bare_word (vec[i]), list);
+	if (n < 0) 
+	    list = REVERSE_LIST (list, WORD_LIST *);
+	break;
+
+    case '<':
+    case '>':
+#if defined (HAVE_POSIX_REGEXP)
+    case '/':
+    case '~':
+#endif
+    case '=':
+    case '!':
+    case '%':
+    case '.':
+    case '?':
+    default:
+	for (i = 0; i < size; i++) {
+	    out = string_pipe_operator (vec[i], command, method, mflags);
+	    if (out)
+		list = make_word_list (make_bare_word (out), list);
+	    FREE (out);
+	}
+	break;
+    }
+
+    if (list == 0)		/* empty result to be removed */
+	return (char *)NULL;
+
+    list = REVERSE_LIST (list, WORD_LIST *);
+    if (mflags & MATCH_QUOTED && mflags & MATCH_STARSUB) {
+	list = quote_list (list);
+	out = string_list_dollar_star (list);
+    } else {
+	if (mflags & MATCH_QUOTED)
+	    list = quote_list (list);
+	out = string_list (list);
+    }
+    dispose_words (list);
+    return (out);
+}
+
+
+/* Perform command substitution on VALUE, which is the expansion of VARNAME.
+ * COMMAND is the command to run.  QUOTED is a flags word containing the type of
+ * quoting currently in effect.  Copied from parameter_brace_patsub().
+ */
+static char *
+parameter_brace_commandsub (varname, value, command, quoted, quoted_dollar_atp, contains_dollar_at)
+    char *varname, *value, *command;
+    int quoted, *quoted_dollar_atp, *contains_dollar_at;
+{
+    int vtype, mflags, size;
+    char *val, *temp, *tt;
+    SHELL_VAR *v;
+    char **vec;
+    enum dot_method method;
+    WORD_LIST *list;
+
+    this_command_name = varname;
+
+    /* Check for syntax errors.
+     */
+    switch (command[0]) {
+    case '@':		/* empty key okey */
+	/* Emulate $@ behaviour, when '@' is given.  If there is no match, then
+	 * the pattern will be removed.
+	 */
+	chk_atstar ("@", quoted, quoted_dollar_atp, contains_dollar_at);
+	break;
+
+    case ',':		/* empty separator okey */
+	break;
+
+    case '<':
+    case '>':
+	if (parse_colon_range (command + 1, ':', (int *)NULL, (int *)NULL, 0) != 1) {
+	    internal_error ("`%s': expected one integer", command);
+	    return (&expand_param_error);
+	}
+	break;
+
+    case '[':
+	size = strlen (command);
+	if (command[size - 1] != ']') {
+	    internal_error ("`%s': expected [a:b] range", command);
+	    return (&expand_param_error);
+	}
+	command[size - 1] = '\0';
+	if (parse_colon_range (command + 1, ':', (int *)NULL, (int *)NULL, 0) == 0) {
+	    command[size - 1] = ']';
+	    internal_error ("`%s': expected [a:b] range", command);
+	    return (&expand_param_error);
+	}
+	break;
+
+    case '*':
+	if (parse_colon_range (command + 1, ':', (int *)NULL, (int *)NULL, 0) != 1) {
+	    internal_error ("`%s': expected one integer", command);
+	    return (&expand_param_error);
+	}
+	break;
+
+#if defined (HAVE_POSIX_REGEXP)
+    case '/':
+    case '~':
+    case '-':
+    case '+':
+    case '\261':	/*  (177, 0261, 0xb1) */
+#endif
+    case '=':
+    case '!':
+	if (command[1] == '\0') {
+	    internal_error ("`%s': expected regex or glob", command);
+	    return (&expand_param_error);
+	}
+	break;
+
+    case '%':
+	if (parse_colon_range (command + 1, '.', (int *)NULL, (int *)NULL, 0) == 0) {
+	    internal_error ("`%s': expected %%n.m format", command);
+	    return (&expand_param_error);
+	}
+	break;
+
+    case '.':
+	if (command[1] == '\0') {
+	    internal_error ("`%s': expected .method format", command);
+	    return (&expand_param_error);
+	}
+	else if (STREQ (command + 1, "strip")) method = strip_method;
+	else if (STREQ (command + 1, "lrstrip")) method = lrstrip_method;
+	else if (STREQ (command + 1, "lstrip")) method = lstrip_method;
+	else if (STREQ (command + 1, "rstrip")) method = rstrip_method;
+	else if (STREQ (command + 1, "strip0")) method = strip0_method;
+	else if (STREQ (command + 1, "upper")) method = upper_method;
+	else if (STREQ (command + 1, "lower")) method = lower_method;
+	else if (STREQ (command + 1, "swapcase")) method = swapcase_method;
+	else if (STREQ (command + 1, "capitalize")) method = capitalize_method;
+	else if (STREQ (command + 1, "capwords")) method = capwords_method;
+	else if (STREQ (command + 1, "title")) method = title_method;
+	else if (STREQ (command + 1, "ascii")) method = ascii_method;
+	else if (STREQ (command + 1, "rev")) method = rev_method;
+	else if (STREQ (command + 1, "strfry")) method = strfry_method;
+	else if (STREQ (command + 1, "singlequote")) method = singlequote_method;
+	else if (STREQ (command + 1, "doublequote")) method = doublequote_method;
+	else if (STREQ (command + 1, "backslashquote")) method = backslashquote_method;
+	else if (STREQ (command + 1, "ansicquote")) method = ansicquote_method;
+	else if (STREQ (command + 1, "csvquote")) method = csvquote_method;
+	else if (STREQ (command + 1, "csvdequote")) method = csvdequote_method;
+	else if (STREQ (command + 1, "htmlquote")) method = htmlquote_method;
+	else if (STREQ (command + 1, "urldequote")) method = urldequote_method;
+	else if (STREQ (command + 1, "regexquote")) method = regexquote_method;
+	else if (STREQ (command + 1, "cent")) method = cent_method;
+	else if (STREQ (command + 1, "dollar")) method = dollar_method;
+	else if (STREQ (command + 1, "base36")) method = base36_method;
+	else {
+	    internal_error ("`%s': unknown string method", command);
+	    return (&expand_param_error);
+	}
+	break;
+
+    case '?':
+	if (legal_identifier (command + 1) == 0) {
+	    internal_error ("`%s': invalid command", command);
+	    return (&expand_param_error);
+	}
+	break;
+
+    default:
+	if (legal_identifier (command) == 0) {
+	    internal_error ("`%s': invalid command", command);
+	    return (&expand_param_error);
+	}
+	break;
+    }
+
+    vtype = get_var_and_type (varname, value, quoted, &v, &val);
+    if (vtype == -1)
+	return (char *)NULL;
+
+    /* If it's just array name, it was interpreted as array[0] by
+     * get_var_and_type().  Change it back to mean array[@] for key/value pairs.
+     */
+    if (command[0] == '@') {
+	if (vtype == VT_ARRAYMEMBER && ! valid_array_reference (varname)) {
+	    vtype = VT_ARRAYVAR;
+	    val = (char *)array_cell (v);
+	} else if (vtype == VT_VARIABLE || vtype == VT_ARRAYMEMBER) {
+	    if (vtype == VT_VARIABLE)
+		FREE (val);
+	    internal_error ("key/value pairs not applicable for string");
+	    return (&expand_param_error);
+	}
+    }
+
+    mflags = 0;
+    if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
+	mflags |= MATCH_QUOTED;
+
+    if (vtype & VT_STARSUB) {
+	vtype &= ~VT_STARSUB;
+	mflags |= MATCH_STARSUB;
+    }
+
+    if (val == 0)
+	return (char *) NULL;
+
+    /* The pattern matching code doesn't understand CTLESC quoting CTLESC and
+     * CTLNUL so we use the dequoted variable values passed in (VT_VARIABLE) so
+     * the pattern substitution code works right.  We need to requote special
+     * chars after we're done for VT_VARIABLE and VT_ARRAYMEMBER, and for the
+     * other cases if QUOTED == 0, since the posparams and arrays indexed by '*'
+     * or '@' do special things when QUOTED != 0.
+     */
+    switch (vtype) {
+    case VT_VARIABLE:
+    case VT_ARRAYMEMBER:
+	temp = string_pipe_operator (val, command, method, mflags);
+	if (vtype == VT_VARIABLE)
+	    FREE (val);
+
+	/* Split operation must behave like $@, so that we get multiple items
+	 * when inside double quotes.  So, fake it, by following VT_POSPARMS or
+	 * VT_ARRAYVAR behaviour below.
+	 */
+	switch (command[0]) {
+	case ',':
+#if defined (HAVE_POSIX_REGEXP)
+	case '-':
+	case '+':
+	case '\261':	/*  (177, 0261, 0xb1) */
+#endif
+	    if (temp && (mflags & MATCH_QUOTED) == 0) {
+		tt = quote_escapes (temp);
+		free (temp);
+		temp = tt;
+	    }
+	    chk_atstar ("@", quoted, quoted_dollar_atp, contains_dollar_at);
+	    break;
+	default:
+	    if (temp) {
+		tt = quote_escapes (temp);
+		free (temp);
+		temp = tt;
+	    }
+	    break;
+	}
+	break;
+
+    case VT_POSPARMS:
+#if defined (ARRAY_VARS)
+    case VT_ARRAYVAR: 
+	if (vtype == VT_ARRAYVAR && command[0] == '@' && command[1] == '\0') {
+	    list = serialize_arrayvar (v);
+	    if (list == 0)		/* empty result to be removed */
+		return (char *)NULL;
+	    if (mflags & MATCH_QUOTED && mflags & MATCH_STARSUB) {
+		list = quote_list (list);
+		temp = string_list_dollar_star (list);
+	    } else {
+		if (mflags & MATCH_QUOTED)
+		    list = quote_list (list);
+		temp = string_list (list);
+	    }
+	    dispose_words (list);
+	}
+	else if (vtype == VT_ARRAYVAR) {
+	    vec = argv_from_array (array_cell (v), 1 /* alloc */);
+	    temp = vector_pipe_operator (vec, command, method, mflags, vtype);
+	    strvec_dispose (vec);
+	}
+	else
+#endif
+	{
+	    vec = argv_from_parameters (1 /* alloc */);
+	    temp = vector_pipe_operator (vec, command, method, mflags, vtype);
+	    strvec_dispose (vec);
+	}
+	/* 'vec' must be a copy, because parse_and_execute() called by
+	 * ${var|?func} runs at the same level.  Any change to original variable
+	 * by 'func' will turn 'vec' into dangling pointers.  This is especially
+	 * true for positional parameters.
+	 */
+
+	if (temp && (mflags & MATCH_QUOTED) == 0) {
+	    tt = quote_escapes (temp);
+	    free (temp);
+	    temp = tt;
+	}
+	break;
+    }
+
+    return (temp);
+}
--- bash-3.2_orig/subst.c	2008-04-05 08:42:57.000000000 +0000
+++ bash-3.2/subst.c	2008-04-05 08:45:14.000000000 +0000
@@ -5617,6 +5617,10 @@
   return temp;
 }
 
+
+#include "subst.2.c"		/* parameter_brace_commandsub()  --William */
+
+
 /****************************************************************/
 /*								*/
 /* Functions to perform pattern substitution on variable values */
@@ -5947,6 +5951,7 @@
   WORD_DESC *tdesc, *ret;
   int t_index, sindex, c, tflag;
   intmax_t number;
+  int want_commandsub = 0;		/* add |  --William */
 
   value = (char *)NULL;
   var_is_set = var_is_null = var_is_special = check_nullness = 0;
@@ -5958,7 +5963,7 @@
   if (string[t_index] == '#' && legal_variable_starter (string[t_index+1]))		/* {{ */
     name = string_extract (string, &t_index, "}", EX_VARNAME);
   else
-    name = string_extract (string, &t_index, "#%:-=?+/}", EX_VARNAME);
+    name = string_extract (string, &t_index, "#%:-=?+/|}", EX_VARNAME);
 
   ret = 0;
   tflag = 0;
@@ -5978,7 +5983,7 @@
     {
       t_index++;
       free (name);
-      temp1 = string_extract (string, &t_index, "#%:-=?+/}", 0);
+      temp1 = string_extract (string, &t_index, "#%:-=?+/|}", 0);	/* add |  --William */
       name = (char *)xmalloc (3 + (strlen (temp1)));
       *name = string[sindex];
       if (string[sindex] == '!')
@@ -6013,6 +6018,9 @@
   else if (c == '/' && string[sindex] != RBRACE)
     want_patsub = 1;
 
+  else if (c == '|' && string[sindex] != RBRACE)	/* add |  --William */
+      want_commandsub = 1;
+
   /* Catch the valid and invalid brace expressions that made it through the
      tests above. */
   /* ${#-} is a valid expansion and means to take the length of $-.
@@ -6028,7 +6036,7 @@
 
   /* ...but ${#%}, ${#:}, ${#=}, ${#+}, and ${#/} are errors. */
   if (name[0] == '#' && name[1] == '\0' && check_nullness == 0 &&
-	member (c, "%:=+/") && string[sindex] == RBRACE)
+	member (c, "%:=+/|") && string[sindex] == RBRACE)		/* add |  --William */
     {
       temp = (char *)NULL;
       goto bad_substitution;
@@ -6233,6 +6241,18 @@
       return ret;
     }
 
+  /*****************************************************************************
+   * ${var|command}  --William
+   */
+  else if (want_commandsub) {
+      temp1 = parameter_brace_commandsub (name, temp, value, quoted, quoted_dollar_atp, contains_dollar_at);
+      FREE (name);
+      FREE (value);
+      FREE (temp);
+      return (temp1);
+  }
+  /****************************************************************************/
+
   /* Do the right thing based on which character ended the variable name. */
   switch (c)
     {
--- bash-3.2_orig/support/bashbug.sh	2008-04-05 08:42:57.000000000 +0000
+++ bash-3.2/support/bashbug.sh	2008-04-05 08:43:10.000000000 +0000
@@ -103,6 +103,7 @@
 BASHTESTERS="bash-testers@cwru.edu"
 
 case "$RELSTATUS" in
+[Ww]illiam*|bashdiff*)	BUGBASH=opengeometry@yahoo.ca ;;	# --William 
 alpha*|beta*|devel*|rc*)	BUGBASH=chet@cwru.edu ;;
 *)				BUGBASH=bug-bash@gnu.org ;;
 esac
